{
    "title": "Newclid A User-Friendly Replacement for AlphaGeometry",
    "abstract": "We introduce a new symbolic solver for geometry, called Newclid, which is based on AlphaGeometry. Newclid contains a symbolic solver called DDARN (derived from DDAR- Newclid), which is a significant refactoring and upgrade of AlphaGeometry’s DDAR symbolic solver by being more user-friendly - both for the end user as well as for a programmer wishing to extend the codebase. For the programmer, improvements include a modularized codebase and new debugging and visualization tools. For the user, Newclid contains a new command line interface (CLI) that provides interfaces for agents to guide DDARN. DDARN is flexible with respect to its internal reasoning, which can be steered by agents. Further, we support input from GeoGebra to make Newclid accessible for educational contexts. Further, the scope of problems that Newclid can solve has been expanded to include the ability to have an improved understanding of metric geometry concepts (length, angle) and to use theorems such as the Pythagorean theorem in proofs. Bugs have been fixed, and reproducibility has been improved. Lastly, we re-evaluated the five remaining problems from the original AG-30 dataset that AlphaGeometry was not able to solve and contrasted them with the abilities of DDARN, running in breadth-first-search agentic mode (which corresponds to how DDARN runs by default), finding that DDARN solves an additional problem. We have open-sourced our code under: https://github.com/LMCRC/Newclid 1 Introduction General remarks. AlphaGeometry [Trinh et al., 2024] demonstrated the ability to solve geom- etry problems at the level of the International Mathematical Olympiad (IMO), with performance comparable to top human competitors. At the heart of AlphaGeometry is a formal language that encodes geometric problems and theorems, rooted in JGEX [Ye et al., 2011], as well as a symbolic reasoning engine called DDAR (see Subsection 4.4.2 for more information), written in Python, ∗Equal contributions. †Corresponding author: vladmir.siccagoncalves@mail.mcgill.ca ‡Work carried out while at Huawei. §Corresponding senior author: simon.frieder@cs.ox.ac.uk 1 arXiv:2411.11938v1  [cs.GR]  18 Nov 2024",
    "body": "Newclid: A User-Friendly Replacement for AlphaGeometry\nVladmir Sicca∗†1, Tianxiang Xia∗‡3, Math¨ıs F´ed´erico∗‡ , Philip John Gorinski‡4,\nSimon Frieder§2, and Shangling Jui1\n1Huawei Lagrange Mathematics and Computing Research Center\n2Oxford University\n3ETH Z¨urich\n4Robin AI\nNovember 20, 2024\nAbstract\nWe introduce a new symbolic solver for geometry, called Newclid, which is based on\nAlphaGeometry. Newclid contains a symbolic solver called DDARN (derived from DDAR-\nNewclid), which is a significant refactoring and upgrade of AlphaGeometry’s DDAR symbolic\nsolver by being more user-friendly - both for the end user as well as for a programmer wishing\nto extend the codebase. For the programmer, improvements include a modularized codebase\nand new debugging and visualization tools. For the user, Newclid contains a new command\nline interface (CLI) that provides interfaces for agents to guide DDARN. DDARN is flexible\nwith respect to its internal reasoning, which can be steered by agents. Further, we support\ninput from GeoGebra to make Newclid accessible for educational contexts. Further, the\nscope of problems that Newclid can solve has been expanded to include the ability to have\nan improved understanding of metric geometry concepts (length, angle) and to use theorems\nsuch as the Pythagorean theorem in proofs. Bugs have been fixed, and reproducibility has\nbeen improved. Lastly, we re-evaluated the five remaining problems from the original AG-30\ndataset that AlphaGeometry was not able to solve and contrasted them with the abilities of\nDDARN, running in breadth-first-search agentic mode (which corresponds to how DDARN\nruns by default), finding that DDARN solves an additional problem. We have open-sourced\nour code under:\nhttps://github.com/LMCRC/Newclid\n1\nIntroduction\nGeneral remarks.\nAlphaGeometry [Trinh et al., 2024] demonstrated the ability to solve geom-\netry problems at the level of the International Mathematical Olympiad (IMO), with performance\ncomparable to top human competitors. At the heart of AlphaGeometry is a formal language that\nencodes geometric problems and theorems, rooted in JGEX [Ye et al., 2011], as well as a symbolic\nreasoning engine called DDAR (see Subsection 4.4.2 for more information), written in Python,\n∗Equal contributions.\n†Corresponding author: vladmir.siccagoncalves@mail.mcgill.ca\n‡Work carried out while at Huawei.\n§Corresponding senior author: simon.frieder@cs.ox.ac.uk\n1\narXiv:2411.11938v1  [cs.GR]  18 Nov 2024\n\nwhich is an extension and reimplementation by Trinh et al. [2024] of an earlier symbolic AI\nengine [Chou et al., 2000].\nIntertwined with DDAR in the original work is a large language model (LLM), trained on\na synthetic dataset of proofs generated using DDAR, that predicts new geometric clauses that\nDDAR can use to draw new inferences.\nAlphaGeometry’s inference loop.\nAlphaGeometry works, at a high level, in the following\nway: DDAR iterates through statements that can be logically justified from previous ones until it\nfinds what needs to be proved. There are many ways to find a new statement: An initial batch of\nthem comes from expanding the clauses into statements by the rules described in the defs.txt\nfile. Then, sequential iterations of the AR module that make up DDAR (see Subsection 4.4.2 for\nmore information), followed by the application of rules in the rules.txt file is applied until the\ngoal or a fixpoint is reached. In case of reaching a fixpoint, the LLM will be called to add a new\nclause so the iterations can start again.\nIssues.\nDespite its impressive reasoning capabilities, AlphaGeometry suffers from limitations\nin terms of user-friendliness, both for the end-user as well as for the programmer interested in\nextending the current codebase and the scope of problems it can handle.\n• User-friendliness issues: There are three main obstacles that users have to overcome to use\nAlphaGeometry:\n– Installing AlphaGeometry is difficult, mainly because the Meliad library,1 on which Alpha-\nGeometry depends, is difficult to install.\n– Problems have to be input using the JGEX formal language.\n– The files rules.txt and defs.txt inside the AlphaGeometry system describe the founda-\ntions which DDAR uses to make inferences.2 Yet, during AlphaGeometry’s inference loop\n(see above), different rules could kick that were not explicitly stated in these text files, but\nare hard-coded, see Section 3.4.3.\n• Coder-friendliness issues. AlphaGeometry’s codebase is not modularly built, which makes\nit hard for someone who want to contribute code to add new features, inspect proof traces,\nadd logs, etc. Further, the LLM is implemented in Meliad, a deep-learning Python library\nthat is not widely used - which further makes it hard to finetune the LLM or understand its\ninner workings, among other desirable operations.\n• Problem scope issues. AlphaGeometry is not able to work with rather simple and funda-\nmental theorems, notably the Pythagorean theorem, lacking support for the concept of length\nof a segment, used, among other things, in elementary geometry courses. This makes Alpha-\nGeometry a type of narrow AI system whose intelligence contrasts with human intelligence: it\nis inconceivable that an IMO-level competitor will be able to solve certain IMO-level geometry\nproblems while not being able to use the Pythagorean theorem. AlphaGeometry “overfits” on\nOlympiad geometry problems, compared to arbitrary plane geometry.\n1https://github.com/google-research/meliad\n2Detailed descriptions and explanations of the content of those files can be found in the project’s documentation\nunder https://lmcrc.github.io/Newclid/\n2\n\nContributions.\nIn this research work, we have focused our efforts predominantly on the DDAR\nsolver (as opposed to the LLM) because of the relative importance of DDAR when compared\nto the LLM in considering the contributions of these two core components of AlphaGeometry\ntowards its final performance on the test dataset: Two datasets were used to report the perfor-\nmance of AlphaGeometry: AG-30, consisting of 30 geometry problems from the IMO, as well\nas a larger unnamed set of 231 Olympiad-level geometry problems [Trinh et al., 2024] (no data\ncollection protocol has been provided). We will call the latter AG-231 to distinguish between the\ntwo. Table 1 in [Trinh et al., 2024] presents a breakdown of the performance of AlphaGeometry,\nas a function of which combination of methods has been used (DD only, DDAR, DDAR + human\nheuristic, DDAR + various forms of the LLM, etc.) on the AG-30 dataset. This is augmented\nby Figure 6,b in the Extended Data section of [Trinh et al., 2024]: If we re-express the results on\nAG-30 from Table 1 in percentages, the best symbolic AI approach (DDAR + human heuristics)\nsolves 60% of the problems, whereas the best deep-learning approach (DDAR + LLM) solves\n∼83.3% of the problems. Yet this increase of ∼23% is reduced to an increase of merely ∼6.5% on\nthe larger—and thus more representative—AG-231 dataset, where DDAR + human heuristics\nsolve ∼92.2%, and DDAR + LLM solves ∼98.7% of problems. (Further, it was noted in [Sinha\net al., 2024] that the number reported in Table 1 on how many problems could be solved by the\nclassical Wu method [Wu, 1978] was underestimated since it was found that Wu’s method was\nable to solve 15 rather than 10 problems.)\nConcretely, because of DDAR’s outsized importance in AlphaGeometry, as argued above, we\nfocused on Newclid, which uses a new symbolic solver called “DDARN” (DDAR-Newclid) that\nfixed many of the issues present in DDAR:\n1. User friendliness. The following elements were improved:\n• Simplified installation: We provide simple ways to install Newclid, in particular, via\nPyPI. We have removed the dependency on the Meliad library, and streamlined the\ninstallation process, see Subsection 3.1.\n• Problems can be input using an improved command-line interface (CLI), which offers\nendpoints to introduce agents that can manipulate DDARN, see Subsection 3.2.\n• Additionally to the new CLI, problems can also be input using the GeoGebra interface,\nsee Subsection 3.3.\n• We have slightly expanded the scope of problems that can be solved. DDARN can use,\nin particular, Pythagoras theorem, see Subsection 3.4.\n2. Coder friendliness.\nA significant refactoring of existing classes was performed, and\nseveral tools that assist in debugging and allow the visualizing of several internal objects\n(such as symbolic graphs) are introduced. These improvements fall into three categories:\n• General code refactoring that does not affect the reasoning capabilities but laid the\ngroundwork for any subsequent work that was done, see Subsection 4.1\n• improvements that affect how the reasoning works, which include changes that make\nadding future code easier, see Subsections 4.2, and\n• improvements that improve the DDARN reasoning engine, see Subsection 4.4, and\n• tools that make debugging and visualizing of DDARN’s internal objects easier (in fact\nwe used these to find some of the missing rules, see Subsection 4.3.\n3. Reproducibility. We have elaborated on the reproducibility of AlphaGeometry and New-\nclid, see Section 5.\n3\n\n4. Detailed evaluation. Lastly, we compare AlphaGeometry’s DDAR to Newclid’s DDARN\non the five problems from the AG-30 dataset whose solution eluded AlphaGeometry, namely\nthe IMO problems 2008 P1B, 2006 P6, 2011 P6, 2019 P2 and 2021 P3. Two problems out\nof these five, we argue, cannot easily be solved given the current symbolic solver framework;\none problem that previously was not solvable becomes solvable using DDARN (IMO 2008\nP1B), as can be seen in Section 6.\nIn the future (see Section 7), we plan to augment Newclid to also include an improved LLM,\ncompared to the one present in AlphaGeometry, that would be one example of an agent that\nmanipulates DDARN.\n2\nTerminology\nBelow, we define various terms related to functional aspects that underlie both DDAR and\nDDARN. Some (but not all) of these were implicitly used in [Trinh et al., 2024]. To make the\ninner workings of DDAR and DDARN reasoning engines more transparent, we chose to give\nan explicit description of all of them to enhance the conceptual understanding of DDAR and\nDDARN.\nWhen defining a theory for plane geometry, one is faced with the question of deciding what\nare the fundamental objects that will be used to describe the theory. The choice made for DDAR,\nand continued in DDARN, are to base the theory on points, and use them to represent other\ngeometric objects (lines, circles, triangles, angles, ratios, relationships between objects, etc.).\nThe relationship descriptors, such as cyclic, or cong, to denote whether a collection of points\nlie on a circle or two congruent segments, respectively, are called predicates. Their use dates\nback to the DD symbolic engine introduced by Chou et al. [2000]. Predicates work thus like a\nfunction, taking as arguments points, e.g., cyclic a b c d describes that the four points a, b,\nc, d are on the same circle and cong a b c d describes the congruence of the two segments,\ntextttab and cd, that are made up by the four points a,b,c,d. A predicate that is instantiated\nby points, such as the mentioned circle a b c, is called a statement and is the foundational\nelement of the reasoning engine.\nIn DDAR and DDARN, inferences can be made by using three different paths: application\nof rules described in the rules.txt file, running the algebraic reasoning module, and resolutions\nthat are made on the go through hard-built, not-described functions (which we call intrinsic\nrules).\nThe collection of statements that DDAR and DDARN store at a given point when solving a\nproblem is the proof state of the problem at that stage. The objective of the engine is to find a\nspecific statement, the goal, supplied by the user, in the proof state.\nWhenever we use the word symbolically in this article, we refer to something that is inferred\nexclusively from the proof state. As explained below, statements are not directly inserted in\nthe proof state by a human but are either derived from the problem prescription, derived from\nprevious statements by the inference loop that runs within DDAR and DDARN, or, in some rare\ncases, directly derived from a diagram of the problem through a numerical check.\nThe problem prescription, created by a human user, does not use the language of the state-\nments and predicates apart from the establishing of the goal, but that of clauses, implemented\nfrom definitions. Clauses represent geometric constructions, and we will often refer to clauses as\nconstructions. Most clauses will induce the generation of statements. For example, in a problem\nwhere points a, b, and c are already defined, we may define point d = incenter d a b c in the\nstatement of the problem. In that case, when the problem is read, the statements described in\nthe incenter definition, with those arguments, will be added to the starting point of the proof\n4\n\nstate, namely the ones corresponding to the fact that the incenter is the meeting of the bisectors\nof the angles of the triangle: eqangle a b a c a x a c, eqangle c a c x c b, and eqangle\nb c b x b x b a.\nThe definition incenter will also provide instructions to get numerical coordinates for point\nd, and here the information that the incenter is the intersection of internal bisectors of the angles\nof the triangle instead of external ones is recorded in some sense. In comparison, there is also\na definition of excenter that is symbolically equivalent to the incenter, which will create a\npoint with an appropriately different numerical representation. Clauses can also be added by\nthe LLM later in the solving loop of a problem, but technically DDAR/DDARN see this action\nas the writing of a new problem.\nDuring the reasoning procedure, the main way to generate new statements is through the\napplications of rules.\nA rule is the encoding of a theorem, and it consists of a sequence of\nstatements, the hypothesis, followed by a new statement, the consequence. Of course, a rule is\nwritten with generic points, so a separate procedure when rules are actually being used is to\ndo the matching of the rule. The matching is the process of seeing if, for some combination of\npoints, all the hypotheses of the rule are statements in the proof state. If so, the consequence\nof the rule will be added to the proof state as well. A full list of rules available for Newclid,\nnumbered r1 to r69, can be found in Appendix A.\nThese shortcomings prevent it from being widely adopted by mathematicians working in the\ndomain of theorem proving, educators, and students learning Euclidean geometry. Therefore we\nintroduce Newclid, which is a large refactoring of AlphaGeometry, that improves AlphaGeome-\ntry’s codebase, in particular the DDAR solver.\n3\nUser Friendliness.\nBelow, we detail the four improvements that we made regarding user-friendliness: This includes\na simplified installation process, two interfaces that we have added to Newclid to make it more\nuser-friendly (the command line interface (CLI), and the other is a GeoGebra interface), and a\nsection on how we expanded the problem scope that DDARN can solve.\n3.1\nEasy Installation\nWe have streamlined the installation process so that it is easy to install Newclid using pip\ninstall; additionally, we are releasing it as a PyPI package. The isolation of the Meliad de-\npendency was the main factor in making the installation easier, as running the DDARN solver\nnow is not contingent on having Meliad installed (for AlphaGeometry, even if only DDAR was\nused, Meliad also had to be installed). Further, we have created an API so that Newclid can be\ncomfortably called from other code.\n3.2\nCommand Line Interface (CLI)\nOur most fundamental new interface is presented to the user via the command line interface\n(CLI). Its main objective is to allow one to run a problem with Newclid, without having to use a\nPython code entry point, and with the option of a human-understandable step-by-step process,\nwhich allows the replacement of the original LLM by human decisions.\nThe CLI is characterized by a high degree of control over the solver through our current three\nagents (a human option, a brute-force automatic option, or a dummy option), which we detail\nbelow.\n5\n\nProblems always need a defined name: multiple problems can be inside a single text file and\nare referred to by a name. In the case of the GeoGebra folder with the GeoGebra .ggb file\n(which contains the entire construction made up of clauses but not the goal), a text file with the\ngoal needs to be supplied. Problems can be fed to Newclid in formal language from a .txt file,\njust as in the case of AlphaGeometry. The CLI provides the following elements:\n• An environment: We have introduced a new concept of environment that contains the rules\nfile and the definitions file for the problems used by the reasoning agent.\nA typical environment, with the outputs of solutions of a hypotetical problem1 has the fol-\nlowing structure and contents.\nenvironment/\n|-- rules.txt\n|-- defs.txt\n|-- problem1/\n| -- problem1.ggb\n| -- html\n| -- index.html\n| -- symbols_graph.html\n| -- dependency_graph.html\n| -- figure.svg\n| -- goals.txt\n| -- construction_figure.svg\n| -- run_infos.txt\n| -- proof_steps.txt\n| -- proof_figure.txt\n|-- problem2/\nDifferent files with rules and definitions can be used for each problem so that the solver uses a\ndifferent set of those exclusively for one specific problem. For technical details we refer to the\ndocumentation section.\nIntroducing the concept of environment for a problem proved to be a good solution to 1)\nflexibly allow various ways of inputs (currently Newclid supports CLI and GeoGebra (see\nbelow), but we invite the community to extend our approach), where the environment collects\nall necessary to enable that input, and 2) to provide, similarly to a software package manager,\nsuch as Python’s virtual environments, an easy way to run different mathematical problems\nwith different inputs.\n• Seeds: The construction of a numerical diagram of the problem contains various random\nchoices, which can influence numerical check predicates and change poofs. A seed is collected\nso that these choices can be made deterministic;\n• Display settings and logging: It is specified what logs the terminal should show if the matrices\ngenerated by the algebra reasoning sub-engine (the “AR” part) should be displayed or if no\nlogs should be recorded.\nAlphaGeometry’s design is such that it runs, given an initial human translation of a geometric\nproblem into JGEX, to end without further human intervention. Thus, the reasoning procedure\nis rigid.\n6\n\nFigure 1: Index page generated for a single problem, with the diagram of the proof, the symbols\ngraph, and the dependency graph.\nContrasting, we designed Newclid by generalizing its working to allow agentic interaction\nmodes. In particular, the Human Agent is an interface that allows a person to control the path\nof a solution, deciding which theorems to try to apply at each moment, add new points on the\ngo, check symbolically if a given statement was added to the proof state at any given stage, look\nat the evolution of the proof graphs at each step, or run the usual breadth-first-search DDAR\nreasoning procedure on call.\nThe Human Agent is called as a reasoning agent, currently in opposition to DDARN (which\nwe also treat as an agent, see Subsection 4.2 to see how this is treated in the code), as it can\nbe viewed as a particular way to guide the search for a proof of the problem. It was designed\nas a first step towards a plan to try to improve the proof search from BFS to a better heuristic\nthrough learning from human data of trying to solve problems, but it also proved an important\ntool in debugging, as it became a way to check the effect of theorems one at a time, drastically\nincreasing the granularity of diagnostics when compared to full BFS runs.\nIt is still limited for human use because the lack of a better graphic interface can make it\nhard to directly understand the problems and theorems only from the text, but it is our belief\nthat a friendlier interface for the Human Agent could even make it an interesting learning tool.\nWith it, users can try to experiment fast when solving a problem, without the risk of making\nfalse claims, and check what middle steps have been already verified at each point, as well as\nsee the history of the proof state. It could work for problem investigation in plane geometry\nin tandem with a graphic tool like GeoGebra, the same way symbolic computing and graphic\nsoftware like Mathematica and MatLab work with investigations in other areas of mathematics\nand applied sciences.\n7\n\n3.3\nGeogebra Interface\nOne barrier to using AlphaGeometry is the need to translate a given geometric problem into\nthe internal JGEX formal language format, which is not widely known, not widely used in other\nsystems, and not well-documented. To make usage of this software simpler, Newclid provides an\ninterface for a user to be able to prescribe the problem from a GeoGebra diagram of the problem\ninstead. The big advantage is that GeoGebra has an intuitive graphic interface, is widely known\nby people working with Euclidean geometry (including in educational settings), and has a large\ncommunity to support one’s path to learning its usage.\nTo provide the statement of the problem, one has to provide a file environment containing\nthe .ggb file and a goals.txt file containing the goals in JGEX format.\nNewclid will then\nuse the GeoGebra construction to generate the numerical representation of the problem and the\nconstruction tools used in GeoGebra to enumerate the initial premises in the proof state, allowing\nthe solver to operate as if the problem were prescribed in text.\n3.4\nExpanded Problem Scope\nAll of the extensions outlined here rely on our significant refactoring of the code, which was the\nfoundation that made the extensions possible in terms of reasoning capabilities. In the following\nSubsections 3.4.1, 3.4.2, 3.4.3, 3.4.4, we mention various new additions we made. These are the\nby-product of our refactoring, which made these extensions, in particular, the ones made in the\nlast section, 3.4.4, possible. Our big achievement is that Newclid is able to use the Pythagorean\ntheorem inside other proofs, see Subsection 3.4.3.\n3.4.1\nAdding New Predicates\nPredicates form the internal vocabulary used by the reasoning of the engine. We recall from the\nsection on terminology, Section 2, that each predicate behaves as a function, with a prescribed\nnumber of arguments which correspond to points. A predicate should be thought by the user\nas a fact relating the arguments, such as “the segments defined by two pairs of points being\ncongruent”, or “the lines through these two pairs of points being parallel”. The only human\ninputs of predicates are the goals of a problem, but any definition will be symbolically broken\ndown into instances of predicates, and rules are stated in terms of predicates as well.\nThe\nengine then proceeds to “think” using this language. Therefore, the list of predicates is the most\nfundamental list of notions that the engine knows.\nCrucially, AlphaGeometry lacked functional predicates that consider numerical measures of\nangles, ratios, and lengths. This made simple questions, such as finding the third angle of a\ntriangle given the values of the first two, unanswerable, even if the algebraic module could easily\nfind the information. Given that questions asking for a specific angle or distance are extremely\ncommon in Euclidean geometry and would be expected of any plane geometry solver, this was\na significant limitation we sought to overcome. (Curiously, we found traces of such predicates\ninside the released codebase, which left us with the impression that the original intention was to\ninclude them but that this was abandoned for reasons unknown to us.)\nTo fill this gap, we patched up or added the following predicates:\n• aconst. This predicate encodes the information that the angle between two lines has a given\nconstant value (that can be given in degrees or in radians). Specifically, lines are denoted in\norder, each by a pair of points, and the angle is the one obtained by going in the counterclock-\nwise direction from the first to the second line. In the original work, this predicate backed the\ns angle definition and superficial predicate, but it only accepted radians as input and could\n8\n\nFigure 2: An exemplary problem in GeoGebra that can be parsed by Newclid.\n9\n\nnot be used for goals. We fixed it for all uses, created syntax for both degrees and radians in\na unified predicate and turned s angle into only a definition that directly calls aconst.\n• rconst. This predicate encodes the information that the ratio between two segments is a\ngiven numerical fraction. It was present in the original codebase, in the definition triangle12\nspecifically, but was not functional. We fixed it in all functionalities and switched to a fraction\nnotation for the ratio instead of a pair of integers.\n• lconst. This predicate encodes the information that the length of a segment is a given nu-\nmerical value (without units). It was created from scratch, as it was not a functionality within\nthe original AlphaGeometry, so we added it mirroring the behaviour of the other predicates\ndealing with constant measures. To give consistency to this predicate, it was also necessary to\nchange some of the existing definitions, as their corresponding numerical sketch was not length-\nagnostic. This complication was probably not addressed in the original software because its\nwhole logic structure was scale invariant by not ever assigning numerical length information.\nTheoretically, the study of lengths creates a new issue, as a numerical length demands a unit\nof measurement in contrast to angles and ratios. Our approach to this was to assume a single\nunnamed unit of measurement throughout each problem.\n• acompute. This is a new kind of predicate that does not simply ask for the proof of a goal\nbut creates the goal itself on the run. It is meant for open-ended questions, specifically when\na problem asks the measure of a specific angle. It will try to locate the corresponding aconst\nstatement and turn it into the goal internally. Then, it generates a proof in which the last\nstatement is the angle being measured equals its value.\n• rcompute. The exact analogue of acompute for problems asking the value of a ratio between\ntwo segments. Similarly, it will search for an rconst statement in the proof state corresponding\nto the ratio asked and turn it into the goal of the problem.\n• lcompute. Working just as acompute and rcompute, lcompute is meant to allow one to ask\nthe length of a segment by searching the appropriate lconst statement. These three predicates\nadd little in terms of logic but are ubiquitous among elementary school problems and allow\none to “solve” geometry problems in a larger sense: not only writing down proofs but also\nfinding open solutions.\n• nsameside. This predicate is of a different nature with respect to the previous ones, as it\nis simply a numerical check, not verifiable symbolically. It can be imposed as a goal, but\nif it is true, it will automatically be satisfied.\nAdding predicates like this is important to\nallow for proper enunciating of rules, especially since the solver uses the notion of full angles,\nwhich do not differentiate between the two angles in an intersection. The previous version of\nAlphaGeometry already had a sameside predicate that verified if two points were on the same\nside of two corresponding vectors by checking if the inner products between pairs of vectors\nin the configuration have the same sign. For a larger flexibility of adding rules, we added\na predicate for the negation of sameside as well, just as was the case for the collinearity,\nperpendicularity, and parallelism predicates.\n• same clock. Just as was the case for nsameside, same clock is also simply a numerical check,\none that verifies if the triplets of vertices of two different triangles are ordered with the same\norientation. This is important when checking the similarity and congruence of triangles in the\ncase of full angles, as the fact that two angles are the same only if there is an orientation-\npreserving isometry taking one to the other (with markings) means the rules for triangle\nsimilarity and congruence are also orientation sensitive.\nIn the original work, the authors\n10\n\nsolved this problem by implementing a function that checked orientation hidden inside the\nmatching of rules involving congruence and similarity. The issue, of course, is that such checks\nwere hidden from the proofs and were not highlighted in the code. To solve those problems,\nwe turned the original same clock Python function into an explicit predicate that can be used\nto write rules and that behaves as the other numerical checks.\n3.4.2\nAdding New Definitions\nWhile predicates are prerequisites for an extension of reasoning, simply adding a predicate does\nnot incorporate it into the engine reasoning. Information about the predicate enters the reasoning\nloop either by direct insertion of information in the statement of the problem or as a derivation\nof a rule. As can be noted from the experience of solving geometry problems in general, for\nproblems where angles and lengths measures occur, it is usually necessary that some previous\nmeasure is provided, such as a known angle. That is particularly true in the case of lengths, as\nestablishing a scale is always necessary in order to calculate distances.\nIn parallel, even predicates that are often derived from rules without a need for an introduction\nof the statement can be wanted as a premise.\nFor example, the eqratio statement, which\ncorresponds to the fact that the ratios between two pairs of segments are the same, usually\noccurs as a consequence of verification of conditions on similar triangles, but it is not unusual\nthat a problem has such as a statement mentioned in its premises, in the form of a proportion.\nTo be able to insert those sorts of premises for problems, Newclid has to introduce new defi-\nnitions. Introducing new definitions on the syntax is not a hard task from a technical viewpoint,\nin essence one only needs to define the characteristics of the definition on the .txt file con-\ntaining the list of definitions and construct a corresponding function in the sketch.py module\nthat creates a numerical representation of the new definition. Nonetheless, it is a crucial step in\nincreasing the scope of the problems that can be stated for Newclid.\nWe introduced new definitions with the goal of declaring premises of problems that were\nnot available before but could be managed by the original predicates, of declaring premises of\nproblems that demand the new predicates (de facto including them in the reasoning possibilities\nof the Newclid), or of making previous definitions more flexible, either reducing conditions for\ntheir use or making the statements each definition adds more strict. We introduced the following\ndefinitions:\n• on pline0. Similar to the previously existing on pline, but drops the requirement that the\nparallel lines are distinct, allowing one to have overlapping parallel lines.\n• iso triangle0. Similar to the previously existing iso triangle, generates the three vertices\nof an isosceles triangle but adds to the proof state only the fact that the triangle has two equal\nsides, not also a pair of equal angles as well. This should be proved.\n• iso triangle vertex. As in the previous definition, it creates only the apex of an isosceles\ntriangle, but it is weaker than the original definition on bline, which included both the con-\ngruence of a pair of sides and of a pair of angles into the proof state. This only adds congruence\nof a pair of sides.\n• iso triangle vertex angle. This is the complementary definition to iso triangle vertex,\nwhich creates the apex of an isosceles triangle but only adds the statement of the angle con-\ngruence to the proof state.\n• on aline0. This new construction of an angle equivalence adds a configuration that did not\nexist before. Namely, given an intersecting pair of lines, a third line, and a free point, it creates\n11\n\na new point such that the line through this point and the previously existing free point forms\nan angle with the third line that is congruent to the angle between the other pair of lines. It\nis more flexible and includes the previous definitions on aline and angle mirror as special\ncases.\n• eqratio. This new construction is the first that allows the prescription of an eqratio predi-\ncate, that is, to deal with a premise that two pairs of segments have an equal ratio between\nthem. As for on aline0, it takes seven points as arguments (two free existing segments and a\nfree point) to create a new one that completes a fourth segment.\n• eqratio6. This is another new construction created to insert eqratio conditions that can\nbe problem premises. In this case, it creates a point that will show up twice in the same\nfraction of the proportion equivalence, which is usually used to split a given segment with the\nproportion of a pair of segments. As such, the function takes only six points as arguments.\n• rconst. This construction was created to insert a rconst predicate as a premise of a problem,\nthat is, a premise that says a pair of segments has a prescribed ratio. It takes one segment\nand a free point as arguments to construct a fourth point completing the second segment in\nthe ratio.\n• rconst2. Similarly to eqratio6, this construction allows for an instantiation of rconst in\nwhich a point shows up in both segments of the prescribed ratio. It is particularly used for\nproblems which ask for a segment to be split in a ratio of p : q.\n• aconst. This is a new construction for prescribing an angle between two lines with a fixed\nvalue without the need to specify the angle vertex. It is the first construction to implement\nthe aconst predicate explicitly.\n• s angle. The original AlphaGeometry had a s angle definition, that actually called an aconst\npredicate on the background. We harmonized it with the overall functioning of the engine. It\nprescribes an angle of a fixed value with a fixed vertex, and it can be realized by aconst if\none uses the intersecting point to describe the pair of lines.\n• lconst.\nThis construction was created as the entry point for length information into the\nengine. Given a point, it creates a new point such that both points form a segment with the\nprescribed length. This is important in order to write problems with information on the length\nof segments and also to allow a way for length information to enter the problem. In classical\ngeometry terms, it is the only way to introduce the scale, or the unitary segment, into the\nproblem.\n3.4.3\nAdding New Rules\nIncreasing the number of predicates and definitions is the way to increase the number of geometric\nproblems the engine can reason about. Such new problems can then be constructed and run,\nbut most likely, no solution will be found since the appropriate rules are missing. In order for\nthese problems to be solved, the reasoning side of the engine itself must be improved, and such\nimprovements can take many forms.\nWe recall that in the original engine, conclusions can be reached by three different paths:\napplication of rules described in the rules.txt file, the running of the algebraic reasoning\nmodule, and resolutions that are made on the go through hard-built, not-described functions,\nthat we called intrinsic rules.\n12\n\nThe intrinsic rules were created to operate actions humans tend to overlook, such as verifying\nthat if a point lies on a line, it can be an argument for the definition of the line, and that gives\nrise to a statement of collinearity or that two perpendicular lines form an angle of 90◦between\nthem, etc. They exist for expediency and for efficiency of execution in some cases, but results\nfrom such operations do show up in proofs, as they interfere with the dependency structure, even\nif they were not mentioned in the original AlphaGeometry paper. Our philosophy towards them\nwas to localize and label them, including mentioning them on the proofs, in order to make their\nusage explicit, but to rely on them as little as possible in terms of reasoning steps.\nThe AR module was not explicitly described in the codebase, in the sense that there was\nno separate list of which facts are turned into equations in the algebraic solver. We altered the\nalgebraic module in the process of inserting new predicates so that they could interact with the\nalgebra operations, see Section 4.4.2.\nThe rules.txt file is the most explicitly written piece of the reasoning engine. Typically, each\nline of the file gives you a theorem, structured as a sequence of predicate-enunciated hypotheses,\nwhich, if verified for the given proof state, will include the consequence, also predicate-based,\ninto the proof state as well. This set of rules makes up the deductive database (DD) part of the\nengine. In principle, including a new theorem in the database should be as simple as translating\nit into an implication described on statements and writing it into a new line of the file. At first,\nthis was not true because some rules could conflict with the traceback or use predicates that\nwere not finalized. This was fixed by our centralization of the predicates.\nOur first approach towards adding new rules was to try to add new high-level theorems as\nrules (r43-r48, see Appendix A for a list of all rules added), with the hope that this would\nallow the solving of new problems. This looked like a natural extension of the fact that the\nentire DDAR engine operates not on a purely axiomatic basis but by specifying a collection of\ntheorems that can be used.\nHowever, no new problems from AG-30 were solved thanks to that addition; although we did\nmanage to simplify some of the other existing proofs, that now could be shortened by appealing\nto the newly added theorems-as-rules.\nA more fruitful approach focusing only on theorems that arguably are “close” to axioms, was\nachieved by probing DDAR with small, controlled geometry problems regarding various simple\ngeometric facts to see what facts it knew. In this way, we observed that some basic facts about\ncircles (r49 and r50 from Appendix A) were missing. Also, we confirmed that there was no\nconnection between the midpoint predicate and the ratio between the corresponding segments\nbeing\n1\n2, which made us include r51.\nThese small facts did prove fruitful in expanding the\ncapabilities of the solver, including in the benchmark of IMO problems, see Section 6.\nSome theorems that one would like to add may not be simple enough to be written with\npredicates of a simpler form, as the ones inherited from DDAR. In that case, more complex\npredicates that are potentially less transparent with regard to exactly what they represent have\nto be designed.\nFor example, the Pythagorean Theorem is a line in the rules file:\nPythagorasPremises a b c => PythagorasConclusions a b c.\nThen, when we are checking and performing the resolution of PythagorasPremise a b c, the\npredicate function automatically finds its suitable premises if they are already in the proof\nstate. For its functioning, as we already check numerically every statement before checking it\nsymbolically to feed the cache (see Subsection 4.4.3), the solver only needs to check whether the\nvalues of the symbols are deducible by the system, but we don’t need to really resolve equations\nto get the values.\n13\n\n3.4.4\nAdding New Equations to AR\n1. Following the reorganization of the code, as outlined in Section 4 on Coder Friendliness, it\nis easy to list all rules for the addition of equations into AR. Equations are added to the\nsystems of equations at the addition of new statements by calling a prep ar method. We\nhave the following instances where that happens:\n• cong A B C D: adds the equation log AB = log CD to the table of ratios.\n• aconst A B C D r: adds the equation d(CD) = d(AB)+r to the table of angles, where\nr is any real number that will be taken\nmod π once the statement is added to the proof\nstate, during the DDARN inference loop.\n• lconst A B l: adds the equation log AB = log l to the table of ratios, where l is a\npositive number.\n• eqangle A B C D E F G H: adds the equations d(CD) −d(AB) = d(GH) −d(EF) to\nthe table of angles.\n• eqratio A B C D E F G H: adds log AB −log CD = log EF −log GH to the table of\nratios.\n• para A B C D: adds d(AB) = d(CD) to the table of angles.\n• perp A B C D: adds d(CD) = d(AB) + π\n2 to the table of angles.\nWe note that the original codebase contained separate tables of lengths and ratios. We\nmerged them, which resulted in cleaner code, as detailed in Subsection 4.4.2, and conse-\nquently, only a table of ratios is available, referenced above, which includes all lengths.\nOf this list, the addition of the equations referring to cong statements was moved from\nthe lengths table, used in AlghaGeometry, while the ones referring to aconst and lconst\nstatements are new additions we added to the table of ratios.\n2. Further, it is now easy to add new predicates to the engine given the Predicate class we\nintroduced, see Subsection 4.4.1. This, in turn, allowed us to easily add the predicates that\nallow the Pythagorean theorem to be used by DDARN.\n4\nCoder Friendliness\nA significant amount of our time was dedicated to refactoring the codebase of AlphaGeometry\nto make the inner workings of its 16,000-line, highly entangled, complex code easier to work\nwith, to eliminate bugs, and to add low-level functionalities that make the user’s interaction\nwith AlphaGeometry easier, and on which the previous Section 3.4 built.\nWith the exception of the preliminary numerical checking and caching of statements men-\ntioned in Subsection 4.2, this refactoring effort had no direct impact on the reasoning engine.\nEach subsection below sums up the different types of changes and additions we made.\n4.1\nOverall Foundational Design\nAlthough we achieved improvements on the reasoning part of the engine, a necessary step to\nmake that possible, and one that took most of the time, was to refactor the original codebase\ninto something more manageable.\nThe first step, and one that brought Newclid to life, was to separate the AlphaGeometry\ncode into two halves. The first contains everything necessary for the software to solve a problem\n14\n\nthat does not demand auxiliary constructions, i.e., the processing of a problem as well as the\nsymbolic reasoning structure. The other half is the code necessary for the implementation of the\nlanguage model used to generate auxiliary constructions. The subsequently created early version\nof the Newclid codebase could run independently, with the limitation in solvability verified for\nDDAR in [Trinh et al., 2024], while the LLM’s codebase had to call Newclid as a library in order\nto operate.\nThis separation of the code not only turns the LLM and the symbolic solver into two codebases\nthat can evolve in parallel but also contains all dependency complications from the original\nAlphaGeometry inside the LLM’s codebase, so Newclid could be tested and developed from\nday one. An added benefit of the separate framework between agents and Newclid is that, as\ndependencies of the agent become optional for the running of the engine, it can be made lighter\nto install and run if one only wants to use the reasoning engine, without the addition of new\npoints.\nAfter this first change, there were still many iterations of large refactorings of the Alpha-\nGeometry codebase to increase readability and modularity and hence make improvements and\ndebugging easier. The overall principle was to first find the basic ideas effectively used in the\nfunctioning of the engine, separate them into smaller modules and classes, each with fewer re-\nsponsibilities, and centralize important concepts that were scattered throughout the code.\nTo support the refactoring process, we added several tests. In particular, we have tests for\nall of the most important rules that are used.\n4.2\nAgentic Support\nThe reorganization and the modularity we added to the code allow for better communication\nbetween Newclid and other software through an interface of what we call “agents”, as mentioned\nearlier. As of now, the existing agents are subclasses of the larger DeductiveAgent class inside\nNewclid itself.\nThe currently existing agents are DDARN (which uses breadth-first-search), HumanAgent\n(that allows human control of the solving process), and flemmard (a dummy agent that does not\ntry to apply anything after building the problem, and is good for testing the parts of the code\nbeyond the reasoning), which we explain below.\nWe allow the possibility of adding similar classes that allow LLMs, such as the original\ntransformer model from AlphaGeometry, to operate through an agent.\nIn an agentic setting, important mechanisms are 1) how different agents can interact with\neach other, 2) what each agent observes and what actions it can take.\nWe have implemented this by exporting the “proof state”, carrying all the information about\nthe statements derived by the reasoning at any given moment (agents also accept the file with\nthe rules as input, in case they have to do derivation themselves).\nTo interact with the proof state, the agent needs to be designed with observation functions,\nwhich can directly add new clauses to the problem, match a theorem, add or change a dependency,\nor check a goal. The functions can be customized to access other information about the proof\nstate, such as the current geometrical graphics of the problem and its premises.\nIn terms of code, the HumanAgent is an example of an agent that explores all the function-\nalities of the ProofState class.\nAs shown in Figure 3, the interactions pertain to three parts: the agent, the observation\nfunctions and the proof states. A run loop generates steps where, at each step, the agent can\nmanipulate the proof state by matching rules, adding dependencies, and adding clauses that\ndescribe auxiliary constructions.\n15\n\nFigure 3: Overview of interactions between different components of Newclid.\n4.3\nImproved Visualization and Debugging Capabilities\nOne important contribution to the understanding of the functioning of the code was the visual-\nization of two structures that were implicit and entangled in the original AlphaGeometry code:\nthe symbols graph and the dependency graph. Originally, they were both defined in the single\nGraph class, whose definition span almost 3000 lines of code, making it very difficult to under-\nstand. Also, there were no visualization capabilities built in, so there were no immediate ways\nto generate these graphs.\nAs the name suggests, the dependency graph depicts the dependency structure of the proof,\nnamely what premises were derived, on what other premises they rely on, and what the mecha-\nnism that allowed for that derivation is. It is an and-or graph, with nodes representing statements\nand directed edges representing dependencies between the statements. Each dependency can con-\nsist of potentially multiple, or even zero, incoming statements and one outgoing statement, in\naddition to a reason citing the rule allowing the deduction of the outgoing statement from the\nincoming ones. There are two depictions of the dependency graph: One can see the full depen-\ndency graph, which shows all the dependencies between all the statements that DDARN derives\n(which appears if a solution is not found at all), or one sees the reduced dependency graph, avail-\nable only in case where a problem was solved, where we traverse the full dependency graph and\nexclude any nodes (and corresponding edges) that are not relevant to the found solution, using\nthe traceback.\nLess obvious is the symbols graph, which depicts all the geometric objects created in the\nconstruction of the problem and the development of the proof, and if they are composed of\nsmaller objects, they will be connected to those basic objects.\n16\n\nFigure 4: A depiction of the reduced dependency graph containing the proof of a simple problem\nsolved by Newclid(see Appendix C for a formal statement of the problem). This reduced graph\nonly shows when a problem can be solved, which allows us to prune the full dependency graph\nof any nodes that did not contribute to the solution of the problem.\nFigure 5:\nA depiction of what the symbols graph of a small problem that could be solved by\nDDAR in the original AlphaGeometry, with two components, one for angles and one for ratios,\nlooks like (see Appendix C for a formal statement of the problem). Obtaining this figure already\nrelies on code changes to AlphaGeometry to extract the symbols graph while not exhibiting any\nof the further refactorings we made to the storing of geometric objects.\n17\n\n4.3.1\nDependency Graph\nThe biggest feature that was missing that we encountered in the AlphaGeometry code, was clear\ndocumentation of the dependency structure: a datastructure that collects the statements and\ntheir dependencies in a proof. Although the original paper by Trinh et al. [2024] mentions the\nneed for a traceback to simplify proofs and to weed out statements that were derived during the\nDDAR loop but that are not necessary for the proof, it does not touch on the complexity of the\nfunctions located throughout the code dedicated to registering and sorting out the dependencies\nof statements generated in the process.\nSuch dependencies are now stored in what is called the Dependency class, and the collection\nof all dependencies forms the (full) dependency graph. A dependency is typically built when a\nstatement is checked symbolically, a rule is applied, or exceptionally when the symbols graph is\nsynthesised by merging lines or circles, which happens when the engine finds out three points\n(which would correspond to three lines in the symbols graph), are actually collinear. It consists\nof a justification (such as the name of the rule), its premises and a conclusion. Also, when a\ndependency is added to the dependency graph, a function related to the conclusion predicate can\nbe triggered, and the inner states of the AR module and the symbols graph can be modified.\n4.3.2\nSymbols Graph\nInitially, the symbols graph contained many kinds of objects: points, segments, directions, an-\ngles, ratios, measurements of angles, values of ratios, the numerical value of those measures, and\ncircles. This myriad of classes of geometric objects was necessary because many implicit deriva-\ntions of facts took place through identifications of nodes on the symbols graph. In our work, we\nmoved a big part of the reasoning responsibilities of the symbols graph, namely the ones involv-\ning congruences of measures, to the AR module, and some others were given to explicit rules.\nFor DDARN, the cleaned-up symbols graph only stores points, lines, and circles, and the only\nreasoning it carries concerns detecting and storing when new points are found in already existing\nlines and circles (i.e. collinearity and concyclicity). It should be stressed that such identification\nis only accepted by the engine if there is a symbolic justification for it, the numeric recognition\nthat a point lies on a given line on circle is not enough for the registering of that information in\nthe symbols graph.\n4.3.3\nUsing the Graphs\nVisualizing this information in these graphs and inspecting them had important consequences.\nIt turned out that they are one of the most comprehensive visual depictions one can have of the\nreasoning of the engine, to the point that we found out that the original s angle definition was\nprocessed through a hidden, not entirely functional, aconst predicate because that dependency\nsurprisingly showed up in dependency graphs (but not in the proof).\nBoth the symbols graph and the dependency graph were crucial concepts to understand the\nunderlying structure of the reasoning beyond the information contained in generated proofs. In\naddition, having these visualization tools that contain a lot more information on the reasoning of\nthe engine than the proofs was crucial for debugging, as it pointed us to incorrect or superfluous\nconnections that were made by the engine. This information, in turn, made it possible to make\nvarious additions to fix these problems.\n18\n\nFigure 6: The width at every depth of the dependency graphs, with levels ordered from statements\nthat are closer to the goal in the proof, for all the 15 problems in the imo ag 30 benchmark that\ncan be solved by Newclid’s DDARN module (with breadth-first-search).\n19\n\nFigure 7: The DDARN symbols graph of the same problem as in Figure 5, generated by Newclid.\nThe essential relationships present in the problem can be easily read from the symbols graph.\n4.4\nReasoning Engine Improvements\nThe guiding principle of DDAR was to be able to apply theorems to a problem in a breadth-first\nsearch (BFS). To execute this idea, a series of technical challenges have arisen regarding how to\nstructure and store the mathematical information and how to implement the search. A big part\nof our effort focused on creating good, flexible code structures that could execute the breadth-\nfirst strategy that DDARN employs in a better way than AlphaGeometry. In order to do so, we\nimplemented and modified the structures described below.\n4.4.1\nPredicates\nOne major step in giving the code flexibility was to create the Predicate class and to organize\nthe most fundamental reasoning terminology of Newclid as a collection of subclasses, with a\nstructure that can be expanded if needed and easily modified. Predicates are more complex than\ndefinitions, so a Predicate class is more complex than a definition statement on the defs.txt\nfile, but the philosophy we followed was that the former should be as easily found and modified\nas the latter.\nA Predicate class contains methods to:\n• Put the arguments of the predicate in a canonical order (preparse).\n• Parse its arguments from strings to geometrical points (parse).\n• Find a dependency structure that can justify the existence of that predicate and do the sym-\nbolic check (why, add).\n• Check numerically for the validity of that predicate, do the numerical check (check numerical).\n• Process the representation of that predicate when writing the proof, generating diagrams, or\nreceiving and passing information to the LLM (pretty).\n20\n\nThis list is typical but not exhaustive, as some predicates may demand extra processing\nfunctions in the background.\nFor example, in order to apply Pythagoras’ theorem, as can be seen in the rules.txt file\npertaining to this example, two predicates were created, PythagoreanPremises to represent the\npremises (the presence of a right-angled triangle), and PythagoreanConclusions to represent\nthe conclusion (the sum of the squares of the legs). The PythagorasConclusions predicate has\na method to extract the distance of the missing side of the triangle (if there are two known sides)\nnumerically and add the corresponding lconst statement to the proof state, avoiding the need\nfor manipulating an equation. This method, of course, does not have an equivalent in other\npredicates, but the fact that predicates are classes adds this flexibility to their definition while\nkeeping all clauses needed in one place.\n4.4.2\nAlgebra Reasoning\nOne of the main contributions of the authors of [Trinh et al., 2024] to the development of a geom-\netry reasoning engine was the addition of the algebraic reasoning module (AR) in tandem with\nthe deductive database (DD) resulting in the DDAR solver, that increases the range of state-\nments found compared to DD. AR is a symbolic engine for checking and getting the justification\nof statements based on an internal set of linear equations.\nThe original engine was built on three sets of linear equations, called tables: one storing\ninformation about angles, one storing information about ratios, and one storing information\nabout lengths. Each internal linear equation is of the form y = P qixi + constant, where only\nthe qi’s are stored explicitly. When a new equation is given, it is simplified so that it contains\nonly free variables on the right-hand side, with one variable, y, to depend on others, if necessary.\nThe goal of the AR module is to find new equations of the form P bixi = Constant, corre-\nsponding to new predicates not present in the previous equations. This involves resolving the\ndependency structure of the predicate found to minimize proofs at the time of the traceback.\nDifferent procedures are applied at each of those stages.\nTo find the new statements, as described in the original work by [Trinh et al., 2024], the\nengine applies Gaussian elimination at each table, a process that can result in a new statement\nor not. Each table stores information about all occurrences of predicates feeding it, but not\nall of them necessarily relate to the new statement found. Once a goal is found, to weed out\nunrelated statements in the table, the engine uses linear programming techniques to find the\nminimal system that satisfies the new statement, aiming at a shorter proof.\nAll those procedures are part of AlphaGeometry. In order to have a clearer algebraic module\nthat is easier to understand and modify and that is more robust against mistakes, we made minor\nchanges.\nThe most notable one was the removal of the length table. The lengths of segments were\narguments in both the table of lengths and the one of ratios (in this case, ratios are linearized by\nthe application of logarithms as described in [Trinh et al., 2024]). The table of lengths, though,\nhad only simple information about the equality of segment lengths, information that we easily\nincorporated into the table of ratios without further negative consequences, reducing the number\nof tables to two.\nAs this table now has to deal with information on constant lengths, but the entries are log-\narithms of lengths for the linearization of ratios, we end up having to deal with the logarithms\nof constants. To minimize numerical instabilities and simplify symbolic manipulations, instead\nof storing those throughout the Gaussian elimination process, we retrieve them through nu-\nmerical checks whenever the proof state has dependencies supporting the corresponding lconst\nstatements(see Subsection 3.4.4).\n21\n\n4.4.3\nMatching\nAt first look, a BFS search for an automatic theorem prover may look as costly as the number of\ntheorems it has to go through while performing the search. Our experience with AlphaGeometry\nshows that this is only part of the story. In fact, the process of using theorems can be separated\ninto one that matches the theorem, that is, looks for arguments to fit the predicates in the\nhypothesis of the theorem, and one that applies the theorem generating a new statement from\nthe theorem’s conclusion. The matching is the combinatorially expensive step of the process,\nand it can make some theorems consume significantly more resources than others.\nGenerally, to reduce the amount of resources needed for running a loop in a symbolic solver\nthat is responsible for the application of theorems, one could either improve the search strategy,\nwhich has been done, for example, by the use of reinforcement learning and Monte Carlo tree-\nsearch in unrelated earlier work, e.g. by Lample et al. [2022], but this is a more difficult task.\nA different strategy that is more easily implemented is to reduce the space of possible mappings\nfor the theorems.\nWe implemented the latter strategy in two ways. First, we implemented a matching cache.\nThe idea here is that the matching only takes into account real statements, instead of all com-\nbinations of arguments present in the problem, by numerically checking all possibly matched\nstatements and caching the true ones in the disk at the beginning of the problem. This way,\nthe full cost of matching is concentrated at the beginning of the process of solving the problem\nfor the first time, which makes the time spent in the BFS loop itself really short. This reduces\nthe overall time to solve a problem by a bit, and makes debugging and improving the code a lot\nfaster, even if one tests features on large theorems, as the matching time for building the cache\nis only spent in the first iteration of the problem.\nAnother strategy we used for reducing the time spent in matching was to reorder the state-\nments in the hypothesis of theorems in the rules.txt file in such a way that the first statements\nare the ones with fewer arguments. The guiding principle was: if the rule checking is going to\nfail, we want it to fail faster, i.e. without checking all the premises. We thus put the premises\nwith fewer arguments ahead in the checking loop, as these are resolved faster. Thus, time doesn’t\nneed to be spent on the remaining premises with more arguments, which take longer to resolve.\nThis way, failures of theorems happen faster, saving unnecessary time spent on slower match-\ning statements with more arguments. This also has the advantage of being easily tested, as one\ncan perform experiments simply by generating an alternative rules.txt file. Testing a reorga-\nnization of the rules’ hypothesis against the imo ag 30 benchmark shows a reduction of a little\nmore than 10% on those problems, see Figure 8.\n5\nReproducibility\nFor a third-party checking of the experimental results presented in [Trinh et al., 2024], given the\nnature of the software, there are two different aspects to be considered: on one hand, one should\nbe able to run the problems on AlphaGeometry’s code in order to get the same outcomes, on\nthe other hand, someone with the proper mathematical knowledge should be able to know which\nsteps were taken by the engine and verify if the proof written was mathematically correct. We\nidentified issues in AlphaGeometry (and DDAR specifically, since the LLM is secondary to these\nissues) regarding both aspects and tried to introduce improvements in both the possibility of\nreproducing results and verifying their soundness. We elaborate on these below and highlight\nhow the new additions made in previous sections aid reproducibility.\nWhen it comes to understanding and verifying proofs, DDAR presented some issues. The most\nvisible one was that some proof steps were presented without justification; that is, the recorded\n22\n\n(a) Percentage distribution of time spent on matching predicates with rules written in the old order,\nwith a clear prevalence of time spent on the costly eqratio and eqangle predicates.\n(b) Percentage distribution of time spent on matching predicates with rules written in the new order,\nwith more time spent on the quicker same clock predicate.\nFigure 8: The profiling of the level of functions where the matching of predicates occurs in the\ncode, for the problems in the imo ag 30 benchmark. It clearly shows that most of the time is\nspent on matching specific predicates, which do not depend on the nature of the problem. More\ntime spent on quicker predicates, as can be seen at the bottom, results in a shorter overall time\nfor solving problems.\n23\n\nproofs did not explicitly state which rules justified each implication. While it is true that it is\ncommon in mathematics that arguments are sometimes presented with little to no justification,\nassuming the reader can complete the argument with previous knowledge, an automatic prover\nhas to satisfy a higher level of rigour because it makes it hard to understand the inner workings of\na symbolic engine (and therefore to anticipate potential weaknesses) from proof trace inspection\nif there are gaps. In the case of DDAR, this issue is even deeper, as some steps in the proof use\nintrinsic rules, which are not made explicit anywhere.\nOne of our first tasks was to try to fill this gap (which led us to uncover the dependency\nstructure of proofs, mentioned in Subsection 4.3.1). We were only able to have fully descriptive\nproofs once we rebuilt the dependency graph of the problems, with full control of how depen-\ndencies, in particular the ones generated in the background, were transmitted to statements. By\ncontrast, in DDARN a user can fully evaluate the statements derived at each step and decide if\nany given step is sound or not.\nA more subtle issue we found when trying to run problems with DDAR at different times\nwas that the proofs written are not deterministic; that is, proofs change between iterations even\nwithout changes in the parameters. (We emphasize that this happens in DDAR alone, even\nwhere proofs are carried out without the intervention of the LLM, which naturally introduces\nnondeterminism.) Investigating this unexpected phenomenon, we found that the assignment of\ncoordinates to points during the building of the problem contained randomness, and that seemed\nto be the only source of randomness in the DDAR pipeline. In principle, this randomness should\nnot change the symbolic nature of the proof state. However, in practice, it can alter the predicates\nthat are obtained from numerical checks of the diagram built at the instantiation of the problem.\nIn particular, it can generally, with a 50% chance, change the orientation of triangles.\nNow, there was no explicit condition on the orientation of vertices of triangles to be found on\nthe rules or to be identified as a predicate. However, when checking conditions for the similarity\nand congruence of triangles, because of the use of the concept of total angles in DDAR, the\norientation of vertices of triangles is relevant. Indeed, hidden inside the specific theorem matching\nfunctions, one could find checks for the orientation of vertices of the triangles being compared (see\nthe same clock functions, which turn these hidden functions in explicit predicates, mentioned\nin Subsection 3.4.1), and those influenced the final shape of the proofs.\nIn more extreme cases, for example, in the proof of Problem 2 of the IMO 2009 exam, given\nin the Supplementary Material to the AlphaGeometry paper Trinh et al. [2024], page 29-30, the\nvery correctness of the proof depends on a choice made at random by the software. Specifically,\none of the auxiliary points described there, D, is given by the intersection of two circles. Now,\na pair of circles intersect at two points, and in that case, the solver makes the choice of which\npoint to use at random (without making it explicit). It so happens that one can find errors in\nthe written proof if the point not chosen (but that also satisfies the defining conditions of D)\nwere to be considered by the AlphaGeometry software: In that case, the statement proved in\nstep 11 of the proof (∠MLK = ∠DML) is false if one considers full angles, and the statement\nproved in step 15 (∠(LD, CO) = ∠QBO) is false under any formal definition of angles. Thus,\nthe proof in the Supplementary Material, as written, must have been arrived at from the choice\nof the correct point in the intersection of the circles, although this fact is not explicitly noted.\nTo address those issues, we took extra care to make every step explicit. First, we added\nthe mentioned same clock predicate as a numerically checked predicate and enunciated it as a\nhypothesis on the rules concerning the similarity and congruence of triangles. As a consequence,\nthe proof will explicitly show the choice made and the use of facts about the orientation of the\nvertices of the triangle in the proof.\nIndeed, combining that with the functionality we added for checking multiple goals, one\ncan steer the random choices of the orientation of triangles in the problem, and doing that for\n24\n\nProblem 2 of the 2009 IMO exam, one can verify that DDAR would not have been able to find\na solution for the problem with the other different choice of D, even if both provide the same\nstatements to the proof state by the prescribed auxiliary point.\nSeparately, to control the randomness of the engine, we introduced a seed that can control the\nrandom choices of Newclid, which must be done carefully. The randomization of the prescription\nof coordinates to points is not a trivial aspect of the building of a problem. In fact, every time\ncoordinates are prescribed in the construction of a numerical representation of the problem, the\nengine will check the correctness of the goals, and if a goal is not numerically true, the software\nwill scrap the coordinates and try to assign new ones. This can be repeated a finite number\nof times before Newclid gives up (this is currently set to be repeated 10000 times, but it only\nmatters that it is a sufficiently large number), in contrast to the original version of the software\nthat used a while loop, risking a potentially infinite loop for problems that had false goals. This\nis important not only as a sanity check but also because some assumptions needed for a problem\nare not contemplated by the language available to Newclid, for example, an open constraint on\nthe relative sides of two segments or the fact that a point is internal or external to a triangle. If\nthe space of points satisfying those conditions has a positive measure in the space of all possible\nconfigurations within the random choices of the problem, the good configuration can be reached\nrandomly, given sufficiently many tries, and that is what the randomization allows. Of course,\nfor testing, it is useful to be able to fix a good seed and have better control of the problem.\n6\nThe 5 Missing Problems From imo ag 30.txt\nIn AlphaGeometry paper by Trinh et al. [2024], the authors compile a collection of 30 problems in\nthe AlphaGeometry format from 27 unique problems from the IMO exams between 2000 and 2022\n(the last officially released exam before the writing of the paper). The three remaining problems\narise from splitting three of the problems in the set of 27 problems into two problems. From\nthose, the (original) DDAR engine solved 14/30 problems, while the full AlphaGeometry (i.e.,\nDDAR and the LLM working in tandem) at full computing capacity could solve 25/30 problems.\nThe adaptations and solutions to those 30 problems are collected in the Supplementary Material\nof [Trinh et al., 2024], their formulation into the language used by AlphaGeometry is contained\nin the file imo ag 30.txt of the original AlphaGeometry codebase on GitHub.\nStudying the five problems that AlphaGeometry was not able to solve (2008 P1B, 2008 P6,\n2011 P6, 2019 P2, and 2021 P3) is instructive and provides insights regarding the capabilities\nand limitations of AlphaGeometry both as a concrete software, with its technical and specific\ndesign limitations, and as an overall project of a coordinate agnostic automatic reasoning system.\nBelow, we discuss each of these five problems, highlight what was missing for the engine to\nsolve them, or the reason for their non-solvability when that is the case.\nOne should keep in mind that there is a level of stochasticity in the analysis of why problems\nfail, as one can only speculate on the precise reasons a probability-based machine such as an LLM\ntakes a specific path in comparison to another one. Also, the axiomatic reasoning developed by\nDDAR, which is also incorporated in DDARN, despite being deterministic in principle, is highly\nsensitive to changes in the formulation of problems and rules, so it is to be expected that other\nmodifications different from the ones we proposed can have the same positive outcome as a result.\nProblem 2 from IMO 2019 is already discussed in the Extended Data, Figure 4, of the original\npaper, so it is briefly mentioned here for completeness only.\n25\n\n6.1\nIMO 2008 P1B\nProblem (Original Formulation of P1 2008 (Evan Chen’s Solution Notes)). Let H be the or-\nthocenter of the acute-angled triangle ABC. The circle ΓA centered at the midpoint of BC and\npassing through H intersects the sideline BC at points A1 and A2. Similarly, define the points\nB1, B2, C1, and C2. Prove that six points A1, A2, B1, B2, C1, C2 are concyclic.\nExplanation of our translation of P1 2008 (with auxiliary points in red):\nConsider\nthe triangle ABC, and that also\n• H is the orthocenter of ABC.\n• D is the midpoint of BC.\n• E is the midpoint of AC.\n• F is the midpoint of AB.\n• A1 is the first intersection of the circle of center D through H and line BC.\n• A2 is the second intersection of the circle of center D through H and line BC.\n• B1 is the first intersection of the circle of center E through H and line AC.\n• B2 is the second intersection of the circle of center E through H and line AC.\n• C1 is the first intersection of the circle of center F through H and line AB.\n• C2 is the second intersection of the circle of center F through H and line AB.\n• O1 is the point on the line perpendicular to EF, through H, such that the distance from E\nto O1 is the distance from E to H (the reflection of H across the line EF).\n• O2 is the point on the line perpendicular to ED, through H, such that the distance from E\nto O2 is the distance from E to H (the reflection of H across the line ED).\n• O3 is the point on the line perpendicular to FD, through H, such that the distance from F\nto O3 is the distance from F to H (the reflection of H across the line FD).\n• O is the center of the circle through C1, C2, and B1.\nThen, prove that A1, A2, B1, B2, C1, C2 are concyclic.\nFormal translation of our problem:\na b c = t r i a n g l e\na b c ;\nh = orthocenter h a b c ;\nd = midpoint d b c ;\ne = midpoint\ne a c ;\nf = midpoint\nf\na b ;\na1 = o n c i r c l e\na1 d h ,\no n l i n e\na1 b c ;\na2 = o n c i r c l e\na2 d h ,\no n l i n e\na2 b c ;\nb1 = o n c i r c l e\nb1 e h ,\no n l i n e\nb1 c a ;\nb2 = o n c i r c l e\nb2 e h ,\no n l i n e\nb2 c a ;\nc1 = o n c i r c l e\nc1\nf\nh ,\no n l i n e\nc1 a b ;\nc2 = o n c i r c l e\nc2\nf\nh ,\no n l i n e\nc2 a b ;\n26\n\nFigure 9: Diagram for the statement of Problem 1 of the IMO 2008 exam.\no1 = eqdistance\no1 e e h ,\no n t l i n e\no1 h e\nf ;\no2 = eqdistance\no2 e e h ,\no n t l i n e\no2 h e d ;\no3 = eqdistance\no3\nf\nf\nh ,\no n t l i n e\no3 h\nf\nd ;\no = c i r c l e\no c1\nc2 b1 ?\nc y c l i c\nc1\nc2 b1 b2 a1 a2\nDiscussion:\nProblem 1 of the 2008 IMO exam asked to prove that a collection of six points\n(A1, A2, B1, B2, C1, and C2 in the original formulation) lied in the same circle. In terms of the\ninternal language of AlphaGeometry, that should be expressed by a cyclic predicate.\nIn the original formulation by Trinh et al. [2024], problem 1 from the 2008 IMO exam was\nsplit into two problems, one asking for cyclic B1 B2 C1 C2 (2008 P1A) and the other asking\nfor cyclic C1 C2 B1 A1 (2008 P1B), choice that was probably motivated by the fact that the\n“natural” presentation of the cyclic predicate has four arguments, as any triple of points in\ngeneral position determines a circle. In case both problems were solved, still some human vision\nwould be needed to understand that proving both facts is enough for the complete problem, as\nthey cover the two possible configurations of quadruples of points distributed pairwise on the\nsides of a triangle. So the full problem could be proven “analogously”. Of course, a larger issue\nis that AlphaGeometry was only able to solve P1A, but not P1B.\nTrying to understand what AlphaGeometry missed for this problem, the first thing to observe\nis that cyclic is a predicate that accepts any list of points, so one can straight away ask for\ncyclic A1 A2 B1 B2 C1 C2 as a goal in the formulation, without the need to split the problem\nin two. Of course, as AlphaGeometry could not solve P1B, it cannot solve the unified formulation\n27\n\neither, even if provided via a new clause with the additional clauses that allowed the solution of\nP1A.\nBut observing the clause suggested for the proof of P1A, we can get a good outline of how to\nproceed in solving this problem: P1A was solved by adding the point O (O1 in our formulation),\nthe reflection of the orthocenter H of the triangle by a line connecting midpoints E and F of\nsides AC and AB, respectively. Those are exactly the sides where points B1, B2, C1, and C2,\nmentioned in the goal of P1A, lie. One way to prove that all the points mentioned lie in a single\ncycle would be to reprove P1A for the three pairs of adjacent sides of the triangle and then show\nthat all the circles found are the same.\nWith this in mind, we prescribed O1, O2, and O3, the reflections of H along the three lines\nconnecting midpoints of sides of the triangle, extending the suggestion given for P1A. This proved\nnot to be enough for DDARN to prove all six points lie on the same circle, so we also added O,\nthe center of the circle through C1, C2, and B1 (and the common center to all circles already\ndetected by the solver analogously to P1A). Then DDARN could find a solution to the problem.\nThe existence of this solution suggests a better understanding both of the behaviour of the\nLLM and of the limitations of the original rules of DDAR. For the LLM, it is plausible to assume\nthat, as it did find a good clause O for 2008 P1A in the original run described in [Trinh et al.,\n2024], it could propose O1, O2, and O3 in our construction, as they all play the same role, up\nto a cyclic permutation of the sides of the triangle. The problem, of course, is that there is\nno evidence that the LLM can profit from such symmetry of points, so it would need to repeat\nwhatever reasoning brought it O thrice, demanding triple resources. This does not mean it could\ndecide to suggest our O, the center of the circle asked in the goal, although that is also a natural\npoint to suggest. Simply making all those decisions would demand too much depth in the search.\nOn the other hand, we did try to run our new formulation of 2008 P1 with the original set of\nrules from DDAR, and it still exhausted the DDAR search without finding a proof. Reviewing\nour proof, on the other hand, reveals the use of rules r49 and r50 (the need for rule r50, in\nfact, was detected by studying this very problem); see Appendix A. Those two rules contain very\nsimple facts about circles: that points lying on the same circle are equidistant from the center\nand that the intersection of the perpendicular bisectors of non-parallel chords of a circle happens\nat its center. Nonetheless, those facts were unknown to the original DDAR formulation, and\ntheir addition is necessary for the solution of some problems involving circumferences and cyclic\npoints, such as 2008 P1.\nA full output of the solution of Newclid for this problem can be found in Appendix B.\n6.2\nIMO 2008 P6\nProblem (Original Formulation of P6 2008 (Evan Chen’s Solution Notes)). Let ABCD be a\nconvex quadrilateral with BA ̸= BC. Denote the incircles of triangles ABC and ADC by ω1\nand ω2 respectively. Suppose that there exists a circle ω tangent to ray BA beyond A and to\nthe ray BC beyond C, which is also tangent to the lines AD and CD. Prove that the common\nexternal tangents to ω1 and ω2 intersect on ω.\nExplanation of AlphaGeometry’s translation of P6 2008:\nConsider the triangle XY Z\nwith prescribed coordinates (they will determine the circle ω), and also that\n• O is the center of the circle through X, Y , and Z.\n• W is a point on the circle with center O through X, with prescribed coordinates.\n• A is the intersection of the line perpendicular to OZ at Z with the line perpendicular to OX\nat X (so AZ is tangent to ω at Z and AX is tangent to ω at X).\n28\n\n• B is the intersection of the line perpendicular to OZ at Z with the line perpendicular to OW\nat W.\n• C is the intersection of the line perpendicular to OY at Y with the line perpendicular to OW\nat W.\n• D is the intersection of the line perpendicular to OX at X and the line perpendicular to OY\nat Y .\n• I1 is the incenter of the triangle ABC.\n• I2 is the incenter of the triangle ACD.\n• F1 is the orthogonal projection of I1 onto the side AC (so ω1 has center I1 and goes through\nF1).\n• F2 is the orthogonal projection of I2 onto the side AC (so ω2 has center I2 and goes through\nF2).\n• Q is the point of tangency to the circle ω1 and T is the point of tangent to the circle ω2 of a\ncommon tangent to both cicles.\n• P is the point of tangency to the circle ω1 and S is the point of tangency to the circle ω2 of a\ncommon tangent to both circles.\n• K is the intersection of lines QT and PS.\nThen, prove that OK = OX.\nFormal translation of the problem:\nx@4 .96\n−0.13 y@−1.0068968328888160\n−1.2534881080682770\nz@−2.8402847238575120\n−4.9117762734006830 = t r i a n g l e\nx y z ;\no = c i r c l e\no x y z ;\nw@6.9090049230038776\n−1.3884003936987552 = o n c i r c l e w o x ;\na = o n t l i n e\na z o z ,\no n t l i n e\na x o x ;\nb = o n t l i n e\nb z o z ,\no n t l i n e\nb w o w;\nc = o n t l i n e\nc y o y ,\no n t l i n e\nc w o w;\nd = o n t l i n e\nd x o x ,\no n t l i n e\nd y o y ;\ni1 = i n c e n t e r\ni1\na b c ;\ni2 = i n c e n t e r\ni2\na c d ;\nf1 = foot\nf1\ni1\na c ;\nf2 = foot\nf2\ni2\na c ;\nq t p s = cc tangent\nq t p s\ni1\nf1\ni2\nf2 ;\nk = o n l i n e\nk q t ,\no n l i n e\nk p s\n? cong o k o x\nDiscussion:\nProblem 6 of the 2008 IMO exam is an example of a problem where, for technical\nreasons, not all the premises given in the problem can be well described by the symbolic system\nused in DDAR, and that results in an ambiguity that cannot be solved within the design choices\nof the pseudo-axiomatic system used by AlphaGeometry, and there is no simple way to fix those\nlimitations.\nThe problem presents two circles, W1 and W2, and asks something about K, the intersection\nof the common external tangents to W1 and W2 specifically, that it lies on a third circle W.\n29\n\nFigure 10: Diagram for the statement of Problem 6 of the IMO 2008 exam.\n30\n\nThe issue here is that there are four common tangents to the pair of circles, which results in 6\nintersections of pairs of common tangents to the circles. Of those, only one of them lies on W.\nFor a human, it is not hard to make this distinction and find good arguments that fit the\ncorrect drawing and that lead towards proof. But this involves a collection of unsaid assumptions\nabout that specific pair of lines that are not available for the computer. Even if the construction\ncreated in AlphaGeometry to represent a situation like this (definition cc tangent) generates a\nbackground coordinate representation of the problem that effectively assumes the choice of the\nexternal tangents, there is no symbolical information in terms of predicates that separates the\n“good” choice of the pair of tangents from the “bad” choices. In practical terms, this means that\nif we could write a proof for this problem, each step of it would apply as well to the other five\npoints that are intersections of common tangents to W1 and W2. But those do not lie in W,\nand the proof would be false.\nTrying to update the foundations to encompass a solution for this problem would involve first\ncreating predicates that would allow the distinction between the different line configurations and\nthen assuring that we have a powerful set of deduction rules that allows for consequences of\nsuch predicates to be derived up to the desired results. As the current version of both DDAR\nand DDARN are not equipped to prescribe and recognize in-betweenness, we envision it will be\ndifficult to devise an axiomatic system that could deal with this problem.\nAs it remains now, 2008 P6 is a case of undecidability of DDAR as well as DDARN.\n6.3\nIMO 2011 P6\nProblem (Original Formulation of P6 2011 (IMO Shortlist File - G8)). Let ABC be an acute\ntriangle with circumcircle ω. Let t be a tangent line to ω. Let ta, tb, and tc be the lines obtained\nby reflecting t in the lines BC, CA, and AB, respectively. Show that the circumcircle of the\ntriangle determined by the lines ta, tb, and tc is tangent to the circle ω.\nExplanation of AlphaGeometry’s translation of P6 2011:\nConsider triangle ABC, and\nalso that\n• O is the circumcenter of ABC.\n• P is a point on the circle centered in O through A.\n• Q is a point on the line perpendicular to OP at P (the tangent line to the circle centered at\nO at P). So the line PQ is t.\n• Pa is the image of P reflected through BC.\n• Pb is the image of P reflected through CA.\n• Pc is the image of P reflected through AB.\n• Qa is the image of Q reflected through BC (so the line PaQa is ta).\n• Qb is the image of Q reflected through CA (so the line PbQb is tb).\n• Qc is the image of Q reflected through AB (so the line PcQc is tc).\n• A1 is the intersection of tb and tc.\n• B1 is the intersection of tb and tc.\n31\n\n• C1 is the intersection of ta and tb.\n• O1 is the circumcenter of A1B1C1.\n• X is a point in the intersection of the circles of center O through A and of center O1 through\nA1.\nThen, prove that X, O, and O1 are collinear (if the centers of two circles and an intersection\npoint of theirs are collinear, the intersection point is a tangency point of the pair of circles).\nFormal translation of our problem:\na b c = t r i a n g l e\na b c ;\no = c i r c l e\no a b c ;\np = o n c i r c l e\np o a ;\nq = o n t l i n e\nq p o p ;\npa = r e f l e c t\npa p b c ;\npb = r e f l e c t\npb p c a ;\npc = r e f l e c t\npc p a b ;\nqa = r e f l e c t\nqa q b c ;\nqb = r e f l e c t\nqb q c a ;\nqc = r e f l e c t\nqc q a b ;\na1 = o n l i n e\na1 pb qb ,\no n l i n e\na1 pc qc ;\nb1 = o n l i n e\nb1 pa qa ,\no n l i n e\nb1 pc qc ;\nc1 = o n l i n e\nc1 pa qa ,\no n l i n e\nc1 pb qb ;\no1 = c i r c l e\no1 a1 b1 c1 ;\nx = o n c i r c l e\nx o a ,\no n c i r c l e\nx o1 a1 ?\nc o l l\nx o o1\nDiscussion:\nAfter many attempts to solve this problem through the addition of extra points,\nno clear candidate for a new minor fix of the engine proved to be a solution. Neither there seems\nto be a good reason for it to be undecidable. The only commentary that can be made after a\nlong effort is that there seems to be a lack of links between the information associated with point\nX, defined as the intersection of the two circumcircles, and the rest of the problem.\nIn fact, the proof suggested in the 2011 IMO shortlist file, see [Smit et al., 2011], uses the\ndefinition of an alternative point, for example, a point K, the intersection of another pair of\ncircles, and proceeds to prove K = X. This is essentially a proof by contradiction (two distinct\npoints exist then prove that they are the same), a scheme that is not available for AlphaGeometry\nfor two reasons: first, there are checks to prevent the instantiation of two overlapping points,\nand second, there is no set of axioms that can perform a logical chain ending in “two points are\nthe same”. It is not impossible to imagine that adaptations could be made to Newclid to allow\nthis sort of argument, but that would take us too far from the scope chosen for this project.\n6.4\nIMO 2019 P2\nThis problem had a solution presented in the original paper [Trinh et al., 2024], given by the\nmanual provision of three extra points (which the LLM module could not find), after which the\noriginal formulation of DDAR can write a proof.\nThe human-aided solution to this problem was provided by the authors in their Supplementary\nMaterial, and a conjecture on why the transformer could not detect the suggested points in the\nExtended Data Fig. 4 of the original paper.\n32\n\nFigure 11: Diagram for the statement of Problem 6 of the IMO 2011 exam.\n6.5\nIMO 2021 P3\nProblem (Original Formulation of P3 2021 (Evan Chen’s Solution Notes)). Let D be an interior\npoint of the acute triangle ABC with AB > AC so that ∠DAB = ∠CAD. The point E on the\nsegment AC satisfies ∠FDA = ∠DBC, and the point X on the line AC satisfies CX = BX.\nLet O1 and O2 be the circumcenters of the triangles ADC and EXD, respectively. Prove that\nthe lines BC, EF, and O1O2 are concurrent.\nExplanation of AlphaGeometry’s translation of P3 2021:\nConsider triangle ABC, and\nalso\n• D a point in the bisector of angle ∠BAC.\n• E a point on line AC such that ∠EDA = ∠DCB.\n• F a point on line AB such that ∠FDA = ∠DBC.\n• X a point on the intersection of the bisector of segment BC with line AC.\n• O1 the center of the circle through A, D, and C.\n• O2 the center of the circle through E, X, and D.\n• Y the intersection of lines EF and BC.\nThen, prove that O1, O2, and Y are collinear.\n33\n\nFigure 12: Diagram for the statement of Problem 3 of the IMO 2021 exam.\nFormal translation of the problem:\na b c = t r i a n g l e\na b c ;\nd = a n g l e b i s e c t o r\nb a c ;\ne = o n a l i n e\nd a d c b ,\no n l i n e\na c ;\nf = o n a l i n e\nd a d b c ,\no n l i n e\na b ;\nx = on bli ne\nb c ,\no n l i n e\na c ;\no1 = c i r c l e\na d c ;\no2 = c i r c l e\ne x d ;\ny = o n l i n e\ne\nf ,\no n l i n e\nb c ?\nc o l l\no1 o2 y\nDiscussion:\nThis problem, as 2008 P6, presents a premise that cannot be expressed by Al-\nphaGeometry’s engine, namely that point D is interior to the triangle. In general, those kinds\nof open premises on geometry problems are usually associated with non-degeneracy conditions\nfor the construction of the points of the problem, a situation AlphaGeometry can handle by cre-\nating an explicit instance of the problem before starting the solution and checking numerically\nfor the expected goal. If it fails at that point, it will try again with some random variation\nwithin its degrees of freedom in the hope that, eventually, it will find a good regime for the con-\nstruction. Another possible reason for adding open conditions is to avoid a multiplicity of cases\nthat would take too much unnecessary time for the person solving the problem, a consideration\nAlphaGeometry does not have to deal with.\nThe case of problem 3 of the 2021 IMO exam is different.\nHere, if the non-degeneracy\ncondition is violated, we do not have the construction breaking down, but rather, if D is external\nto ABC, the goal becomes false, while all the conditions of the problem remain in place. This\nmeans AlphaGeometry will be able to build an instance of the problem and try to proceed\nto the proof, but as in the case of problem 2008 P6, there is no symbolic difference within\nAlphaGeometry’s symbolic engine between the regime where the goal of the problem is true\n34\n\nand where it is false. As a consequence, if a proof were written down for the regime where the\nproblem is true, it would also hold for the regime where the problem is false, hence it would be\nincorrect. It is also a case of undecidability of the axiomatic system.\nAgain, to be able to handle such problems is not simply a matter of designing definitions\nthat allow the insertion of information like “D internal to ABC” into the engine.\nA whole\ncollection of deduction rules must be developed to allow the consequences of that information to\nbe transmitted through the reasoning.\n7\nLimitations and Future Work\nGeoGebra input\nThere are a couple of drawbacks related to using the GeoGebra constructor.\nFirst, one has to understand how to perform the geometric construction of the problem with\na straightedge and compass sense. Nonetheless, this is also often the case when writing problems\nin formal language, as the order of the points constructed often has to be coherent with the\ngeometric dependency of some points on others.\nSecond, because of the flexibility of calling all numerical tools available to Python when\nwriting a definition, there is a greater flexibility of definitions when proposing a problem with\nthe formal language when compared to the closed set of tools available in GeoGebra.\nThat\nsaid, we do believe the ease of use surpasses such drawbacks, especially as the vast majority of\nproblems in plane geometry should admit a GeoGebra construction.\nNewclid’s interface.\nCurrently, Newclid’s user interface is very rudimentary, albeit straight-\nforward. For a normal user, Newclid can import a geometric construction from a GeoGebra file\nand solve the problem via DDARN, which runs using breadth-first-search or using a Human\nAgent.\nWe plan to improve the interface of Newclid to complete it as a public training gym for auxil-\niary points finding using AI approaches (including, but not limited to, an LLM-based approach,\nsuch as the one from AlphaGeometry), with both text description and geometrical graphics as\ninput and auxiliary points as output.\nNewclid’s LLM module.\nOur work to date focused on improving DDAR, which resulted in\nthe new system DDARN. Our motivation for this choice, as argued in the introduction, was that\nmost of the performance benefits of AlphaGeometry come from DDAR. AlphaGeometry’s LLM\nis written in Meliad. We plan to release a PyTorch version of the LLM, with the same weights as\nthe original model, so that the LLM can be easily integrated and used in the Newclid interface.\n8\nConclusion\nWe have presented an improved and expanded version of AlphaGeometry, called Newclid, that\nenables user-friendly interaction to solve IMO-level geometry and an agentic interface that can\neasily be augmented by various agents to guide how DDARN solves problems.\nFurther, we\npresent a much-improved codebase that has better debugging capabilities, and we encourage the\ncommunity to improve and extend our codebase to enable more user-friendly interactions.\n35\n\nAcknowledgments\nWe thank Ronald Cardenas Acosta for their helpful support during the development of this\nproject.\nA\nList of rules\nIn this section, we have the content of the unabridged rules.txt file, containing the largest\ncollection of rules were that used and experimented with in Newclid. The current implementation\nof the rules.txt file contains r01, r03-r07, r11-r29, r34, r3, r42, r49, and r51-r63 and\nrepresents the rules that are used by DDARN. The missing numbers in the rules.txt file\ncorrespond to those rules of DDAR, listed in [Trinh et al., 2024] that contain the now unsupported\npredicates simtri* and contri*. They were replaced by new rules that make the logical steps\nof the triangle similarity arguments fully explicit. More information on the history of each rule\ncan be found in the relevant documentation section.3\nList of rules with names:\nr00\nPerpendiculars\ngive\np a r a l l e l\nperp A B C D,\nperp C D E F,\nn c o l l A B E => para A B E F\nr01\nD e f i n i t i o n\nof\nc i r c l e\ncong O A O B,\ncong O B O C,\ncong O C O D => c y c l i c A B C D\nr02\nP a r a l l e l\nfrom\ni n c l i n a t i o n\neqangle A B P Q C D P Q => para A B C D\nr03\nArc\ndetermines\ni n t e r n a l\nangles\nc y c l i c A B P Q => eqangle P A P B Q A Q B\nr04\nCongruent\nangles\nare\nin\na\nc i r c l e\neqangle P A P B Q A Q B,\nn c o l l P Q A B => c y c l i c A B P Q\nr05 Same arc\nsame chord\nc y c l i c A B C P Q R,\neqangle C A C B R P R Q => cong A B P Q\nr06\nBase\nof\nh a l f\nt r i a n g l e\nmidp E A B,\nmidp F A C => para E F B C\nr07\nThales Theorem\nI\npara A B C D,\nc o l l O A C,\nc o l l O B D => e q r a t i o 3 A B C D O O\nr08\nRight\nt r i a n g l e s common angle\nI\nperp A B C D,\nperp E F G H,\nnpara A B E F => eqangle A B E F C D G H\nr09 Sum of\nangles\nof\na\nt r i a n g l e\neqangle\na b c d m n p q ,\neqangle\nc d e\nf\np q r u => eqangle\na b e\nf m n\nr u\nr10\nRatio\nc a n c e l l a t i o n\n3https://lmcrc.github.io/Newclid/manual/default_files/index.html\n36\n\ne q r a t i o\na b c d m n p q ,\ne q r a t i o\nc d e\nf\np q r u => e q r a t i o\na b e\nf m n\nr u\nr11\nBisector\ntheorem\nI\ne q r a t i o\nd b d c a b a c ,\nc o l l\nd b c ,\nn c o l l\na b c => eqangle\na b a d a d\na c\nr12\nBisector\ntheorem\nI I\neqangle\na b a d a d a c ,\nc o l l\nd b c ,\nn c o l l\na b c => e q r a t i o\nd b d c a b\na c\nr13\nI s o s c e l e s\nt r i a n g l e\nequal\nangles\ncong O A O B,\nn c o l l O A B => eqangle O A A B A B O B\nr14\nEqual\nbase\nangles\nimply\ni s o s c e l e s\neqangle A O A B B A B O,\nn c o l l O A B => cong O A O B\nr15\nArc\ndetermines\ni n s c r i b e d\nangles\n( tangent )\nc i r c l e O A B C,\nperp O A A X => eqangle A X A B C A C B\nr16 Same arc\ngiving\ntangent\nc i r c l e O A B C,\neqangle A X A B C A C B => perp O A A X\nr17\nCentral\nangle\nvs\ni n s c r i b e d\nangle\nI\nc i r c l e O A B C,\nmidp M B C => eqangle A B A C O B O M\nr18\nCentral\nangle\nvs\ni n s c r i b e d\nangle\nI I\nc i r c l e O A B C,\nc o l l M B C,\neqangle A B A C O B O M => midp M B C\nr19\nHypothenuse\ni s\ndiameter\nperp A B B C,\nmidp M A C => cong A M B M\nr20\nDiameter\ni s\nhypotenuse\nc i r c l e O A B C,\nc o l l O A C => perp A B B C\nr21\nCyclic\ntrapezoid\nc y c l i c A B C D,\npara A B C D => eqangle A D C D C D C B\nr22\nBisector\nConstruction\nmidp M A B,\nperp O M A B => cong O A O B\nr23\nBisector\ni s\nperpendicular\ncong A P B P,\ncong A Q B Q => perp A B P Q\nr24\nCyclic\nk i t e\ncong A P B P,\ncong A Q B Q,\nc y c l i c A B P Q => perp P A A Q\nr25\nDiagonals\nof\nparallelogram\nI\nmidp M A B,\nmidp M C D => para A C B D\nr26\nDiagonals\nof\nparallelogram\nI I\nmidp M A B,\npara A C B D,\npara A D B C => midp M C D\n37\n\nr27\nThales\ntheorem\nI I\ne q r a t i o O A A C O B B D,\nc o l l O A C,\nc o l l O B D,\nn c o l l A B C,\nsameside A\nO C B O D => para A B C D\nr28\nOverlapping\np a r a l l e l s\npara A B A C => c o l l A B C\nr29\nMidpoint\ni s\nan\ne q r a t i o\nmidp M A B,\nmidp N C D => e q r a t i o M A A B N C C D\nr30\nRight\nt r i a n g l e s common angle\nI I\neqangle A B P Q C D U V,\nperp P Q U V => perp A B C D\nr31\nDenominator\nc a n c e l l i n g\ne q r a t i o A B P Q C D U V,\ncong P Q U V => cong A B C D\nr34 AA S i m i l a r i t y\nof\nt r i a n g l e s\n( d i r e c t )\neqangle B A B C Q P Q R,\neqangle C A C B R P R Q,\nn c o l l A B C,\nsameclock\nA B C P Q R => s i m t r i A B C P Q R\nr35 AA S i m i l a r i t y\nof\nt r i a n g l e s\n( r e v e r s e )\neqangle B A B C Q R Q P,\neqangle C A C B R Q R P,\nn c o l l A B C,\nsameclock\nA B C P R Q => s i m t r i r A B C P Q R\nr36 ASA Congruence\nof\nt r i a n g l e s\n( d i r e c t )\neqangle B A B C Q P Q R,\neqangle C A C B R P R Q,\nn c o l l A B C,\ncong A B\nP Q,\nsameclock A B C P Q R => c o n t r i A B C P Q R\nr37 ASA Congruence\nof\nt r i a n g l e s\n( r e v e r s e )\neqangle B A B C Q R Q P,\neqangle C A C B R Q R P,\nn c o l l A B C,\ncong A B\nP Q,\nsameclock A B C P R Q => c o n t r i r A B C P Q R\nr41\nThales\ntheorem\nI I I\npara a b c d ,\nc o l l m a d ,\nc o l l\nn b c ,\ne q r a t i o m a m d n b n c ,\nsameside\nm a d n b c => para m n a b\nr42\nThales\ntheorem IV\npara a b c d ,\nc o l l m a d ,\nc o l l\nn b c ,\npara m n a b => e q r a t i o m a m d n\nb n c\nr43\nOrthocenter\ntheorem\nperp a b c d ,\nperp a c b d => perp a d b c\nr44 Pappus ’ s\ntheorem\nc o l l\na b c ,\nc o l l\np q r ,\nc o l l\nx a q ,\nc o l l\nx p b ,\nc o l l\ny a\nr ,\nc o l l\ny p c ,\nc o l l\nz b r ,\nc o l l\nz c q => c o l l\nx y z\nr45\nSimson ’ s\nl i n e\ntheorem\nc y c l i c\na b c p ,\nc o l l\na\nl\nc ,\nperp p\nl\na c ,\nc o l l m b c ,\nperp p m b c ,\nc o l l\nn a b ,\nperp p n a b => c o l l\nl m n\nr46\nIncenter\ntheorem\neqangle\na b a x a x a c ,\neqangle b a b x b x b c ,\nn c o l l\na b c => eqangle\n38\n\nc b c x c x c a\nr47\nCircumcenter\ntheorem\nmidp m a b ,\nperp x m a b ,\nmidp n b c ,\nperp x n b c ,\nmidp p c a => perp x\np c a\nr48\nCentroid\ntheorem\nmidp m a b ,\nc o l l m x c ,\nmidp n b c ,\nc o l l\nn x a ,\nmidp p c a => c o l l\nx p b\nr49\nRecognize\ncenter\nof\nc y c l i c\n( c i r c l e )\nc i r c l e O A B C,\nc y c l i c A B C D => cong O A O D\nr50\nRecognize\ncenter\nof\nc y c l i c\n( cong )\nc y c l i c A B C D,\ncong O A O B,\ncong O C O D,\nnpara A B C D => cong O A O C\nr51\nMidpoint\ns p l i t s\nin\ntwo\nmidp M A B => rconst M A A B 1/2\nr52\nProperties\nof\ns i m i l a r\nt r i a n g l e s\n( Direct )\ns i m t r i A B C P Q R => eqangle B A B C Q P Q R,\ne q r a t i o B A B C Q P Q R\nr53\nProperties\nof\ns i m i l a r\nt r i a n g l e s\n( Reverse )\ns i m t r i r A B C P Q R => eqangle B A B C Q R Q P,\ne q r a t i o B A B C Q P Q R\nr54\nD e f i n i t i o n\nof\nmidpoint\ncong M A M B,\nc o l l M A B => midp M A B\nr55\nProperties\nof\nmidpoint\n( cong )\nmidp M A B => cong M A M B\nr56\nProperties\nof\nmidpoint\n( c o l l )\nmidp M A B => c o l l M A B\nr57\nPythagoras\ntheorem\nPythagoreanPremises a b c => PythagoreanConclusions\na b c\nr58 Same chord same\narc\nI\nc y c l i c\na b c p q r ,\ncong a b p q ,\nsameclock\nc a b r p q ,\nsameside\nc a b\nr p q => eqangle\nc a c b r p r q\nr59 Same chord same\narc\nI I\nc y c l i c\na b c p q r ,\ncong a b p q ,\nsameclock\nc b a\nr p q ,\nnsameside\nc b a\nr p q => eqangle\nc a c b r q r p\nr60 SSS\nS i m i l a r i t y\nof\nt r i a n g l e s\n( Direct )\ne q r a t i o B A B C Q P Q R,\ne q r a t i o C A C B R P R Q,\nn c o l l A B C,\nsameclock\nA B C P Q R => s i m t r i A B C P Q R\nr61 SSS\nS i m i l a r i t y\nof\nt r i a n g l e s\n( Reverse )\ne q r a t i o B A B C Q P Q R,\ne q r a t i o C A C B R P R Q,\nn c o l l A B C,\nsameclock\nA B C P R Q => s i m t r i r A B C P Q R\nr62 SAS S i m i l a r i t y\nof\nt r i a n g l e s\n( Direct )\n39\n\ne q r a t i o B A B C Q P Q R,\neqangle B A B C Q P Q R,\nn c o l l A B C,\nsameclock\nA B C P Q R => s i m t r i A B C P Q R\nr63 SAS S i m i l a r i t y\nof\nt r i a n g l e s\n( Reverse )\ne q r a t i o B A B C Q P Q R,\neqangle B A B C Q P Q R,\nn c o l l A B C,\nsameclock\nA B C P R Q => s i m t r i r A B C P Q R\nr64 SSS Congruence\nof\nt r i a n g l e s\n( Direct )\ncong A B P Q,\ncong B C Q R,\ncong C A R P,\nn c o l l A B C,\nsameclock A B C P\nQ R => c o n t r i A B C P Q R\nr65 SSS Congruence\nof\nt r i a n g l e s\n( Reverse )\ncong A B P Q,\ncong B C Q R,\ncong C A R P,\nn c o l l A B C,\nsameclock A B C P\nR Q => c o n t r i r A B C P Q R\nr66 SAS Congruence\nof\nt r i a n g l e s\n( Direct )\ncong A B P Q,\ncong B C Q R,\neqangle B A B C Q P Q R,\nn c o l l A B C,\nsameclock A B C P Q R => c o n t r i A B C P Q R\nr67 SAS Congruence\nof\nt r i a n g l e s\n( Reverse )\ncong A B P Q,\ncong B C Q R,\neqangle B A B C Q P Q R,\nn c o l l A B C,\nsameclock A B C P R Q => c o n t r i r A B C P Q R\nr68\nS i m i l a r i t y\nwithout\ns c a l i n g\n( Direct )\ne q r a t i o B A B C Q P Q R,\ne q r a t i o C A C B R P R Q,\nn c o l l A B C,\ncong A B\nP Q,\nsameclock A B C P Q R => c o n t r i A B C P Q R\nr69\nS i m i l a r i t y\nwithout\ns c a l i n g\n( Reverse )\ne q r a t i o B A B C Q P Q R,\ne q r a t i o C A C B R P R Q,\nn c o l l A B C,\ncong A B\nP Q,\nsameclock A B C P R Q => c o n t r i r A B C P Q R\n40\n\nB\nFull Solution IMO 2008 P1\nHere we present the full proof of problem 1 from the IMO 2008 exam discussed in Subsection 6.1,\nas generated by Newclid. The auxiliary constructions were added by a human. DDAR was not\nable to solve this problem even if provided the extra points.\n==========================\n∗From theorem\npremises :\nA B C H D E F A1 A2 B1 B2 C1 C2 :\nPoints\nAH ⊥BC [ 0 0 ]\nBH ⊥AC [ 0 1 ]\nB,C,D are\nc o l l i n e a r\n[ 0 2 ]\nDB = DC [ 0 3 ]\nA,E,C are\nc o l l i n e a r\n[ 0 4 ]\nEA = EC [ 0 5 ]\nB,A,F are\nc o l l i n e a r\n[ 0 6 ]\nFA = FB [ 0 7 ]\nB, A 1 ,C are\nc o l l i n e a r\n[ 0 8 ]\nDA 1 = DH [ 0 9 ]\nB, A 2 ,C are\nc o l l i n e a r\n[ 1 0 ]\nDA 2 = DH [ 1 1 ]\nA, B 1 ,C are\nc o l l i n e a r\n[ 1 2 ]\nEB 1 = EH [ 1 3 ]\nA,C, B 2\nare\nc o l l i n e a r\n[ 1 4 ]\nEB 2 = EH [ 1 5 ]\nB,A, C 1\nare\nc o l l i n e a r\n[ 1 6 ]\nFC 1 = FH [ 1 7 ]\nB,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ]\nFC 2 = FH [ 1 9 ]\n∗\nAuxiliary\nConstructions :\nO1 O2 O3 O :\nPoints\nO 1E = EH [ 2 0 ]\nO 1H ⊥EF [ 2 1 ]\nO 2E = EH [ 2 2 ]\nDE ⊥HO 2\n[ 2 3 ]\nO 3F = FH [ 2 4 ]\nHO 3 ⊥DF [ 2 5 ]\nOC 1 = OC 2\n[ 2 6 ]\nOC 2 = OB 1\n[ 2 7 ]\n∗Proof\nsteps :\n001. OC 1 = OC 2\n[ 2 6 ] & OC 2 = OB 1\n[ 2 7 ]\n( why cong resolution )⇒\nOB 1 =\nOC 1\n[ 2 8 ]\n002. C 1O = B 1O\n[ 2 8 ] & OC 1 = OC 2\n[ 2 6 ]\n( w h y c i r c l e r e s o l u t i o n )⇒\nO i s\nthe\ncircumcenter\nof\n\\ Delta\nC 1B 1C 2\n[ 2 9 ]\n003. A,C, B 2\nare\nc o l l i n e a r\n[ 1 4 ] & A,C, B 1\nare\nc o l l i n e a r\n[ 1 2 ]\n( i04 )⇒\nA, B 1 , B 2\nare\nc o l l i n e a r\n[ 3 0 ]\n004. B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ] & B,A, C 1\nare\nc o l l i n e a r\n[ 1 6 ]\n( i04 )⇒\nB,A, C 2 , C 1\nare\nc o l l i n e a r\n[ 3 1 ]\n005. EB 1 = EH [ 1 3 ] & O 1E = EH [ 2 0 ] & EB 2 = EH [ 1 5 ]\n( i01 )⇒\nO 1 , B 1 , B 2 ,H are\nc o n c y c l i c\n[ 3 2 ]\n006.\nO 1 , B 1 , B 2 ,H are\nc o n c y c l i c\n[ 3 2 ]\n( r03 )⇒\n∠O 1B 2B 1 = ∠O 1HB 1\n[ 3 3 ]\n007. ∠O 1B 2B 1 = ∠O 1HB 1\n[ 3 3 ] & A, B 1 , B 2\nare\nc o l l i n e a r\n[ 3 0 ]\n( i08 )⇒\n∠\n41\n\n(AB 1−B 2O 1 ) = ∠B 1HO 1\n[ 3 4 ]\n008. ∠O 1B 2B 1 = ∠O 1HB 1\n[ 3 3 ] & A, B 1 , B 2\nare\nc o l l i n e a r\n[ 3 0 ]\n( i08 )⇒\n∠\nHO 1B 2 = ∠HB 1A\n[ 3 5 ]\n009. B, A 2 ,C are\nc o l l i n e a r\n[ 1 0 ] & B,C, A 1\nare\nc o l l i n e a r\n[ 0 8 ]\n( i04 )⇒\nB, A 1 , A 2\nare\nc o l l i n e a r\n[ 3 6 ]\n010. B, A 2 ,C are\nc o l l i n e a r\n[ 1 0 ] & B, A 2 , A 1\nare\nc o l l i n e a r\n[ 3 6 ]\n( i04 )⇒\nB, A 1 ,C, A 2\nare\nc o l l i n e a r\n[ 3 7 ]\n011. AH ⊥BC [ 0 0 ]\n()⇒\n∠(AH−BC) = ∠(BC−AH)\n[ 3 8 ]\n012. B, A 1 ,C are\nc o l l i n e a r\n[ 0 8 ]\n()⇒\nBC ∥A 1B\n[ 3 9 ]\n013. ∠(AH−BC) = ∠(BC−AH)\n[ 3 8 ] & BC ∥A 1B\n[ 3 9 ]\n( why perp repr )⇒\nAH ⊥\nA 1B\n[ 4 0 ]\n014. B, A 1 , A 2 ,C are\nc o l l i n e a r\n[ 3 7 ] & AH ⊥A 1B\n[ 4 0 ]\n( why perp resolution )⇒\nAH ⊥A 2C\n[ 4 1 ]\n015. O 1H ⊥EF [ 2 1 ] & AH ⊥A 2C\n[ 4 1 ]\n( r08 )⇒\n∠O 1HA = ∠(EF−A 2C)\n[ 4 2 ]\n016. ∠O 1HA = ∠(EF−A 2C)\n[ 4 2 ] & B, A 1 ,C, A 2\nare\nc o l l i n e a r\n[ 3 7 ]\n( i08 )⇒\n∠\n(EF−A 1B) = ∠O 1HA [ 4 3 ]\n017. F ,A,B are\nc o l l i n e a r\n[ 0 6 ] & FA = FB [ 0 7 ]\n( why midp resolution )⇒\nF\ni s\nmidpoint\nof AB [ 4 4 ]\n018. E,A,C are\nc o l l i n e a r\n[ 0 4 ] & EA = EC [ 0 5 ]\n( why midp resolution )⇒\nE\ni s\nmidpoint\nof AC [ 4 5 ]\n019. F i s\nmidpoint\nof AB [ 4 4 ] & E i s\nmidpoint\nof AC [ 4 5 ]\n( r06 )⇒\nFE ∥BC\n[ 4 6 ]\n020. FE ∥BC [ 4 6 ] & B, A 1 ,C are\nc o l l i n e a r\n[ 0 8 ]\n( i05 )⇒\nEF ∥A 1B\n[ 4 7 ]\n021. ∠(EF−A 1B) = ∠O 1HA [ 4 3 ] & EF ∥A 1B\n[ 4 7 ]\n( i03 )⇒\nHO 1 ∥AH [ 4 8 ]\n022. ∠(AB 1−B 2O 1 ) = ∠B 1HO 1\n[ 3 4 ] & HO 1 ∥AH [ 4 8 ]\n( why eqangle eqangle )⇒\n∠(AB 1−B 2O 1 ) = ∠B 1HA\n[ 4 9 ]\n023. A, B 2 , B 1\nare\nc o l l i n e a r\n[ 3 0 ] & ∠(AB 1−B 2O 1 ) = ∠B 1HA\n[ 4 9 ]\n( why eqangle6 resolution )⇒\n∠AB 2O 1 = ∠B 1HA\n[ 5 0 ]\n024. HA ∥HO 1\n[ 4 8 ]\n( r28 )⇒\nA,H, O 1 are\nc o l l i n e a r\n[ 5 1 ]\n025. ∠HO 1B 2 = ∠HB 1A\n[ 3 5 ] & HO 1 ∥AH [ 4 8 ]\n( why eqangle eqangle )⇒\n∠\n(AH−B 2O 1 ) = ∠HB 1A\n[ 5 2 ]\n026.\nO 1 ,H,A are\nc o l l i n e a r\n[ 5 1 ] & ∠(AH−B 2O 1 ) = ∠HB 1A\n[ 5 2 ]\n( why eqangle6 resolution )⇒\n∠AO 1B 2 = ∠HB 1A\n[ 5 3 ]\n027. ∠AB 2O 1 = ∠B 1HA\n[ 5 0 ] & ∠AO 1B 2 = ∠HB 1A\n[ 5 3 ]\n( Similar\nTriangles\n35)⇒\nAB 2 : AO 1 = AH: AB 1\n[ 5 4 ]\n028. O 2E = EH [ 2 2 ] & EB 1 = EH [ 1 3 ] & EB 2 = EH [ 1 5 ]\n( w h y c i r c l e r e s o l u t i o n )⇒\nE i s\nthe\ncircumcenter\nof\n\\ Delta\nB 1O 2B 2\n[ 5 5 ]\n029. O 2E = EH [ 2 2 ] & EB 1 = EH [ 1 3 ] & EB 2 = EH [ 1 5 ]\n( i01 )⇒\nB 2 , B 1 ,H, O 2 are\nc o n c y c l i c\n[ 5 6 ]\n030. A,C, B 2\nare\nc o l l i n e a r\n[ 1 4 ] & A,C, B 1\nare\nc o l l i n e a r\n[ 1 2 ] & A,C,E are\nc o l l i n e a r\n[ 0 4 ]\n( i04 )⇒\nA, B 1 , B 2 ,E are\nc o l l i n e a r\n[ 5 7 ]\n031. A, B 1 , B 2 ,E are\nc o l l i n e a r\n[ 5 7 ]\n( w h y c o l l r e s o l u t i o n )⇒\nE, B 1 , B 2\nare\nc o l l i n e a r\n[ 5 8 ]\n032. E i s\nthe\ncircumcenter\nof\n\\ Delta\nB 1O 2B 2\n[ 5 5 ] & E, B 1 , B 2\nare\nc o l l i n e a r\n[ 5 8 ]\n( r20 )⇒\nB 1O 2 ⊥B 2O 2\n[ 5 9 ]\n033.\nB 2 , B 1 ,H, O 2 are\nc o n c y c l i c\n[ 5 6 ]\n( r03 )⇒\n∠B 1HB 2 = ∠B 1O 2B 2\n[ 6 0 ]\n034.\nB 2 , B 1 ,H, O 2 are\nc o n c y c l i c\n[ 5 6 ]\n( r03 )⇒\n∠B 2HO 2 = ∠B 2B 1O 2\n[ 6 1 ]\n035. AH ⊥BC [ 0 0 ] & B 1O 2 ⊥B 2O 2\n[ 5 9 ] & ∠B 1HB 2 = ∠B 1O 2B 2\n[ 6 0 ]\n()⇒\n∠B 1HB 2 = ∠(BC−AH)\n[ 6 2 ]\n036. ∠B 1HB 2 = ∠(BC−AH)\n[ 6 2 ] & BC ∥A 1B\n[ 3 9 ]\n( why eqangle eqangle )⇒\n∠\nB 1HB 2 = ∠(A 1B−AH)\n[ 6 3 ]\n037. B, A 1 , A 2 ,C are\nc o l l i n e a r\n[ 3 7 ] & ∠B 1HB 2 = ∠(A 1B−AH)\n[ 6 3 ]\n42\n\n( why eqangle resolution )⇒\n∠B 1HB 2 = ∠(A 2C−AH)\n[ 6 4 ]\n038.\nB 1 , B 2 ,H, O 1 are\nc o n c y c l i c\n[ 3 2 ] & O 2 , B 1 , B 2 ,H are\nc o n c y c l i c\n[ 5 6 ]\n( w h y c y c l i c r e s o l u t i o n )⇒\nB 2 , B 1 , O 2 , O 1 are\nc o n c y c l i c\n[ 6 5 ]\n039.\nB 2 , B 1 , O 2 ,H are\nc o n c y c l i c\n[ 5 6 ] & B 2 , B 1 , O 2 , O 1 are\nc o n c y c l i c\n[ 6 5 ]\n( i11 )⇒\nB 1 , B 2 , O 2 , O 1 ,H are\nc o n c y c l i c\n[ 6 6 ]\n040.\nB 1 , B 2 , O 2 , O 1 ,H are\nc o n c y c l i c\n[ 6 6 ]\n( w h y c y c l i c r e s o l u t i o n )⇒\nO 1 , B 2 ,H, O 2 are\nc o n c y c l i c\n[ 6 7 ]\n041.\nB 1 , B 2 , O 2 , O 1 ,H are\nc o n c y c l i c\n[ 6 6 ]\n( w h y c y c l i c r e s o l u t i o n )⇒\nO 1 , O 2 ,H, B 1\nare\nc o n c y c l i c\n[ 6 8 ]\n042.\nO 1 , B 2 ,H, O 2 are\nc o n c y c l i c\n[ 6 7 ]\n( r03 )⇒\n∠HO 1O 2 = ∠HB 2O 2\n[ 6 9 ]\n043. ∠HB 2O 2 = ∠HO 1O 2\n[ 6 9 ] & HO 1 ∥AH [ 4 8 ]\n( why eqangle resolution )⇒\n∠HB 2O 2 = ∠(AH−O 1O 2 )\n[ 7 0 ]\n044. ∠B 1HB 2 = ∠(A 2C−AH)\n[ 6 4 ] & ∠HB 2O 2 = ∠(AH−O 1O 2 )\n[ 7 0 ]\n( r09 )⇒\n∠\n(HB 1−B 2O 2 ) = ∠(A 2C−O 1O 2 )\n[ 7 1 ]\n045. ∠(HB 1−B 2O 2 ) = ∠(A 2C−O 1O 2 )\n[ 7 1 ] & B, A 1 ,C, A 2\nare\nc o l l i n e a r\n[ 3 7 ]\n( i08 )⇒\n∠(B 1H−B 2O 2 ) = ∠(A 1B−O 1O 2 )\n[ 7 2 ]\n046. ∠(B 1H−B 2O 2 ) = ∠(A 1B−O 1O 2 )\n[ 7 2 ] & EF ∥A 1B\n[ 4 7 ]\n( i09 )⇒\n∠\n(B 1H−B 2O 2 ) = ∠(EF−O 1O 2 )\n[ 7 3 ]\n047. ∠B 1HB 2 = ∠B 1O 2B 2\n[ 6 0 ] & B 1O 2 ⊥B 2O 2\n[ 5 9 ]\n( why eqangle resolution )⇒\n∠B 2O 2B 1 = ∠B 1HB 2\n[ 7 4 ]\n048. EH = EB 2\n[ 1 5 ]\n( r13 )⇒\n∠EHB 2 = ∠HB 2E\n[ 7 5 ]\n049. ∠EHB 2 = ∠HB 2E\n[ 7 5 ] & A, B 1 , B 2 ,E are\nc o l l i n e a r\n[ 5 7 ]\n( i08 )⇒\n∠\nEHB 2 = ∠(B 2H−AB 1)\n[ 7 6 ]\n050. ∠B 2HO 2 = ∠B 2B 1O 2\n[ 6 1 ] & A, B 1 , B 2\nare\nc o l l i n e a r\n[ 3 0 ]\n( i08 )⇒\n∠\n(AB 1−B 2H) = ∠B 1O 2H\n[ 7 7 ]\n051. ∠B 2HE = ∠(AB 1−B 2H)\n[ 7 6 ] & ∠(AB 1−B 2H) = ∠B 1O 2H\n[ 7 7 ]\n( why eqangle resolution )⇒\n∠B 1O 2H = ∠B 2HE\n[ 7 8 ]\n052. ∠B 2O 2B 1 = ∠B 1HB 2\n[ 7 4 ] & ∠B 1O 2H = ∠B 2HE\n[ 7 8 ]\n( r09 )⇒\n∠\n( B 2O 2−B 1H) = ∠O 2HE\n[ 7 9 ]\n053. ∠(B 1H−B 2O 2 ) = ∠(EF−O 1O 2 )\n[ 7 3 ] & ∠(B 1H−B 2O 2 ) = ∠EHO 2\n[ 7 9 ]\n()⇒\n∠EHO 2 = ∠(EF−O 1O 2 )\n[ 8 0 ]\n054. FC 1 = FH [ 1 7 ] & FC 2 = FH [ 1 9 ]\n( why cong resolution )⇒\nC 2F = C 1F\n[ 8 1 ]\n055. C 2F = C 1F\n[ 8 1 ] & C 2O = C 1O\n[ 2 6 ]\n( r23 )⇒\nC 2C 1 ⊥FO [ 8 2 ]\n056. D,C,B are\nc o l l i n e a r\n[ 0 2 ] & DB = DC [ 0 3 ]\n( why midp resolution )⇒\nD\ni s\nmidpoint\nof CB [ 8 3 ]\n057. D i s\nmidpoint\nof CB [ 8 3 ] & E i s\nmidpoint\nof CA [ 4 5 ]\n( r06 )⇒\nDE ∥AB\n[ 8 4 ]\n058.\nC 1 ,B,A, C 2\nare\nc o l l i n e a r\n[ 3 1 ] & DE ∥AB [ 8 4 ]\n( why para resolution )⇒\nC 2C 1 ∥DE [ 8 5 ]\n059.\nC 2C 1 ⊥FO [ 8 2 ] & DE ⊥HO 2\n[ 2 3 ] & C 2C 1 ∥DE [ 8 5 ]\n( i00 )⇒\nFO ∥\nHO 2\n[ 8 6 ]\n060. ∠EHO 2 = ∠(EF−O 1O 2 )\n[ 8 0 ] & HO 2 ∥FO [ 8 6 ] & EF ∥A 1B\n[ 4 7 ]\n( why eqangle eqangle )⇒\n∠(EH−FO) = ∠(A 1B−O 1O 2 )\n[ 8 7 ]\n061. B, A 1 , A 2 ,C are\nc o l l i n e a r\n[ 3 7 ] & ∠(EH−FO) = ∠(A 1B−O 1O 2 )\n[ 8 7 ]\n( why eqangle resolution )⇒\n∠(EH−FO) = ∠(A 2C−O 1O 2 )\n[ 8 8 ]\n062.\nO 1 , O 2 , B 2 , B 1\nare\nc o n c y c l i c\n[ 6 5 ]\n( r03 )⇒\n∠B 2O 1B 1 = ∠B 2O 2B 1\n[ 8 9 ]\n063.\nO 1 , O 2 , B 2 , B 1\nare\nc o n c y c l i c\n[ 6 5 ]\n( r03 )⇒\n∠O 1B 1B 2 = ∠O 1O 2B 2\n[ 9 0 ]\n064. ∠B 2O 1B 1 = ∠B 2O 2B 1\n[ 8 9 ] & B 1O 2 ⊥B 2O 2\n[ 5 9 ]\n( why eqangle resolution )⇒\n∠B 1O 2B 2 = ∠B 2O 1B 1\n[ 9 1 ]\n065. EB 1 = EH [ 1 3 ] & O 1E = EH [ 2 0 ]\n( why cong resolution )⇒\nEO 1 = EB 1\n43\n\n[ 9 2 ]\n066. EO 1 = EB 1\n[ 9 2 ]\n( r13 )⇒\n∠EO 1B 1 = ∠O 1B 1E\n[ 9 3 ]\n067. A,C, B 1\nare\nc o l l i n e a r\n[ 1 2 ] & A,C,E are\nc o l l i n e a r\n[ 0 4 ]\n( i04 )⇒\nA, B 1 ,E are\nc o l l i n e a r\n[ 9 4 ]\n068. ∠EO 1B 1 = ∠O 1B 1E\n[ 9 3 ] & A, B 1 ,E are\nc o l l i n e a r\n[ 9 4 ]\n( i08 )⇒\n∠\nEO 1B 1 = ∠O 1B 1A\n[ 9 5 ]\n069. ∠O 1B 1B 2 = ∠O 1O 2B 2\n[ 9 0 ] & A, B 1 , B 2\nare\nc o l l i n e a r\n[ 3 0 ]\n( i08 )⇒\n∠AB 1O 1 = ∠B 2O 2O 1\n[ 9 6 ]\n070. ∠B 1O 1E = ∠AB 1O 1\n[ 9 5 ] & ∠AB 1O 1 = ∠B 2O 2O 1\n[ 9 6 ]\n( why eqangle resolution )⇒\n∠B 2O 2O 1 = ∠B 1O 1E\n[ 9 7 ]\n071. ∠B 1O 2B 2 = ∠B 2O 1B 1\n[ 9 1 ] & ∠B 2O 2O 1 = ∠B 1O 1E\n[ 9 7 ]\n( r09 )⇒\n∠\n( B 1O 2−B 2O 1 ) = ∠O 2O 1E\n[ 9 8 ]\n072. AH ⊥BC [ 0 0 ] & B 1O 2 ⊥B 2O 2\n[ 5 9 ] & ∠B 2O 1B 1 = ∠B 2O 2B 1\n[ 8 9 ]\n()⇒\n∠B 2O 1B 1 = ∠(BC−AH)\n[ 9 9 ]\n073. ∠B 2O 1B 1 = ∠(BC−AH)\n[ 9 9 ] & BC ∥A 1B\n[ 3 9 ]\n( why eqangle eqangle )⇒\n∠B 2O 1B 1 = ∠(A 1B−AH)\n[ 1 0 0 ]\n074. B, A 1 , A 2 ,C are\nc o l l i n e a r\n[ 3 7 ] & ∠B 2O 1B 1 = ∠(A 1B−AH)\n[ 1 0 0 ]\n( why eqangle resolution )⇒\n∠B 2O 1B 1 = ∠(A 2C−AH)\n[ 1 0 1 ]\n075.\nO 1 , O 2 ,H, B 1\nare\nc o n c y c l i c\n[ 6 8 ]\n( r03 )⇒\n∠O 1HO 2 = ∠O 1B 1O 2\n[ 1 0 2 ]\n076. ∠O 1B 1O 2 = ∠O 1HO 2\n[ 1 0 2 ] & HO 1 ∥AH [ 4 8 ]\n( why eqangle resolution )⇒\n∠O 1B 1O 2 = ∠AHO 2 [ 1 0 3 ]\n077. ∠B 2O 1B 1 = ∠(A 2C−AH)\n[ 1 0 1 ] & ∠O 1B 1O 2 = ∠AHO 2 [ 1 0 3 ]\n( r09 )⇒\n∠\n( O 1B 2−B 1O 2 ) = ∠(A 2C−HO 2)\n[ 1 0 4 ]\n078. ∠( O 1B 2−B 1O 2 ) = ∠(A 2C−HO 2)\n[ 1 0 4 ] & B, A 1 ,C, A 2\nare\nc o l l i n e a r\n[ 3 7 ]\n( i08 )⇒\n∠( B 2O 1−B 1O 2 ) = ∠(A 1B−HO 2)\n[ 1 0 5 ]\n079. ∠( B 2O 1−B 1O 2 ) = ∠(A 1B−HO 2)\n[ 1 0 5 ] & EF ∥A 1B\n[ 4 7 ] & FO ∥HO 2\n[ 8 6 ]\n( i09 )⇒\n∠( B 1O 2−B 2O 1 ) = ∠(HO 2−EF)\n[ 1 0 6 ]\n080. ∠( B 1O 2−B 2O 1 ) = ∠O 2O 1E\n[ 9 8 ] & ∠( B 1O 2−B 2O 1 ) = ∠(HO 2−EF)\n[ 1 0 6 ]\n()⇒\n∠(HO 2−EF) = ∠O 2O 1E\n[ 1 0 7 ]\n081. ∠(HO 2−EF) = ∠O 2O 1E\n[ 1 0 7 ] & HO 2 ∥FO [ 8 6 ] & EF ∥A 1B\n[ 4 7 ]\n( why eqangle eqangle )⇒\n∠(FO−A 1B) = ∠O 2O 1E\n[ 1 0 8 ]\n082. B, A 1 , A 2 ,C are\nc o l l i n e a r\n[ 3 7 ] & ∠(FO−A 1B) = ∠O 2O 1E\n[ 1 0 8 ]\n( why eqangle resolution )⇒\n∠(FO−A 2C) = ∠O 2O 1E\n[ 1 0 9 ]\n083. ∠(EH−FO) = ∠(A 2C−O 1O 2 )\n[ 8 8 ] & ∠(FO−A 2C) = ∠O 2O 1E\n[ 1 0 9 ]\n( r09 )⇒\n∠(EH−A 2C) = ∠(A 2C−EO 1)\n[ 1 1 0 ]\n084. ∠(EH−A 2C) = ∠(A 2C−EO 1)\n[ 1 1 0 ] & B, A 1 ,C, A 2\nare\nc o l l i n e a r\n[ 3 7 ]\n( i08 )⇒\n∠(EH−A 1B) = ∠(A 1B−EO 1)\n[ 1 1 1 ]\n085. ∠(EH−A 1B) = ∠(A 1B−EO 1)\n[ 1 1 1 ] & EF ∥A 1B\n[ 4 7 ]\n( i09 )⇒\n∠HEF = ∠\nFEO 1\n[ 1 1 2 ]\n086. HE = O 1E\n[ 2 0 ] & ∠HEF = ∠FEO 1\n[ 1 1 2 ]\n(SAS 33)⇒\nFH = FO 1\n[ 1 1 3 ]\n087. FC 2 = FH [ 1 9 ] & O 3F = FH [ 2 4 ] & FH = FO 1\n[ 1 1 3 ]\n( i01 )⇒\nC 2 , O 1 ,H, O 3 are\nc o n c y c l i c\n[ 1 1 4 ]\n088. FC 1 = FH [ 1 7 ] & O 3F = FH [ 2 4 ] & FC 2 = FH [ 1 9 ]\n( i01 )⇒\nC 2 ,H, O 3 , C 1\nare\nc o n c y c l i c\n[ 1 1 5 ]\n089. FC 1 = FH [ 1 7 ] & O 3F = FH [ 2 4 ] & FC 2 = FH [ 1 9 ]\n( w h y c i r c l e r e s o l u t i o n )⇒\nF i s\nthe\ncircumcenter\nof\n\\ Delta\nC 2O 3C 1\n[ 1 1 6 ]\n090.\nC 2 , O 1 ,H, O 3 are\nc o n c y c l i c\n[ 1 1 4 ] & C 2 ,H, O 3 , C 1\nare\nc o n c y c l i c\n[ 1 1 5 ]\n( i11 )⇒\nO 1 , C 1 , C 2 ,H are\nc o n c y c l i c\n[ 1 1 7 ]\n091.\nO 1 , C 1 , C 2 ,H are\nc o n c y c l i c\n[ 1 1 7 ]\n( r03 )⇒\n∠O 1C 2C 1 = ∠O 1HC 1\n[ 1 1 8 ]\n092. ∠O 1C 2C 1 = ∠O 1HC 1\n[ 1 1 8 ] & B,A, C 2 , C 1\nare\nc o l l i n e a r\n[ 3 1 ] &\nA,H, O 1 are\nc o l l i n e a r\n[ 5 1 ]\n( i08 )⇒\n∠( C 2O 1−AB) = ∠AHC 1 [ 1 1 9 ]\n44\n\n093. ∠O 1C 2C 1 = ∠O 1HC 1\n[ 1 1 8 ] & B,A, C 2 , C 1\nare\nc o l l i n e a r\n[ 3 1 ] &\nA,H, O 1 are\nc o l l i n e a r\n[ 5 1 ]\n( i08 )⇒\n∠( C 2O 1−AH) = ∠(AB−C 1H)\n[ 1 2 0 ]\n094. B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ] & ∠AHC 1 = ∠( C 2O 1−AB)\n[ 1 1 9 ]\n( why eqangle6 resolution )⇒\n∠AHC 1 = ∠O 1C 2A\n[ 1 2 1 ]\n095.\nC 1 ,A,B are\nc o l l i n e a r\n[ 1 6 ] & O 1 ,H,A are\nc o l l i n e a r\n[ 5 1 ] & ∠\n(AB−C 1H) = ∠( C 2O 1−AH)\n[ 1 2 0 ]\n( why eqangle6 resolution )⇒\n∠AC 1H = ∠\nC 2O 1A\n[ 1 2 2 ]\n096. ∠AHC 1 = ∠O 1C 2A\n[ 1 2 1 ] & ∠AC 1H = ∠C 2O 1A\n[ 1 2 2 ]\n( Similar\nTriangles\n35)⇒\nAH: AC 1 = AC 2 : AO 1\n[ 1 2 3 ]\n097. OC 1 = OC 2\n[ 2 6 ]\n( r13 )⇒\n∠OC 1C 2 = ∠C 1C 2O\n[ 1 2 4 ]\n098. ∠OC 1C 2 = ∠C 1C 2O\n[ 1 2 4 ] & B,A, C 2 , C 1\nare\nc o l l i n e a r\n[ 3 1 ]\n( i08 )⇒\n∠\n(C 1O−AB) = ∠(AB−C 2O)\n[ 1 2 5 ]\n099.\nC 1 ,A,B are\nc o l l i n e a r\n[ 1 6 ] & B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ] & ∠\n(C 1O−AB) = ∠(AB−C 2O)\n[ 1 2 5 ]\n( why eqangle6 resolution )⇒\n∠OC 1A = ∠\nBC 2O [ 1 2 6 ]\n100. HO 2 ⊥DE [ 2 3 ]\n()⇒\n∠(DE−HO 2) = ∠(HO 2−DE)\n[ 1 2 7 ]\n101. ∠(DE−HO 2) = ∠(HO 2−DE)\n[ 1 2 7 ] & DE ∥AB [ 8 4 ] & HO 2 ∥FO [ 8 6 ]\n( why eqangle eqangle )⇒\n∠(AB−FO) = ∠(FO−AB)\n[ 1 2 8 ]\n102. A,F,B are\nc o l l i n e a r\n[ 0 6 ] & ∠(AB−FO) = ∠(FO−AB)\n[ 1 2 8 ]\n( why eqangle6 resolution )⇒\n∠BFO = ∠OFA [ 1 2 9 ]\n103. BF = AF [ 0 7 ] & ∠BFO = ∠OFA [ 1 2 9 ]\n(SAS 33)⇒\n∠FBO = ∠OAF [ 1 3 0 ]\n104. ∠FBO = ∠OAF [ 1 3 0 ] & B,A, F are\nc o l l i n e a r\n[ 0 6 ]\n( i08 )⇒\n∠ABO = ∠OAB\n[ 1 3 1 ]\n105.\nC 1 ,A,B are\nc o l l i n e a r\n[ 1 6 ] & C 2 ,A,B are\nc o l l i n e a r\n[ 1 8 ] & ∠OAB = ∠\nABO [ 1 3 1 ]\n( why eqangle6 resolution )⇒\n∠OAC 1 = ∠C 2BO [ 1 3 2 ]\n106. ∠OC 1A = ∠BC 2O [ 1 2 6 ] & ∠OAC 1 = ∠C 2BO [ 1 3 2 ]\n( Similar\nTriangles\n35)⇒\nC 1O : C 2O = C 1A : C 2B\n[ 1 3 3 ]\n107. C 1O : C 2O = C 1A : C 2B\n[ 1 3 3 ] & C 1O = C 2O\n[ 2 6 ]\n( i02 )⇒\nC 1A = C 2B\n[ 1 3 4 ]\n108. AH: AC 1 = AC 2 : AO 1\n[ 1 2 3 ] & C 1A = C 2B\n[ 1 3 4 ]\n( i10 )⇒\nAH: C 2B =\nAC 2 : AO 1\n[ 1 3 5 ]\n109. AB 2 : AO 1 = AH: AB 1\n[ 5 4 ] & AH: C 2B = AC 2 : AO 1\n[ 1 3 5 ]\n( Ratio\nchase )⇒\nAB 1 : C 2B = AC 2 : AB 2\n[ 1 3 6 ]\n110. AC 2 : AB 2 = AB 1 : C 2B\n[ 1 3 6 ] & C 1A = C 2B\n[ 1 3 4 ]\n( w h y e q r a t i o 6 r e s o l u t i o n )⇒\nAC 2 : AB 2 = AB 1 : AC 1\n[ 1 3 7 ]\n111. F i s\nmidpoint\nof BA [ 4 4 ] & D i s\nmidpoint\nof BC [ 8 3 ]\n( r06 )⇒\nFD ∥AC\n[ 1 3 8 ]\n112. FD ∥AC [ 1 3 8 ] & A, B 1 ,C are\nc o l l i n e a r\n[ 1 2 ]\n( i05 )⇒\nDF ∥AB 1\n[ 1 3 9 ]\n113. DE ∥AB [ 8 4 ] & DF ∥AB 1\n[ 1 3 9 ]\n( why eqangle eqangle )⇒\n∠BAB 1 = ∠\nBAB 1 [ 1 4 0 ]\n114. B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ] & A, B 2 , B 1\nare\nc o l l i n e a r\n[ 3 0 ] & C 1 ,A,B\nare\nc o l l i n e a r\n[ 1 6 ] & ∠BAB 1 = ∠BAB 1 [ 1 4 0 ]\n( why eqangle6 resolution )⇒\n∠C 2AB 2 = ∠C 1AB 1\n[ 1 4 1 ]\n115. AC 2 : AB 2 = AB 1 : AC 1\n[ 1 3 7 ] & ∠C 2AB 2 = ∠C 1AB 1\n[ 1 4 1 ]\n( Similar\nTriangles\n39)⇒\n∠AC 2B 2 = ∠C 1B 1A\n[ 1 4 2 ]\n116. ∠AC 2B 2 = ∠C 1B 1A\n[ 1 4 2 ] & B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ]\n( i08 )⇒\n∠\n(AB−B 2C 2 ) = ∠C 1B 1A\n[ 1 4 3 ]\n117. A, B 2 , B 1\nare\nc o l l i n e a r\n[ 3 0 ] & C 1 ,B,A, C 2\nare\nc o l l i n e a r\n[ 3 1 ] & ∠\nC 1B 1A = ∠(AB−B 2C 2 )\n[ 1 4 3 ]\n( why eqangle6 resolution )⇒\n∠C 1B 1B 2 =\n∠C 1C 2B 2\n[ 1 4 4 ]\n118. ∠C 1B 1B 2 = ∠C 1C 2B 2\n[ 1 4 4 ]\n( r04 )⇒\nC 1 , B 1 , C 2 , B 2\nare\nc o n c y c l i c\n[ 1 4 5 ]\n119. O i s\nthe\ncircumcenter\nof\n\\ Delta\nC 1B 1C 2\n[ 2 9 ] & C 1 , B 1 , C 2 , B 2\n45\n\nare\nc o n c y c l i c\n[ 1 4 5 ]\n( r49 )⇒\nOC 1 = OB 2\n[ 1 4 6 ]\n120. O i s\nthe\ncircumcenter\nof\n\\ Delta\nC 1B 1C 2\n[ 2 9 ] & C 1 , B 1 , C 2 , B 2\nare\nc o n c y c l i c\n[ 1 4 5 ]\n( r49 )⇒\nB 1O = B 2O\n[ 1 4 7 ]\n121.\nC 1 , O 3 ,H, C 2\nare\nc o n c y c l i c\n[ 1 1 5 ]\n( r03 )⇒\n∠C 1HO 3 = ∠C 1C 2O 3\n[ 1 4 8 ]\n122.\nC 1 , O 3 ,H, C 2\nare\nc o n c y c l i c\n[ 1 1 5 ]\n( r03 )⇒\n∠C 1C 2H = ∠C 1O 3H\n[ 1 4 9 ]\n123.\nC 1 , O 3 ,H, C 2\nare\nc o n c y c l i c\n[ 1 1 5 ]\n( r03 )⇒\n∠C 2HC 1 = ∠C 2O 3C 1\n[ 1 5 0 ]\n124. ∠C 1HO 3 = ∠C 1C 2O 3\n[ 1 4 8 ] & B,A, C 2 , C 1\nare\nc o l l i n e a r\n[ 3 1 ]\n( i08 )⇒\n∠O 3HC 1 = ∠( C 2O 3−AB)\n[ 1 5 1 ]\n125. ∠C 1HO 3 = ∠C 1C 2O 3\n[ 1 4 8 ] & B,A, C 2 , C 1\nare\nc o l l i n e a r\n[ 3 1 ]\n( i08 )⇒\n∠(AB−C 1H) = ∠C 2O 3H\n[ 1 5 2 ]\n126. BH ⊥AC [ 0 1 ]\n()⇒\n∠(BH−AC) = ∠(AC−BH)\n[ 1 5 3 ]\n127. A, B 1 ,C are\nc o l l i n e a r\n[ 1 2 ]\n()⇒\nAC ∥AB 1\n[ 1 5 4 ]\n128. ∠(BH−AC) = ∠(AC−BH)\n[ 1 5 3 ] & AC ∥AB 1\n[ 1 5 4 ]\n( why perp repr )⇒\nBH ⊥\nAB 1\n[ 1 5 5 ]\n129. E,A, B 1\nare\nc o l l i n e a r\n[ 9 4 ] & BH ⊥AB 1\n[ 1 5 5 ]\n( why perp resolution )⇒\nHB ⊥EA [ 1 5 6 ]\n130. HB ⊥EA [ 1 5 6 ] & HO 3 ⊥DF [ 2 5 ]\n( r08 )⇒\n∠BHO 3 = ∠(EA−DF)\n[ 1 5 7 ]\n131. HB ⊥EA [ 1 5 6 ] & HO 3 ⊥DF [ 2 5 ]\n( r08 )⇒\n∠(DF−HB) = ∠(HO 3−EA)\n[ 1 5 8 ]\n132. ∠BHO 3 = ∠(EA−DF)\n[ 1 5 7 ] & A, B 1 ,E are\nc o l l i n e a r\n[ 9 4 ]\n( i08 )⇒\n∠\n(AB 1−DF) = ∠BHO 3 [ 1 5 9 ]\n133. ∠(AB 1−DF) = ∠BHO 3 [ 1 5 9 ] & AB 1 ∥DF [ 1 3 9 ]\n( i03 )⇒\nBH ∥HO 3\n[ 1 6 0 ]\n134. ∠( C 2O 3−AB) = ∠O 3HC 1\n[ 1 5 1 ] & HO 3 ∥BH [ 1 6 0 ]\n( why eqangle eqangle )⇒\n∠( C 2O 3−AB) = ∠BHC 1 [ 1 6 1 ]\n135. B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ] & ∠( C 2O 3−AB) = ∠BHC 1 [ 1 6 1 ]\n( why eqangle6 resolution )⇒\n∠O 3C 2B = ∠BHC 1 [ 1 6 2 ]\n136. HO 3 ∥HB [ 1 6 0 ]\n( r28 )⇒\nO 3 ,H,B are\nc o l l i n e a r\n[ 1 6 3 ]\n137. DE ∥AB [ 8 4 ]\n( why eqangle eqangle )⇒\n∠HBA = ∠HBA [ 1 6 4 ]\n138.\nO 3 ,H,B are\nc o l l i n e a r\n[ 1 6 3 ] & C 2 ,A,B are\nc o l l i n e a r\n[ 1 8 ] & C 1 ,A,B\nare\nc o l l i n e a r\n[ 1 6 ] & ∠HBA = ∠HBA [ 1 6 4 ]\n( why eqangle6 resolution )⇒\n∠\nO 3BC 2 = ∠HBC 1 [ 1 6 5 ]\n139. ∠O 3C 2B = ∠BHC 1 [ 1 6 2 ] & ∠O 3BC 2 = ∠HBC 1 [ 1 6 5 ]\n( Similar\nTriangles\n35)⇒\nO 3C 2 : O 3B = C 1H : C 1B\n[ 1 6 6 ]\n140. ∠O 3C 2B = ∠BHC 1 [ 1 6 2 ] & ∠O 3BC 2 = ∠HBC 1 [ 1 6 5 ]\n( Similar\nTriangles\n35)⇒\nO 3C 2 : C 2B = C 1H :HB [ 1 6 7 ]\n141.\nC 1 ,A,B are\nc o l l i n e a r\n[ 1 6 ] & B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ] & ∠\n(C 1O−AB) = ∠(AB−C 2O)\n[ 1 2 5 ]\n( why eqangle6 resolution )⇒\n∠OC 1B = ∠\nAC 2O [ 1 6 8 ]\n142.\nC 1 ,A,B are\nc o l l i n e a r\n[ 1 6 ] & B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ] & ∠OBA = ∠\nBAO [ 1 3 1 ]\n( why eqangle6 resolution )⇒\n∠OBC 1 = ∠C 2AO [ 1 6 9 ]\n143. ∠OC 1B = ∠AC 2O [ 1 6 8 ] & ∠OBC 1 = ∠C 2AO [ 1 6 9 ]\n( Similar\nTriangles\n35)⇒\nC 1O : C 2O = C 1B : C 2A\n[ 1 7 0 ]\n144. C 1O : C 2O = C 1B : C 2A\n[ 1 7 0 ] & C 1O = C 2O\n[ 2 6 ]\n( i02 )⇒\nC 1B = C 2A\n[ 1 7 1 ]\n145.\nO 3C 2 : O 3B = C 1H : C 1B\n[ 1 6 6 ] & C 1B = C 2A\n[ 1 7 1 ]\n( i10 )⇒\nO 3C 2 : O 3B = C 1H : AC 2\n[ 1 7 2 ]\n146. B,A, C 1\nare\nc o l l i n e a r\n[ 1 6 ] & B,A, F are\nc o l l i n e a r\n[ 0 6 ]\n( i04 )⇒\nB,A,F, C 1\nare\nc o l l i n e a r\n[ 1 7 3 ]\n147. B,A,F, C 1\nare\nc o l l i n e a r\n[ 1 7 3 ] & B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ]\n( w h y c o l l r e s o l u t i o n )⇒\nF, C 2 , C 1\nare\nc o l l i n e a r\n[ 1 7 4 ]\n148. F i s\nthe\ncircumcenter\nof\n\\ Delta\nC 2O 3C 1\n[ 1 1 6 ] & F , C 2 , C 1\nare\nc o l l i n e a r\n[ 1 7 4 ]\n( r20 )⇒\nC 2O 3 ⊥C 1O 3\n[ 1 7 5 ]\n46\n\n149.\nC 2O 3 ⊥C 1O 3\n[ 1 7 5 ] & HO 3 ⊥DF [ 2 5 ]\n( why eqangle resolution )⇒\n∠\n(DF−HO 3) = ∠C 2O 3C 1\n[ 1 7 6 ]\n150.\nC 2O 3 ⊥C 1O 3\n[ 1 7 5 ] & HO 3 ⊥DF [ 2 5 ]\n( r08 )⇒\n∠(DF−C 2O 3 ) = ∠\nHO 3C 1\n[ 1 7 7 ]\n151. ∠C 1C 2H = ∠C 1O 3H\n[ 1 4 9 ] & B,A, C 2 , C 1\nare\nc o l l i n e a r\n[ 3 1 ]\n( i08 )⇒\n∠\n( C 1O 3−AB) = ∠O 3HC 2\n[ 1 7 8 ]\n152. A,F,B are\nc o l l i n e a r\n[ 0 6 ] & ∠O 3HC 2 = ∠( C 1O 3−AB)\n[ 1 7 8 ]\n( why eqangle resolution )⇒\n∠O 3HC 2 = ∠( C 1O 3−AF)\n[ 1 7 9 ]\n153. ∠(DF−HO 3) = ∠C 2O 3C 1\n[ 1 7 6 ] & ∠O 3HC 2 = ∠( C 1O 3−AF)\n[ 1 7 9 ]\n( r09 )⇒\n∠(DF−HC 2) = ∠( O 3C 2−AF)\n[ 1 8 0 ]\n154. ∠(DF−HC 2) = ∠( O 3C 2−AF)\n[ 1 8 0 ] & B,A, F are\nc o l l i n e a r\n[ 0 6 ]\n( i08 )⇒\n∠\n(DF−C 2H) = ∠( C 2O 3−AB)\n[ 1 8 1 ]\n155. O 3F = FH [ 2 4 ] & FC 2 = FH [ 1 9 ]\n( why cong resolution )⇒\nFC 2 = FO 3\n[ 1 8 2 ]\n156. FC 2 = FO 3\n[ 1 8 2 ]\n( r13 )⇒\n∠FC 2O 3 = ∠C 2O 3F\n[ 1 8 3 ]\n157. B,A, C 2\nare\nc o l l i n e a r\n[ 1 8 ] & B,A, F are\nc o l l i n e a r\n[ 0 6 ]\n( i04 )⇒\nB,A,F, C 2\nare\nc o l l i n e a r\n[ 1 8 4 ]\n158. ∠FC 2O 3 = ∠C 2O 3F\n[ 1 8 3 ] & B,A, F , C 2\nare\nc o l l i n e a r\n[ 1 8 4 ]\n( i08 )⇒\n∠\n(AB−C 2O 3 ) = ∠C 2O 3F\n[ 1 8 5 ]\n159. ∠(DF−C 2H) = ∠( C 2O 3−AB)\n[ 1 8 1 ] & ∠( C 2O 3−AB) = ∠FO 3C 2\n[ 1 8 5 ]\n( why eqangle resolution )⇒\n∠FO 3C 2 = ∠(DF−HC 2)\n[ 1 8 6 ]\n160.\nC 2O 3 ⊥C 1O 3\n[ 1 7 5 ] & ∠C 2HC 1 = ∠C 2O 3C 1\n[ 1 5 0 ]\n( why eqangle resolution )⇒\n∠C 2HC 1 = ∠C 1O 3C 2\n[ 1 8 7 ]\n161. FC 1 = FH [ 1 7 ]\n( r13 )⇒\n∠FC 1H = ∠C 1HF\n[ 1 8 8 ]\n162. ∠FC 1H = ∠C 1HF\n[ 1 8 8 ] & B,A,F , C 1\nare\nc o l l i n e a r\n[ 1 7 3 ]\n( i08 )⇒\n∠\n(AB−C 1H) = ∠C 1HF\n[ 1 8 9 ]\n163. ∠(AB−C 1H) = ∠C 2O 3H\n[ 1 5 2 ] & ∠(AB−C 1H) = ∠C 1HF\n[ 1 8 9 ]\n( why eqangle resolution )⇒\n∠C 1HF = ∠C 2O 3H\n[ 1 9 0 ]\n164. ∠C 2HC 1 = ∠C 1O 3C 2\n[ 1 8 7 ] & ∠C 1HF = ∠C 2O 3H\n[ 1 9 0 ]\n( r09 )⇒\n∠\nC 2HF = ∠C 1O 3H\n[ 1 9 1 ]\n165. ∠C 2HF = ∠C 1O 3H\n[ 1 9 1 ] & ∠( C 2O 3−DF) = ∠C 1O 3H\n[ 1 7 7 ]\n( why eqangle resolution )⇒\n∠( O 3C 2−DF) = ∠C 2HF\n[ 1 9 2 ]\n166. ∠FO 3C 2 = ∠(DF−HC 2)\n[ 1 8 6 ] & ∠( O 3C 2−DF) = ∠C 2HF\n[ 1 9 2 ]\n( r09 )⇒\n∠\nO 3FD = ∠DFH [ 1 9 3 ]\n167. O 3F = HF [ 2 4 ] & ∠O 3FD = ∠DFH [ 1 9 3 ]\n(SAS 33)⇒\nDO 3 = DH [ 1 9 4 ]\n168. DA 1 = DH [ 0 9 ] & DO 3 = DH [ 1 9 4 ] & DA 2 = DH [ 1 1 ]\n( i01 )⇒\nA 2 ,H, O 3 , A 1\nare\nc o n c y c l i c\n[ 1 9 5 ]\n169.\nA 2 ,H, O 3 , A 1\nare\nc o n c y c l i c\n[ 1 9 5 ]\n( r03 )⇒\n∠A 2O 3H = ∠A 2A 1H\n[ 1 9 6 ]\n170. ∠A 2O 3H = ∠A 2A 1H\n[ 1 9 6 ] & O 3 ,H,B are\nc o l l i n e a r\n[ 1 6 3 ] & B, A 1 , A 2\nare\nc o l l i n e a r\n[ 3 6 ]\n( i08 )⇒\n∠( A 2O 3−BH) = ∠BA 1H [ 1 9 7 ]\n171. ∠A 2O 3H = ∠A 2A 1H\n[ 1 9 6 ] & O 3 ,H,B are\nc o l l i n e a r\n[ 1 6 3 ] & B, A 1 , A 2\nare\nc o l l i n e a r\n[ 3 6 ]\n( i08 )⇒\n∠( A 2O 3−A 1B) = ∠BHA 1 [ 1 9 8 ]\n172. B,H, O 3 are\nc o l l i n e a r\n[ 1 6 3 ] & ∠(BH−A 2O 3 ) = ∠HA 1B [ 1 9 7 ]\n( why eqangle6 resolution )⇒\n∠BO 3A 2 = ∠HA 1B [ 1 9 9 ]\n173.\nA 1 , A 2 ,B are\nc o l l i n e a r\n[ 3 6 ] & ∠(A 1B−A 2O 3 ) = ∠A 1HB [ 1 9 8 ]\n( why eqangle6 resolution )⇒\n∠BA 2O 3 = ∠A 1HB [ 2 0 0 ]\n174. ∠BO 3A 2 = ∠HA 1B [ 1 9 9 ] & ∠BA 2O 3 = ∠A 1HB [ 2 0 0 ]\n( Similar\nTriangles\n35)⇒\nO 3B : A 2B = A 1B :HB [ 2 0 1 ]\n175.\nO 3C 2 : O 3B = C 1H : AC 2\n[ 1 7 2 ] & O 3C 2 : C 2B = C 1H :HB [ 1 6 7 ] &\nO 3B : A 2B = A 1B :HB [ 2 0 1 ]\n( Ratio\nchase )⇒\nAC 2 : A 2B = A 1B : C 2B\n[ 2 0 2 ]\n176. AC 2 : A 2B = A 1B : C 2B\n[ 2 0 2 ] & C 1B = AC 2\n[ 1 7 1 ]\n( w h y e q r a t i o 6 r e s o l u t i o n )⇒\nBC 1 : BA 2 = BA 1 : BC 2\n[ 2 0 3 ]\n177. DE ∥AB [ 8 4 ] & EF ∥A 1B\n[ 4 7 ]\n( why eqangle eqangle )⇒\n∠ABA 1 = ∠\n47\n\nABA 1 [ 2 0 4 ]\n178.\nC 1 ,A,B are\nc o l l i n e a r\n[ 1 6 ] & A 1 , A 2 ,B are\nc o l l i n e a r\n[ 3 6 ] & C 2 ,A,B\nare\nc o l l i n e a r\n[ 1 8 ] & ∠ABA 1 = ∠ABA 1 [ 2 0 4 ]\n( why eqangle6 resolution )⇒\n∠C 1BA 2 = ∠C 2BA 1\n[ 2 0 5 ]\n179. BC 1 : BA 2 = BA 1 : BC 2\n[ 2 0 3 ] & ∠C 1BA 2 = ∠C 2BA 1\n[ 2 0 5 ]\n( Similar\nTriangles\n39)⇒\n∠BC 1A 2 = ∠C 2A 1B\n[ 2 0 6 ]\n180. ∠BC 1A 2 = ∠C 2A 1B\n[ 2 0 6 ] & B,A, C 1\nare\nc o l l i n e a r\n[ 1 6 ]\n( i08 )⇒\n∠\n(AB−A 2C 1 ) = ∠C 2A 1B\n[ 2 0 7 ]\n181.\nC 1 ,B,A, C 2\nare\nc o l l i n e a r\n[ 3 1 ] & A 1 ,B, A 2\nare\nc o l l i n e a r\n[ 3 6 ] & ∠\n(AB−A 2C 1 ) = ∠C 2A 1B\n[ 2 0 7 ]\n( why eqangle6 resolution )⇒\n∠C 2C 1A 2 =\n∠C 2A 1A 2\n[ 2 0 8 ]\n182. ∠C 2C 1A 2 = ∠C 2A 1A 2\n[ 2 0 8 ]\n( r04 )⇒\nC 1 , C 2 , A 1 , A 2\nare\nc o n c y c l i c\n[ 2 0 9 ]\n183. B,C,D are\nc o l l i n e a r\n[ 0 2 ] & B, A 1 ,C are\nc o l l i n e a r\n[ 0 8 ]\n( w h y c o l l r e s o l u t i o n )⇒\nB, A 1 ,D are\nc o l l i n e a r\n[ 2 1 0 ]\n184. B, A 1 , A 2\nare\nc o l l i n e a r\n[ 3 6 ] & B, A 1 ,D are\nc o l l i n e a r\n[ 2 1 0 ]\n( w h y c o l l r e s o l u t i o n )⇒\nB, A 2 ,D are\nc o l l i n e a r\n[ 2 1 1 ]\n185. B, A 2 ,C are\nc o l l i n e a r\n[ 1 0 ] & B, A 2 , A 1\nare\nc o l l i n e a r\n[ 3 6 ] & B, A 2 ,D\nare\nc o l l i n e a r\n[ 2 1 1 ]\n( i04 )⇒\nB, A 1 , A 2 ,D are\nc o l l i n e a r\n[ 2 1 2 ]\n186. B, A 1 , A 2 ,D are\nc o l l i n e a r\n[ 2 1 2 ]\n( w h y c o l l r e s o l u t i o n )⇒\nD, A 2 , A 1\nare\nc o l l i n e a r\n[ 2 1 3 ]\n187. D, A 2 , A 1\nare\nc o l l i n e a r\n[ 2 1 3 ] & DA 1 = DH [ 0 9 ] & DA 2 = DH [ 1 1 ]\n( why midp resolution )⇒\nD i s\nmidpoint\nof\nA 2A 1\n[ 2 1 4 ]\n188. ∠(DF−HB) = ∠(HO 3−EA)\n[ 1 5 8 ] & A, B 1 ,E are\nc o l l i n e a r\n[ 9 4 ]\n( i08 )⇒\n∠\n(DF−BH) = ∠(HO 3−AB 1)\n[ 2 1 5 ]\n189. ∠(DF−BH) = ∠(HO 3−AB 1)\n[ 2 1 5 ] & A, B 1 ,C are\nc o l l i n e a r\n[ 1 2 ] & DF ∥\nAB 1\n[ 1 3 9 ]\n( i09 )⇒\n∠(AC−BH) = ∠(HO 3−DF)\n[ 2 1 6 ]\n190. EB 2 = EH [ 1 5 ] & EB 1 = EH [ 1 3 ]\n( why cong resolution )⇒\nB 1E = B 2E\n[ 2 1 7 ]\n191. B 1E = B 2E\n[ 2 1 7 ] & B 1O = B 2O\n[ 1 4 7 ]\n( r23 )⇒\nB 1B 2 ⊥EO [ 2 1 8 ]\n192. ∠(AC−BH) = ∠(HO 3−DF)\n[ 2 1 6 ] & AC ∥DF [ 1 3 8 ] & HO 3 ∥BH [ 1 6 0 ]\n( why perp resolution )⇒\nDF ⊥BH [ 2 1 9 ]\n193. A, B 2 , B 1\nare\nc o l l i n e a r\n[ 3 0 ] & DF ∥AB 1\n[ 1 3 9 ]\n( why para resolution )⇒\nB 1B 2 ∥DF [ 2 2 0 ]\n194.\nB 1B 2 ⊥EO [ 2 1 8 ] & DF ⊥BH [ 2 1 9 ] & B 1B 2 ∥DF [ 2 2 0 ]\n( i00 )⇒\nEO ∥\nBH [ 2 2 1 ]\n195. BH ∥HO 3\n[ 1 6 0 ] & EO ∥BH [ 2 2 1 ]\n()⇒\nHO 3 ∥EO [ 2 2 2 ]\n196. ∠(AC−BH) = ∠(HO 3−DF)\n[ 2 1 6 ] & AC ∥DF [ 1 3 8 ] & BH ∥EO [ 2 2 1 ] & HO 3 ∥\nEO [ 2 2 2 ]\n( why perp resolution )⇒\nDF ⊥EO [ 2 2 3 ]\n197. ∠(DE−HO 2) = ∠(HO 2−DE)\n[ 1 2 7 ] & HO 2 ∥FO [ 8 6 ]\n( why perp resolution )⇒\nDE ⊥FO [ 2 2 4 ]\n198. DF ⊥EO [ 2 2 3 ] & DE ⊥FO [ 2 2 4 ]\n( r43 )⇒\nFE ⊥DO [ 2 2 5 ]\n199. FE ⊥DO [ 2 2 5 ] & EF ⊥HO 1\n[ 2 1 ]\n( i00 )⇒\nDO ∥HO 1\n[ 2 2 6 ]\n200. DO ∥HO 1\n[ 2 2 6 ] & A,H, O 1 are\nc o l l i n e a r\n[ 5 1 ]\n( i05 )⇒\nDO ∥AH [ 2 2 7 ]\n201. ∠(AH−BC) = ∠(BC−AH)\n[ 3 8 ] & AH ∥DO [ 2 2 7 ] & BC ∥A 1B\n[ 3 9 ]\n( why perp repr )⇒\nDO ⊥A 1B\n[ 2 2 8 ]\n202.\nA 1 , A 2 ,B are\nc o l l i n e a r\n[ 3 6 ] & DO ⊥A 1B\n[ 2 2 8 ]\n( why perp resolution )⇒\nOD ⊥A 2A 1\n[ 2 2 9 ]\n203. D i s\nmidpoint\nof\nA 2A 1\n[ 2 1 4 ] & OD ⊥A 2A 1\n[ 2 2 9 ]\n( r22 )⇒\nOA 1 =\nOA 2\n[ 2 3 0 ]\n204.\nC 1 , C 2 , A 1 , A 2\nare\nc o n c y c l i c\n[ 2 0 9 ] & OC 1 = OC 2\n[ 2 6 ] & OA 1 =\nOA 2\n[ 2 3 0 ]\n( r50 )⇒\nOC 1 = OA 1\n[ 2 3 1 ]\n205. OC 1 = OB 2\n[ 1 4 6 ] & OC 1 = OC 2\n[ 2 6 ] & OC 1 = OA 1\n[ 2 3 1 ]\n( i01 )⇒\n48\n\nC 1 , B 2 , A 1 , C 2\nare\nc o n c y c l i c\n[ 2 3 2 ]\n206.\nC 1 , B 2 , A 1 , C 2\nare\nc o n c y c l i c\n[ 2 3 2 ] & C 1 , A 1 , C 2 , A 2\nare\nc o n c y c l i c\n[ 2 0 9 ]\n( i11 )⇒\nC 1 , B 2 , A 1 , A 2\nare\nc o n c y c l i c\n[ 2 3 3 ]\n207.\nC 1 , B 2 , A 1 , C 2\nare\nc o n c y c l i c\n[ 2 3 2 ] & C 1 , B 2 , A 1 , A 2\nare\nc o n c y c l i c\n[ 2 3 3 ] & C 1 , B 2 , C 2 , B 1\nare\nc o n c y c l i c\n[ 1 4 5 ]\n( i11 )⇒\nA 2 , B 2 , C 1 , A 1 , B 1\nare\nc o n c y c l i c\n[ 2 3 4 ]\n208.\nA 2 , B 2 , C 1 , A 1 , B 1\nare\nc o n c y c l i c\n[ 2 3 4 ]\n( w h y c y c l i c r e s o l u t i o n )⇒\nC 1 , B 2 , A 1 , B 1\nare\nc o n c y c l i c\n[ 2 3 5 ]\n209.\nC 1 , B 2 , A 1 , C 2\nare\nc o n c y c l i c\n[ 2 3 2 ] & C 1 , B 2 , A 1 , A 2\nare\nc o n c y c l i c\n[ 2 3 3 ] & C 1 , B 2 , A 1 , B 1\nare\nc o n c y c l i c\n[ 2 3 5 ]\n( i11 )⇒\nC 1 , C 2 , B 1 , B 2 , A 1 , A 2\nare\nc o n c y c l i c\n==========================\n49\n\nC\northocenter aux Problem\nFigures 4 and 5 of the symbols graphs and the dependency graphs in the paper refer to the\nproblem orthocenter aux, present in the examples.txt problem file already in the original\nAlphaGeometry codebase. Here we present a description of the problem.\nThe problem is to prove the existence of the orthocenter of the triangle, that is, the common\nintersection of the three heights:\nProblem. Given a triangle ABC and D the intersection of the heights of the triangle with\nrespect to sides AC and AB, prove that D is also in the height relative to side BC. Take as an\nauxiliary point E, the foot of the vertex B with respect to side AC.\nExplanation of AlphaGeometry’s translation of the orthocenter aux problem:\nCon-\nsider the triangle ABC and that\n• D is the intersection of the line perpendicular to AC through B with the line perpendicular\nto AB through C.\n• E is the intersection of line AC with line BD.\nThen, prove that line AD is perpendicular to line BC.\nFormal translation of the problem:\na b c = t r i a n g l e\na b c ;\nd = o n t l i n e\nd b a c ,\no n t l i n e\nd c a b ;\ne = o n l i n e\ne a c ,\no n l i n e\ne b d ? perp a d b c\n50\n\nReferences\nShang-Ching Chou, Xiao-Shan Gao, and Jing-Zhong Zhang. A deductive database approach to\nautomated geometry theorem proving and discovering. Journal of Automated Reasoning, 25\n(3):219–246, 2000.\nGuillaume Lample, Timothee Lacroix, Marie-Anne Lachaux, Aurelien Rodriguez, Amaury Hayat,\nThibaut Lavril, Gabriel Ebner, and Xavier Martinet. Hypertree proof search for neural theorem\nproving. Advances in neural information processing systems, 35:26337–26349, 2022.\nShiven Sinha, Ameya Prabhu, Ponnurangam Kumaraguru, Siddharth Bhat, and Matthias\nBethge. Wu’s Method can Boost Symbolic AI to Rival Silver Medalists and AlphaGeome-\ntry to Outperform Gold Medalists at IMO Geometry. arXiv preprint arXiv:2404.06405, 2024.\nBart de Smit, Ilya Bogdanov, Johan Bosman, Andries Brouwer, Gabriele Della Torre, G´eza K´os,\nHendrik Lenstra, Charles Leytem, Ronald van Luijk, Christian Reiher, Eckard Specht, Hans\nSterk, and Lenny Taelman. 52nd International Mathematical Olympiad Problem: Shortlist\nWith Solutions. Technical report, International Mathematical Olympiad (IMO), Amsterdam,\nJuly 2011. URL https://www.imo-official.org/problems/IMO2011SL.pdf.\nTrieu H. Trinh, Yuhuai Wu, Quoc V. Le, He He, and Thang Luong. Solving olympiad geometry\nwithout human demonstrations. Nature, 625(7995):476–482, January 2024. ISSN 0028-0836,\n1476-4687. URL https://www.nature.com/articles/s41586-023-06747-5.\nWen-Ts¨un Wu.\nOn the decision problem and the mechanization of theorem-proving\nin\nelementary\ngeometry.\nScientia\nSinica,\n21(2):159–172,\n1978.\nURL\nhttp:\n//utest.sciengine.com/publisher/ScienceChinaPress/journal/ScientiaSinica/\n21/2/10.1360/ya1978-21-2-159.\nZheng Ye, Shang-Ching Chou, and Xiao-Shan Gao. An Introduction to Java Geometry Expert.\nIn Automated Deduction in Geometry: 7th International Workshop, ADG 2008, Shanghai,\nChina, September 22-24, 2008. Revised Papers 7, pages 189–195. Springer, 2011.\n51",
    "pdf_filename": "Newclid_A_User-Friendly_Replacement_for_AlphaGeometry.pdf"
}