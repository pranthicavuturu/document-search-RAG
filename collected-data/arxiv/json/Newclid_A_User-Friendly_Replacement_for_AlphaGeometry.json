{
    "title": "Newclid: A User-Friendly Replacement for AlphaGeometry",
    "abstract": "We introduce a new symbolic solver for geometry, called Newclid, which is based on AlphaGeometry. Newclid contains a symbolic solver called DDARN (derived from DDAR- Newclid),whichisasignificantrefactoringandupgradeofAlphaGeometry’sDDARsymbolic solverbybeingmoreuser-friendly-bothfortheenduseraswellasforaprogrammerwishing toextendthecodebase. Fortheprogrammer,improvementsincludeamodularizedcodebase andnewdebuggingandvisualizationtools. Fortheuser,Newclidcontainsanewcommand lineinterface(CLI)thatprovidesinterfacesforagentstoguideDDARN.DDARNisflexible with respect to its internal reasoning, which can be steered by agents. Further, we support input from GeoGebra to make Newclid accessible for educational contexts. Further, the scope of problems that Newclid can solve has been expanded to include the ability to have animprovedunderstandingofmetricgeometryconcepts(length,angle)andtousetheorems such as the Pythagorean theorem in proofs. Bugs have been fixed, and reproducibility has beenimproved. Lastly,were-evaluatedthefiveremainingproblemsfromtheoriginalAG-30 datasetthatAlphaGeometrywasnotabletosolveandcontrastedthemwiththeabilitiesof DDARN,runninginbreadth-first-searchagenticmode(whichcorrespondstohowDDARN runsbydefault),findingthatDDARNsolvesanadditionalproblem. Wehaveopen-sourced our code under: https://github.com/LMCRC/Newclid 1 Introduction Generalremarks. AlphaGeometry[Trinhetal.,2024]demonstratedtheabilitytosolvegeom- etryproblemsattheleveloftheInternationalMathematicalOlympiad(IMO),withperformance comparabletotophumancompetitors. AttheheartofAlphaGeometryisaformallanguagethat encodesgeometricproblemsandtheorems,rootedinJGEX[Yeetal.,2011],aswellasasymbolic reasoning engine called DDAR (see Subsection 4.4.2 for more information), written in Python, ∗Equalcontributions. †Correspondingauthor: vladmir.siccagoncalves@mail.mcgill.ca ‡WorkcarriedoutwhileatHuawei. §Correspondingseniorauthor: simon.frieder@cs.ox.ac.uk 1 4202 voN 81 ]RG.sc[ 1v83911.1142:viXra",
    "body": "Newclid: A User-Friendly Replacement for AlphaGeometry\nVladmir Sicca∗†1, Tianxiang Xia∗‡3, Math¨ıs F´ed´erico∗‡ , Philip John Gorinski‡4,\nSimon Frieder§2, and Shangling Jui1\n1Huawei Lagrange Mathematics and Computing Research Center\n2Oxford University\n3ETH Zu¨rich\n4Robin AI\nNovember 20, 2024\nAbstract\nWe introduce a new symbolic solver for geometry, called Newclid, which is based on\nAlphaGeometry. Newclid contains a symbolic solver called DDARN (derived from DDAR-\nNewclid),whichisasignificantrefactoringandupgradeofAlphaGeometry’sDDARsymbolic\nsolverbybeingmoreuser-friendly-bothfortheenduseraswellasforaprogrammerwishing\ntoextendthecodebase. Fortheprogrammer,improvementsincludeamodularizedcodebase\nandnewdebuggingandvisualizationtools. Fortheuser,Newclidcontainsanewcommand\nlineinterface(CLI)thatprovidesinterfacesforagentstoguideDDARN.DDARNisflexible\nwith respect to its internal reasoning, which can be steered by agents. Further, we support\ninput from GeoGebra to make Newclid accessible for educational contexts. Further, the\nscope of problems that Newclid can solve has been expanded to include the ability to have\nanimprovedunderstandingofmetricgeometryconcepts(length,angle)andtousetheorems\nsuch as the Pythagorean theorem in proofs. Bugs have been fixed, and reproducibility has\nbeenimproved. Lastly,were-evaluatedthefiveremainingproblemsfromtheoriginalAG-30\ndatasetthatAlphaGeometrywasnotabletosolveandcontrastedthemwiththeabilitiesof\nDDARN,runninginbreadth-first-searchagenticmode(whichcorrespondstohowDDARN\nrunsbydefault),findingthatDDARNsolvesanadditionalproblem. Wehaveopen-sourced\nour code under:\nhttps://github.com/LMCRC/Newclid\n1 Introduction\nGeneralremarks. AlphaGeometry[Trinhetal.,2024]demonstratedtheabilitytosolvegeom-\netryproblemsattheleveloftheInternationalMathematicalOlympiad(IMO),withperformance\ncomparabletotophumancompetitors. AttheheartofAlphaGeometryisaformallanguagethat\nencodesgeometricproblemsandtheorems,rootedinJGEX[Yeetal.,2011],aswellasasymbolic\nreasoning engine called DDAR (see Subsection 4.4.2 for more information), written in Python,\n∗Equalcontributions.\n†Correspondingauthor: vladmir.siccagoncalves@mail.mcgill.ca\n‡WorkcarriedoutwhileatHuawei.\n§Correspondingseniorauthor: simon.frieder@cs.ox.ac.uk\n1\n4202\nvoN\n81\n]RG.sc[\n1v83911.1142:viXra\nwhich is an extension and reimplementation by Trinh et al. [2024] of an earlier symbolic AI\nengine [Chou et al., 2000].\nIntertwined with DDAR in the original work is a large language model (LLM), trained on\na synthetic dataset of proofs generated using DDAR, that predicts new geometric clauses that\nDDAR can use to draw new inferences.\nAlphaGeometry’s inference loop. AlphaGeometry works, at a high level, in the following\nway: DDARiteratesthroughstatementsthatcanbelogicallyjustifiedfrompreviousonesuntilit\nfindswhatneedstobeproved. Therearemanywaystofindanewstatement: Aninitialbatchof\nthem comes from expanding the clauses into statements by the rules described in the defs.txt\nfile. Then, sequentialiterationsoftheARmodulethatmakeupDDAR(seeSubsection4.4.2for\nmore information), followed by the application of rules in the rules.txt file is applied until the\ngoal or a fixpoint is reached. In case of reaching a fixpoint, the LLM will be called to add a new\nclause so the iterations can start again.\nIssues. Despite its impressive reasoning capabilities, AlphaGeometry suffers from limitations\nin terms of user-friendliness, both for the end-user as well as for the programmer interested in\nextending the current codebase and the scope of problems it can handle.\n• User-friendliness issues: Therearethreemainobstaclesthatusershavetoovercometouse\nAlphaGeometry:\n– Installing AlphaGeometry is difficult, mainly because the Meliad library,1 on which Alpha-\nGeometry depends, is difficult to install.\n– Problems have to be input using the JGEX formal language.\n– The files rules.txt and defs.txt inside the AlphaGeometry system describe the founda-\ntions which DDAR uses to make inferences.2 Yet, during AlphaGeometry’s inference loop\n(see above), different rules could kick that were not explicitly stated in these text files, but\nare hard-coded, see Section 3.4.3.\n• Coder-friendliness issues. AlphaGeometry’s codebase is not modularly built, which makes\nit hard for someone who want to contribute code to add new features, inspect proof traces,\nadd logs, etc. Further, the LLM is implemented in Meliad, a deep-learning Python library\nthat is not widely used - which further makes it hard to finetune the LLM or understand its\ninner workings, among other desirable operations.\n• Problem scope issues. AlphaGeometry is not able to work with rather simple and funda-\nmental theorems, notably the Pythagorean theorem, lacking support for the concept of length\nof a segment, used, among other things, in elementary geometry courses. This makes Alpha-\nGeometryatypeofnarrow AIsystemwhoseintelligencecontrastswithhumanintelligence: it\nisinconceivablethatanIMO-levelcompetitorwillbeabletosolvecertainIMO-levelgeometry\nproblems while not being able to use the Pythagorean theorem. AlphaGeometry “overfits” on\nOlympiad geometry problems, compared to arbitrary plane geometry.\n1https://github.com/google-research/meliad\n2Detaileddescriptionsandexplanationsofthecontentofthosefilescanbefoundintheproject’sdocumentation\nunderhttps://lmcrc.github.io/Newclid/\n2\nContributions. Inthisresearchwork,wehavefocusedoureffortspredominantlyontheDDAR\nsolver (as opposed to the LLM) because of the relative importance of DDAR when compared\nto the LLM in considering the contributions of these two core components of AlphaGeometry\ntowards its final performance on the test dataset: Two datasets were used to report the perfor-\nmance of AlphaGeometry: AG-30, consisting of 30 geometry problems from the IMO, as well\nas a larger unnamed set of 231 Olympiad-level geometry problems [Trinh et al., 2024] (no data\ncollectionprotocolhasbeenprovided). WewillcallthelatterAG-231 todistinguishbetweenthe\ntwo. Table 1 in [Trinh et al., 2024] presents a breakdown of the performance of AlphaGeometry,\nasafunctionofwhichcombinationofmethodshasbeenused(DDonly,DDAR,DDAR+human\nheuristic, DDAR + various forms of the LLM, etc.) on the AG-30 dataset. This is augmented\nbyFigure6,bintheExtendedDatasectionof[Trinhetal.,2024]: Ifwere-expresstheresultson\nAG-30fromTable1inpercentages, thebestsymbolicAIapproach(DDAR+humanheuristics)\nsolves 60% of the problems, whereas the best deep-learning approach (DDAR + LLM) solves\n∼83.3%oftheproblems. Yetthisincreaseof∼23%isreducedtoanincreaseofmerely∼6.5%on\nthe larger—and thus more representative—AG-231 dataset, where DDAR + human heuristics\nsolve ∼92.2%, and DDAR + LLM solves ∼98.7% of problems. (Further, it was noted in [Sinha\net al., 2024] that the number reported in Table 1 on how many problems could be solved by the\nclassical Wu method [Wu, 1978] was underestimated since it was found that Wu’s method was\nable to solve 15 rather than 10 problems.)\nConcretely, because of DDAR’s outsized importance in AlphaGeometry, as argued above, we\nfocused on Newclid, which uses a new symbolic solver called “DDARN” (DDAR-Newclid) that\nfixed many of the issues present in DDAR:\n1. User friendliness. The following elements were improved:\n• Simplified installation: We provide simple ways to install Newclid, in particular, via\nPyPI. We have removed the dependency on the Meliad library, and streamlined the\ninstallation process, see Subsection 3.1.\n• Problems can be input using an improved command-line interface (CLI), which offers\nendpoints to introduce agents that can manipulate DDARN, see Subsection 3.2.\n• Additionally to the new CLI, problems can also be input using the GeoGebra interface,\nsee Subsection 3.3.\n• We have slightly expanded the scope of problems that can be solved. DDARN can use,\nin particular, Pythagoras theorem, see Subsection 3.4.\n2. Coder friendliness. A significant refactoring of existing classes was performed, and\nseveral tools that assist in debugging and allow the visualizing of several internal objects\n(such as symbolic graphs) are introduced. These improvements fall into three categories:\n• General code refactoring that does not affect the reasoning capabilities but laid the\ngroundwork for any subsequent work that was done, see Subsection 4.1\n• improvements that affect how the reasoning works, which include changes that make\nadding future code easier, see Subsections 4.2, and\n• improvements that improve the DDARN reasoning engine, see Subsection 4.4, and\n• tools that make debugging and visualizing of DDARN’s internal objects easier (in fact\nwe used these to find some of the missing rules, see Subsection 4.3.\n3. Reproducibility. WehaveelaboratedonthereproducibilityofAlphaGeometryandNew-\nclid, see Section 5.\n3\n4. Detailed evaluation. Lastly,wecompareAlphaGeometry’sDDARtoNewclid’sDDARN\nonthefiveproblemsfromtheAG-30datasetwhosesolutioneludedAlphaGeometry,namely\nthe IMO problems 2008 P1B, 2006 P6, 2011 P6, 2019 P2 and 2021 P3. Two problems out\nofthesefive,weargue,cannoteasilybesolvedgiventhecurrentsymbolicsolverframework;\none problem that previously was not solvable becomes solvable using DDARN (IMO 2008\nP1B), as can be seen in Section 6.\nIn the future (see Section 7), we plan to augment Newclid to also include an improved LLM,\ncompared to the one present in AlphaGeometry, that would be one example of an agent that\nmanipulates DDARN.\n2 Terminology\nBelow, we define various terms related to functional aspects that underlie both DDAR and\nDDARN. Some (but not all) of these were implicitly used in [Trinh et al., 2024]. To make the\ninner workings of DDAR and DDARN reasoning engines more transparent, we chose to give\nan explicit description of all of them to enhance the conceptual understanding of DDAR and\nDDARN.\nWhen defining a theory for plane geometry, one is faced with the question of deciding what\narethefundamentalobjectsthatwillbeusedtodescribethetheory. ThechoicemadeforDDAR,\nand continued in DDARN, are to base the theory on points, and use them to represent other\ngeometric objects (lines, circles, triangles, angles, ratios, relationships between objects, etc.).\nThe relationship descriptors, such as cyclic, or cong, to denote whether a collection of points\nlie on a circle or two congruent segments, respectively, are called predicates. Their use dates\nback to the DD symbolic engine introduced by Chou et al. [2000]. Predicates work thus like a\nfunction,takingasargumentspoints,e.g.,cyclic a b c ddescribesthatthefourpointsa, b,\nc, d are on the same circle and cong a b c d describes the congruence of the two segments,\ntextttab and cd, that are made up by the four points a,b,c,d. A predicate that is instantiated\nby points, such as the mentioned circle a b c, is called a statement and is the foundational\nelement of the reasoning engine.\nIn DDAR and DDARN, inferences can be made by using three different paths: application\nofrulesdescribedintherules.txtfile,runningthealgebraicreasoningmodule,andresolutions\nthat are made on the go through hard-built, not-described functions (which we call intrinsic\nrules).\nThe collection of statements that DDAR and DDARN store at a given point when solving a\nproblem is the proof state of the problem at that stage. The objective of the engine is to find a\nspecific statement, the goal, supplied by the user, in the proof state.\nWhenever we use the word symbolically in this article, we refer to something that is inferred\nexclusively from the proof state. As explained below, statements are not directly inserted in\nthe proof state by a human but are either derived from the problem prescription, derived from\npreviousstatementsbytheinferenceloopthatrunswithinDDARandDDARN,or,insomerare\ncases, directly derived from a diagram of the problem through a numerical check.\nThe problem prescription, created by a human user, does not use the language of the state-\nments and predicates apart from the establishing of the goal, but that of clauses, implemented\nfrom definitions. Clauses represent geometric constructions, and we will often refer to clauses as\nconstructions. Most clauses will induce the generation of statements. For example, in a problem\nwherepointsa,b,andcarealreadydefined,wemaydefinepointd = incenter d a b cinthe\nstatement of the problem. In that case, when the problem is read, the statements described in\nthe incenter definition, with those arguments, will be added to the starting point of the proof\n4\nstate, namelytheonescorrespondingtothefactthattheincenteristhemeetingofthebisectors\nof the angles of the triangle: eqangle a b a c a x a c, eqangle c a c x c b, and eqangle\nb c b x b x b a.\nThe definition incenter will also provide instructions to get numerical coordinates for point\nd,andheretheinformationthattheincenteristheintersectionofinternalbisectorsoftheangles\nof the triangle instead of external ones is recorded in some sense. In comparison, there is also\na definition of excenter that is symbolically equivalent to the incenter, which will create a\npoint with an appropriately different numerical representation. Clauses can also be added by\nthe LLM later in the solving loop of a problem, but technically DDAR/DDARN see this action\nas the writing of a new problem.\nDuring the reasoning procedure, the main way to generate new statements is through the\napplications of rules. A rule is the encoding of a theorem, and it consists of a sequence of\nstatements, the hypothesis, followed by a new statement, the consequence. Of course, a rule is\nwritten with generic points, so a separate procedure when rules are actually being used is to\ndo the matching of the rule. The matching is the process of seeing if, for some combination of\npoints, all the hypotheses of the rule are statements in the proof state. If so, the consequence\nof the rule will be added to the proof state as well. A full list of rules available for Newclid,\nnumbered r1 to r69, can be found in Appendix A.\nThese shortcomings prevent it from being widely adopted by mathematicians working in the\ndomain of theorem proving, educators, and students learning Euclidean geometry. Therefore we\nintroduce Newclid, which is a large refactoring of AlphaGeometry, that improves AlphaGeome-\ntry’s codebase, in particular the DDAR solver.\n3 User Friendliness.\nBelow, we detail the four improvements that we made regarding user-friendliness: This includes\na simplified installation process, two interfaces that we have added to Newclid to make it more\nuser-friendly (the command line interface (CLI), and the other is a GeoGebra interface), and a\nsection on how we expanded the problem scope that DDARN can solve.\n3.1 Easy Installation\nWe have streamlined the installation process so that it is easy to install Newclid using pip\ninstall; additionally, we are releasing it as a PyPI package. The isolation of the Meliad de-\npendency was the main factor in making the installation easier, as running the DDARN solver\nnow is not contingent on having Meliad installed (for AlphaGeometry, even if only DDAR was\nused, Meliad also had to be installed). Further, we have created an API so that Newclid can be\ncomfortably called from other code.\n3.2 Command Line Interface (CLI)\nOur most fundamental new interface is presented to the user via the command line interface\n(CLI).ItsmainobjectiveistoallowonetorunaproblemwithNewclid, withouthavingtousea\nPython code entry point, and with the option of a human-understandable step-by-step process,\nwhich allows the replacement of the original LLM by human decisions.\nTheCLIischaracterizedbyahighdegreeofcontroloverthesolverthroughourcurrentthree\nagents (a human option, a brute-force automatic option, or a dummy option), which we detail\nbelow.\n5\nProblems always need a defined name: multiple problems can be inside a single text file and\nare referred to by a name. In the case of the GeoGebra folder with the GeoGebra .ggb file\n(which contains the entire construction made up of clauses but not the goal), a text file with the\ngoal needs to be supplied. Problems can be fed to Newclid in formal language from a .txt file,\njust as in the case of AlphaGeometry. The CLI provides the following elements:\n• An environment: We have introduced a new concept of environment that contains the rules\nfile and the definitions file for the problems used by the reasoning agent.\nA typical environment, with the outputs of solutions of a hypotetical problem1 has the fol-\nlowing structure and contents.\nenvironment/\n|-- rules.txt\n|-- defs.txt\n|-- problem1/\n| -- problem1.ggb\n| -- html\n| -- index.html\n| -- symbols_graph.html\n| -- dependency_graph.html\n| -- figure.svg\n| -- goals.txt\n| -- construction_figure.svg\n| -- run_infos.txt\n| -- proof_steps.txt\n| -- proof_figure.txt\n|-- problem2/\nDifferent files with rules and definitions can be used for each problem so that the solver uses a\ndifferent set of those exclusively for one specific problem. For technical details we refer to the\ndocumentation section.\nIntroducing the concept of environment for a problem proved to be a good solution to 1)\nflexibly allow various ways of inputs (currently Newclid supports CLI and GeoGebra (see\nbelow), butweinvitethecommunitytoextendourapproach), wheretheenvironmentcollects\nall necessary toenable that input, and2) to provide, similarly to asoftware package manager,\nsuch as Python’s virtual environments, an easy way to run different mathematical problems\nwith different inputs.\n• Seeds: The construction of a numerical diagram of the problem contains various random\nchoices, which can influence numerical check predicates and change poofs. A seed is collected\nso that these choices can be made deterministic;\n• Displaysettingsandlogging: Itisspecifiedwhatlogstheterminalshouldshowifthematrices\ngenerated by the algebra reasoning sub-engine (the “AR” part) should be displayed or if no\nlogs should be recorded.\nAlphaGeometry’sdesignissuchthatitruns,givenaninitialhumantranslationofageometric\nproblem into JGEX, to end without further human intervention. Thus, the reasoning procedure\nis rigid.\n6\nFigure 1: Index page generated for a single problem, with the diagram of the proof, the symbols\ngraph, and the dependency graph.\nContrasting, we designed Newclid by generalizing its working to allow agentic interaction\nmodes. In particular, the Human Agent is an interface that allows a person to control the path\nof a solution, deciding which theorems to try to apply at each moment, add new points on the\ngo, check symbolically if a given statement was added to the proof state at any given stage, look\nat the evolution of the proof graphs at each step, or run the usual breadth-first-search DDAR\nreasoning procedure on call.\nThe Human Agent is called as a reasoning agent, currently in opposition to DDARN (which\nwe also treat as an agent, see Subsection 4.2 to see how this is treated in the code), as it can\nbe viewed as a particular way to guide the search for a proof of the problem. It was designed\nas a first step towards a plan to try to improve the proof search from BFS to a better heuristic\nthrough learning from human data of trying to solve problems, but it also proved an important\ntool in debugging, as it became a way to check the effect of theorems one at a time, drastically\nincreasing the granularity of diagnostics when compared to full BFS runs.\nIt is still limited for human use because the lack of a better graphic interface can make it\nhard to directly understand the problems and theorems only from the text, but it is our belief\nthat a friendlier interface for the Human Agent could even make it an interesting learning tool.\nWith it, users can try to experiment fast when solving a problem, without the risk of making\nfalse claims, and check what middle steps have been already verified at each point, as well as\nsee the history of the proof state. It could work for problem investigation in plane geometry\nin tandem with a graphic tool like GeoGebra, the same way symbolic computing and graphic\nsoftware like Mathematica and MatLab work with investigations in other areas of mathematics\nand applied sciences.\n7\n3.3 Geogebra Interface\nOne barrier to using AlphaGeometry is the need to translate a given geometric problem into\nthe internal JGEX formal language format, which is not widely known, not widely used in other\nsystems, and not well-documented. To make usage of this software simpler, Newclid provides an\ninterfaceforausertobeabletoprescribetheproblemfromaGeoGebradiagramoftheproblem\ninstead. The big advantage is that GeoGebra has an intuitive graphic interface, is widely known\nby people working with Euclidean geometry (including in educational settings), and has a large\ncommunity to support one’s path to learning its usage.\nTo provide the statement of the problem, one has to provide a file environment containing\nthe .ggb file and a goals.txt file containing the goals in JGEX format. Newclid will then\nuse the GeoGebra construction to generate the numerical representation of the problem and the\nconstructiontoolsusedinGeoGebratoenumeratetheinitialpremisesintheproofstate,allowing\nthe solver to operate as if the problem were prescribed in text.\n3.4 Expanded Problem Scope\nAll of the extensions outlined here rely on our significant refactoring of the code, which was the\nfoundation that made the extensions possible in terms of reasoning capabilities. In the following\nSubsections 3.4.1, 3.4.2, 3.4.3, 3.4.4, we mention various new additions we made. These are the\nby-product of our refactoring, which made these extensions, in particular, the ones made in the\nlast section, 3.4.4, possible. Our big achievement is that Newclid is able to use the Pythagorean\ntheorem inside other proofs, see Subsection 3.4.3.\n3.4.1 Adding New Predicates\nPredicates form the internal vocabulary used by the reasoning of the engine. We recall from the\nsection on terminology, Section 2, that each predicate behaves as a function, with a prescribed\nnumber of arguments which correspond to points. A predicate should be thought by the user\nas a fact relating the arguments, such as “the segments defined by two pairs of points being\ncongruent”, or “the lines through these two pairs of points being parallel”. The only human\ninputs of predicates are the goals of a problem, but any definition will be symbolically broken\ndown into instances of predicates, and rules are stated in terms of predicates as well. The\nenginethenproceedsto“think”usingthislanguage. Therefore, thelistofpredicatesisthemost\nfundamental list of notions that the engine knows.\nCrucially, AlphaGeometry lacked functional predicates that consider numerical measures of\nangles, ratios, and lengths. This made simple questions, such as finding the third angle of a\ntrianglegiventhevaluesofthefirsttwo, unanswerable, evenifthealgebraicmodulecouldeasily\nfind the information. Given that questions asking for a specific angle or distance are extremely\ncommon in Euclidean geometry and would be expected of any plane geometry solver, this was\na significant limitation we sought to overcome. (Curiously, we found traces of such predicates\ninside the released codebase, which left us with the impression that the original intention was to\ninclude them but that this was abandoned for reasons unknown to us.)\nTo fill this gap, we patched up or added the following predicates:\n• aconst. This predicate encodes the information that the angle between two lines has a given\nconstant value (that can be given in degrees or in radians). Specifically, lines are denoted in\norder, eachbyapairofpoints,andtheangleistheoneobtainedbygoinginthecounterclock-\nwise direction from the first to the second line. In the original work, this predicate backed the\ns angle definition and superficial predicate, but it only accepted radians as input and could\n8\nFigure 2: An exemplary problem in GeoGebra that can be parsed by Newclid.\n9\nnot be used for goals. We fixed it for all uses, created syntax for both degrees and radians in\na unified predicate and turned s angle into only a definition that directly calls aconst.\n• rconst. This predicate encodes the information that the ratio between two segments is a\ngivennumericalfraction. Itwaspresentintheoriginalcodebase,inthedefinitiontriangle12\nspecifically,butwasnotfunctional. Wefixeditinallfunctionalitiesandswitchedtoafraction\nnotation for the ratio instead of a pair of integers.\n• lconst. This predicate encodes the information that the length of a segment is a given nu-\nmericalvalue(withoutunits). Itwascreatedfromscratch,asitwasnotafunctionalitywithin\nthe original AlphaGeometry, so we added it mirroring the behaviour of the other predicates\ndealingwithconstantmeasures. Togiveconsistencytothispredicate, itwasalsonecessaryto\nchangesomeoftheexistingdefinitions,astheircorrespondingnumericalsketchwasnotlength-\nagnostic. This complication was probably not addressed in the original software because its\nwhole logic structure was scale invariant by not ever assigning numerical length information.\nTheoretically, the study of lengths creates a new issue, as a numerical length demands a unit\nof measurement in contrast to angles and ratios. Our approach to this was to assume a single\nunnamed unit of measurement throughout each problem.\n• acompute. This is a new kind of predicate that does not simply ask for the proof of a goal\nbut creates the goal itself on the run. It is meant for open-ended questions, specifically when\na problem asks the measure of a specific angle. It will try to locate the corresponding aconst\nstatement and turn it into the goal internally. Then, it generates a proof in which the last\nstatement is the angle being measured equals its value.\n• rcompute. The exactanalogue of acompute for problemsasking the value ofa ratiobetween\ntwosegments. Similarly,itwillsearchforanrconststatementintheproofstatecorresponding\nto the ratio asked and turn it into the goal of the problem.\n• lcompute. Working just as acompute and rcompute, lcompute is meant to allow one to ask\nthelengthofasegmentbysearchingtheappropriatelconststatement. Thesethreepredicates\nadd little in terms of logic but are ubiquitous among elementary school problems and allow\none to “solve” geometry problems in a larger sense: not only writing down proofs but also\nfinding open solutions.\n• nsameside. This predicate is of a different nature with respect to the previous ones, as it\nis simply a numerical check, not verifiable symbolically. It can be imposed as a goal, but\nif it is true, it will automatically be satisfied. Adding predicates like this is important to\nallow for proper enunciating of rules, especially since the solver uses the notion of full angles,\nwhich do not differentiate between the two angles in an intersection. The previous version of\nAlphaGeometryalreadyhadasamesidepredicatethatverifiediftwopointswereonthesame\nside of two corresponding vectors by checking if the inner products between pairs of vectors\nin the configuration have the same sign. For a larger flexibility of adding rules, we added\na predicate for the negation of sameside as well, just as was the case for the collinearity,\nperpendicularity, and parallelism predicates.\n• same clock. Justaswasthecasefornsameside,same clockisalsosimplyanumericalcheck,\none that verifies if the triplets of vertices of two different triangles are ordered with the same\norientation. This is important when checking the similarity and congruence of triangles in the\ncase of full angles, as the fact that two angles are the same only if there is an orientation-\npreserving isometry taking one to the other (with markings) means the rules for triangle\nsimilarity and congruence are also orientation sensitive. In the original work, the authors\n10\nsolved this problem by implementing a function that checked orientation hidden inside the\nmatchingofrulesinvolvingcongruenceandsimilarity. Theissue,ofcourse,isthatsuchchecks\nwere hidden from the proofs and were not highlighted in the code. To solve those problems,\nweturnedtheoriginalsame clockPythonfunctionintoanexplicitpredicatethatcanbeused\nto write rules and that behaves as the other numerical checks.\n3.4.2 Adding New Definitions\nWhile predicates are prerequisites for an extension of reasoning, simply adding a predicate does\nnotincorporateitintotheenginereasoning. Informationaboutthepredicateentersthereasoning\nloop either by direct insertion of information in the statement of the problem or as a derivation\nof a rule. As can be noted from the experience of solving geometry problems in general, for\nproblems where angles and lengths measures occur, it is usually necessary that some previous\nmeasure is provided, such as a known angle. That is particularly true in the case of lengths, as\nestablishing a scale is always necessary in order to calculate distances.\nInparallel,evenpredicatesthatareoftenderivedfromruleswithoutaneed foranintroduction\nof the statement can be wanted as a premise. For example, the eqratio statement, which\ncorresponds to the fact that the ratios between two pairs of segments are the same, usually\noccurs as a consequence of verification of conditions on similar triangles, but it is not unusual\nthat a problem has such as a statement mentioned in its premises, in the form of a proportion.\nTo be able to insert those sorts of premises for problems, Newclid has to introduce new defi-\nnitions. Introducingnewdefinitionsonthesyntaxisnotahardtaskfromatechnicalviewpoint,\nin essence one only needs to define the characteristics of the definition on the .txt file con-\ntaining the list of definitions and construct a corresponding function in the sketch.py module\nthat creates a numerical representation of the new definition. Nonetheless, it is a crucial step in\nincreasing the scope of the problems that can be stated for Newclid.\nWe introduced new definitions with the goal of declaring premises of problems that were\nnot available before but could be managed by the original predicates, of declaring premises of\nproblems that demand the new predicates (de facto including them in the reasoning possibilities\nof the Newclid), or of making previous definitions more flexible, either reducing conditions for\ntheiruseormakingthestatementseachdefinitionaddsmorestrict. Weintroducedthefollowing\ndefinitions:\n• on pline0. Similar to the previously existing on pline, but drops the requirement that the\nparallel lines are distinct, allowing one to have overlapping parallel lines.\n• iso triangle0. Similar to the previously existing iso triangle, generates the three vertices\nofanisoscelestrianglebutaddstotheproofstateonlythefactthatthetrianglehastwoequal\nsides, not also a pair of equal angles as well. This should be proved.\n• iso triangle vertex. As in the previous definition, it creates only the apex of an isosceles\ntriangle, but it is weaker than the original definition on bline, which included both the con-\ngruenceofapairofsidesandofapairofanglesintotheproofstate. Thisonlyaddscongruence\nof a pair of sides.\n• iso triangle vertex angle. This is the complementary definition to iso triangle vertex,\nwhich creates the apex of an isosceles triangle but only adds the statement of the angle con-\ngruence to the proof state.\n• on aline0. This new construction of an angle equivalence adds a configuration that did not\nexistbefore. Namely,givenanintersectingpairoflines,athirdline,andafreepoint,itcreates\n11\na new point such that the line through this point and the previously existing free point forms\nan angle with the third line that is congruent to the angle between the other pair of lines. It\nis more flexible and includes the previous definitions on aline and angle mirror as special\ncases.\n• eqratio. This new construction is the first that allows the prescription of an eqratio predi-\ncate, that is, to deal with a premise that two pairs of segments have an equal ratio between\nthem. As for on aline0, it takes seven points as arguments (two free existing segments and a\nfree point) to create a new one that completes a fourth segment.\n• eqratio6. This is another new construction created to insert eqratio conditions that can\nbe problem premises. In this case, it creates a point that will show up twice in the same\nfraction of the proportion equivalence, which is usually used to split a given segment with the\nproportion of a pair of segments. As such, the function takes only six points as arguments.\n• rconst. Thisconstructionwascreatedtoinsertarconstpredicateasapremiseofaproblem,\nthat is, a premise that says a pair of segments has a prescribed ratio. It takes one segment\nand a free point as arguments to construct a fourth point completing the second segment in\nthe ratio.\n• rconst2. Similarly to eqratio6, this construction allows for an instantiation of rconst in\nwhich a point shows up in both segments of the prescribed ratio. It is particularly used for\nproblems which ask for a segment to be split in a ratio of p:q.\n• aconst. This is a new construction for prescribing an angle between two lines with a fixed\nvalue without the need to specify the angle vertex. It is the first construction to implement\nthe aconst predicate explicitly.\n• s angle. TheoriginalAlphaGeometryhadas angledefinition,thatactuallycalledanaconst\npredicate on the background. We harmonized it with the overall functioning of the engine. It\nprescribes an angle of a fixed value with a fixed vertex, and it can be realized by aconst if\none uses the intersecting point to describe the pair of lines.\n• lconst. This construction was created as the entry point for length information into the\nengine. Given a point, it creates a new point such that both points form a segment with the\nprescribedlength. Thisisimportantinordertowriteproblemswithinformationonthelength\nof segments and also to allow a way for length information to enter the problem. In classical\ngeometry terms, it is the only way to introduce the scale, or the unitary segment, into the\nproblem.\n3.4.3 Adding New Rules\nIncreasingthenumberofpredicatesanddefinitionsisthewaytoincreasethenumberofgeometric\nproblems the engine can reason about. Such new problems can then be constructed and run,\nbut most likely, no solution will be found since the appropriate rules are missing. In order for\nthese problems to be solved, the reasoning side of the engine itself must be improved, and such\nimprovements can take many forms.\nWe recall that in the original engine, conclusions can be reached by three different paths:\napplication of rules described in the rules.txt file, the running of the algebraic reasoning\nmodule, and resolutions that are made on the go through hard-built, not-described functions,\nthat we called intrinsic rules.\n12\nTheintrinsicruleswerecreatedtooperateactionshumanstendtooverlook,suchasverifying\nthat if a point lies on a line, it can be an argument for the definition of the line, and that gives\nrise to a statement of collinearity or that two perpendicular lines form an angle of 90◦ between\nthem, etc. They exist for expediency and for efficiency of execution in some cases, but results\nfromsuchoperationsdoshowupinproofs,astheyinterferewiththedependencystructure,even\nif they were not mentioned in the original AlphaGeometry paper. Our philosophy towards them\nwas to localize and label them, including mentioning them on the proofs, in order to make their\nusage explicit, but to rely on them as little as possible in terms of reasoning steps.\nThe AR module was not explicitly described in the codebase, in the sense that there was\nno separate list of which facts are turned into equations in the algebraic solver. We altered the\nalgebraic module in the process of inserting new predicates so that they could interact with the\nalgebra operations, see Section 4.4.2.\nTherules.txtfileisthemostexplicitlywrittenpieceofthereasoningengine. Typically,each\nlineofthefilegivesyouatheorem, structuredasasequenceofpredicate-enunciatedhypotheses,\nwhich, if verified for the given proof state, will include the consequence, also predicate-based,\ninto the proof state as well. This set of rules makes up the deductive database (DD) part of the\nengine. In principle, including a new theorem in the database should be as simple as translating\nit into an implication described on statements and writing it into a new line of the file. At first,\nthis was not true because some rules could conflict with the traceback or use predicates that\nwere not finalized. This was fixed by our centralization of the predicates.\nOur first approach towards adding new rules was to try to add new high-level theorems as\nrules (r43-r48, see Appendix A for a list of all rules added), with the hope that this would\nallow the solving of new problems. This looked like a natural extension of the fact that the\nentire DDAR engine operates not on a purely axiomatic basis but by specifying a collection of\ntheorems that can be used.\nHowever, nonewproblemsfromAG-30weresolvedthankstothataddition; althoughwedid\nmanage to simplify some of the other existing proofs, that now could be shortened by appealing\nto the newly added theorems-as-rules.\nAmorefruitfulapproachfocusingonlyontheoremsthatarguablyare“close”toaxioms,was\nachieved by probing DDAR with small, controlled geometry problems regarding various simple\ngeometric facts to see what facts it knew. In this way, we observed that some basic facts about\ncircles (r49 and r50 from Appendix A) were missing. Also, we confirmed that there was no\nconnection between the midpoint predicate and the ratio between the corresponding segments\nbeing 1, which made us include r51. These small facts did prove fruitful in expanding the\n2\ncapabilities of the solver, including in the benchmark of IMO problems, see Section 6.\nSome theorems that one would like to add may not be simple enough to be written with\npredicates of a simpler form, as the ones inherited from DDAR. In that case, more complex\npredicates that are potentially less transparent with regard to exactly what they represent have\nto be designed.\nFor example, the Pythagorean Theorem is a line in the rules file:\nPythagorasPremises a b c => PythagorasConclusions a b c.\nThen, when we are checking and performing the resolution of PythagorasPremise a b c, the\npredicate function automatically finds its suitable premises if they are already in the proof\nstate. For its functioning, as we already check numerically every statement before checking it\nsymbolically to feed the cache (see Subsection 4.4.3), the solver only needs to check whether the\nvalues of the symbols are deducible by the system, but we don’t need to really resolve equations\nto get the values.\n13\n3.4.4 Adding New Equations to AR\n1. Following the reorganization of the code, as outlined in Section 4 on Coder Friendliness, it\nis easy to list all rules for the addition of equations into AR. Equations are added to the\nsystems of equations at the addition of new statements by calling a prep ar method. We\nhave the following instances where that happens:\n• cong A B C D: adds the equation logAB =logCD to the table of ratios.\n• aconst A B C D r: addstheequationd(CD)=d(AB)+r tothetableofangles,where\nr isanyrealnumberthatwillbetaken mod π oncethestatementisaddedtotheproof\nstate, during the DDARN inference loop.\n• lconst A B l: adds the equation logAB = logl to the table of ratios, where l is a\npositive number.\n• eqangle A B C D E F G H: adds the equations d(CD)−d(AB) = d(GH)−d(EF) to\nthe table of angles.\n• eqratio A B C D E F G H: adds logAB −logCD = logEF −logGH to the table of\nratios.\n• para A B C D: adds d(AB)=d(CD) to the table of angles.\n• perp A B C D: adds d(CD)=d(AB)+ π to the table of angles.\n2\nWe note that the original codebase contained separate tables of lengths and ratios. We\nmerged them, which resulted in cleaner code, as detailed in Subsection 4.4.2, and conse-\nquently, only a table of ratios is available, referenced above, which includes all lengths.\nOf this list, the addition of the equations referring to cong statements was moved from\nthe lengths table, used in AlghaGeometry, while the ones referring to aconst and lconst\nstatements are new additions we added to the table of ratios.\n2. Further, it is now easy to add new predicates to the engine given the Predicate class we\nintroduced,seeSubsection4.4.1. This,inturn,allowedustoeasilyaddthepredicatesthat\nallow the Pythagorean theorem to be used by DDARN.\n4 Coder Friendliness\nA significant amount of our time was dedicated to refactoring the codebase of AlphaGeometry\nto make the inner workings of its 16,000-line, highly entangled, complex code easier to work\nwith, to eliminate bugs, and to add low-level functionalities that make the user’s interaction\nwith AlphaGeometry easier, and on which the previous Section 3.4 built.\nWith the exception of the preliminary numerical checking and caching of statements men-\ntioned in Subsection 4.2, this refactoring effort had no direct impact on the reasoning engine.\nEach subsection below sums up the different types of changes and additions we made.\n4.1 Overall Foundational Design\nAlthough we achieved improvements on the reasoning part of the engine, a necessary step to\nmake that possible, and one that took most of the time, was to refactor the original codebase\ninto something more manageable.\nThe first step, and one that brought Newclid to life, was to separate the AlphaGeometry\ncode into two halves. The first contains everything necessary for the software to solve a problem\n14\nthat does not demand auxiliary constructions, i.e., the processing of a problem as well as the\nsymbolicreasoningstructure. Theotherhalfisthecodenecessaryfortheimplementationofthe\nlanguagemodelusedtogenerateauxiliaryconstructions. Thesubsequentlycreatedearlyversion\nof the Newclid codebase could run independently, with the limitation in solvability verified for\nDDARin[Trinhetal.,2024], whiletheLLM’scodebasehadtocallNewclidasalibraryinorder\nto operate.\nThisseparationofthecodenotonlyturnstheLLMandthesymbolicsolverintotwocodebases\nthat can evolve in parallel but also contains all dependency complications from the original\nAlphaGeometry inside the LLM’s codebase, so Newclid could be tested and developed from\nday one. An added benefit of the separate framework between agents and Newclid is that, as\ndependencies of the agent become optional for the running of the engine, it can be made lighter\nto install and run if one only wants to use the reasoning engine, without the addition of new\npoints.\nAfter this first change, there were still many iterations of large refactorings of the Alpha-\nGeometry codebase to increase readability and modularity and hence make improvements and\ndebugging easier. The overall principle was to first find the basic ideas effectively used in the\nfunctioning of the engine, separate them into smaller modules and classes, each with fewer re-\nsponsibilities, and centralize important concepts that were scattered throughout the code.\nTo support the refactoring process, we added several tests. In particular, we have tests for\nall of the most important rules that are used.\n4.2 Agentic Support\nThe reorganization and the modularity we added to the code allow for better communication\nbetweenNewclidandothersoftwarethroughaninterfaceofwhatwecall“agents”,asmentioned\nearlier. As of now, the existing agents are subclasses of the larger DeductiveAgent class inside\nNewclid itself.\nThe currently existing agents are DDARN (which uses breadth-first-search), HumanAgent\n(thatallowshumancontrolofthesolvingprocess), andflemmard(adummyagentthatdoesnot\ntry to apply anything after building the problem, and is good for testing the parts of the code\nbeyond the reasoning), which we explain below.\nWe allow the possibility of adding similar classes that allow LLMs, such as the original\ntransformer model from AlphaGeometry, to operate through an agent.\nIn an agentic setting, important mechanisms are 1) how different agents can interact with\neach other, 2) what each agent observes and what actions it can take.\nWehaveimplementedthisbyexportingthe“proofstate”, carryingalltheinformationabout\nthe statements derived by the reasoning at any given moment (agents also accept the file with\nthe rules as input, in case they have to do derivation themselves).\nTo interact with the proof state, the agent needs to be designed with observation functions,\nwhichcandirectlyaddnewclausestotheproblem,matchatheorem,addorchangeadependency,\nor check a goal. The functions can be customized to access other information about the proof\nstate, such as the current geometrical graphics of the problem and its premises.\nIn terms of code, the HumanAgent is an example of an agent that explores all the function-\nalities of the ProofState class.\nAs shown in Figure 3, the interactions pertain to three parts: the agent, the observation\nfunctions and the proof states. A run loop generates steps where, at each step, the agent can\nmanipulate the proof state by matching rules, adding dependencies, and adding clauses that\ndescribe auxiliary constructions.\n15\nFigure 3: Overview of interactions between different components of Newclid.\n4.3 Improved Visualization and Debugging Capabilities\nOne important contribution to the understanding of the functioning of the code was the visual-\nization of two structures that were implicit and entangled in the original AlphaGeometry code:\nthe symbols graph and the dependency graph. Originally, they were both defined in the single\nGraph class, whose definition span almost 3000 lines of code, making it very difficult to under-\nstand. Also, there were no visualization capabilities built in, so there were no immediate ways\nto generate these graphs.\nAs the name suggests, the dependency graph depicts the dependency structure of the proof,\nnamely what premises were derived, on what other premises they rely on, and what the mecha-\nnismthatallowedforthatderivationis. Itisanand-orgraph,withnodesrepresentingstatements\nanddirectededgesrepresentingdependencies betweenthestatements. Eachdependencycancon-\nsist of potentially multiple, or even zero, incoming statements and one outgoing statement, in\naddition to a reason citing the rule allowing the deduction of the outgoing statement from the\nincoming ones. There are two depictions of the dependency graph: One can see the full depen-\ndency graph, which shows all the dependencies between all the statements that DDARN derives\n(which appears if a solution is not found at all), or one sees the reduced dependency graph, avail-\nable only in case where a problem was solved, where we traverse the full dependency graph and\nexclude any nodes (and corresponding edges) that are not relevant to the found solution, using\nthe traceback.\nLess obvious is the symbols graph, which depicts all the geometric objects created in the\nconstruction of the problem and the development of the proof, and if they are composed of\nsmaller objects, they will be connected to those basic objects.\n16\nFigure4: Adepictionofthereduceddependencygraphcontainingtheproofofasimpleproblem\nsolved by Newclid(see Appendix C for a formal statement of the problem). This reduced graph\nonly shows when a problem can be solved, which allows us to prune the full dependency graph\nof any nodes that did not contribute to the solution of the problem.\nFigure 5: A depiction of what the symbols graph of a small problem that could be solved by\nDDAR in the original AlphaGeometry, with two components, one for angles and one for ratios,\nlookslike(seeAppendixCforaformalstatementoftheproblem). Obtainingthisfigurealready\nrelies on code changes to AlphaGeometry to extract the symbols graph while not exhibiting any\nof the further refactorings we made to the storing of geometric objects.\n17\n4.3.1 Dependency Graph\nThebiggestfeaturethatwasmissingthatweencounteredintheAlphaGeometrycode,wasclear\ndocumentation of the dependency structure: a datastructure that collects the statements and\ntheir dependencies in a proof. Although the original paper by Trinh et al. [2024] mentions the\nneed for a traceback to simplify proofs and to weed out statements that were derived during the\nDDAR loop but that are not necessary for the proof, it does not touch on the complexity of the\nfunctions located throughout the code dedicated to registering and sorting out the dependencies\nof statements generated in the process.\nSuch dependencies are now stored in what is called the Dependency class, and the collection\nof all dependencies forms the (full) dependency graph. A dependency is typically built when a\nstatement is checked symbolically, a rule is applied, or exceptionally when the symbols graph is\nsynthesised by merging lines or circles, which happens when the engine finds out three points\n(which would correspond to three lines in the symbols graph), are actually collinear. It consists\nof a justification (such as the name of the rule), its premises and a conclusion. Also, when a\ndependencyisaddedtothedependencygraph,afunctionrelatedtotheconclusionpredicatecan\nbe triggered, and the inner states of the AR module and the symbols graph can be modified.\n4.3.2 Symbols Graph\nInitially, the symbols graph contained many kinds of objects: points, segments, directions, an-\ngles, ratios, measurements of angles, values of ratios, the numerical value of those measures, and\ncircles. This myriad of classes of geometric objects was necessary because many implicit deriva-\ntions of facts took place through identifications of nodes on the symbols graph. In our work, we\nmoved a big part of the reasoning responsibilities of the symbols graph, namely the ones involv-\ning congruences of measures, to the AR module, and some others were given to explicit rules.\nFor DDARN, the cleaned-up symbols graph only stores points, lines, and circles, and the only\nreasoningitcarriesconcernsdetectingandstoringwhennewpointsarefoundinalreadyexisting\nlines and circles (i.e. collinearity and concyclicity). It should be stressed that such identification\nis only accepted by the engine if there is a symbolic justification for it, the numeric recognition\nthat a point lies on a given line on circle is not enough for the registering of that information in\nthe symbols graph.\n4.3.3 Using the Graphs\nVisualizing this information in these graphs and inspecting them had important consequences.\nIt turned out that they are one of the most comprehensive visual depictions one can have of the\nreasoning of the engine, to the point that we found out that the original s angle definition was\nprocessed through a hidden, not entirely functional, aconst predicate because that dependency\nsurprisingly showed up in dependency graphs (but not in the proof).\nBoth the symbols graph and the dependency graph were crucial concepts to understand the\nunderlying structure of the reasoning beyond the information contained in generated proofs. In\naddition,havingthesevisualizationtoolsthatcontainalotmoreinformationonthereasoningof\nthe engine than the proofs was crucial for debugging, as it pointed us to incorrect or superfluous\nconnections that were made by the engine. This information, in turn, made it possible to make\nvarious additions to fix these problems.\n18\nFigure6: Thewidthateverydepthofthedependencygraphs,withlevelsorderedfromstatements\nthat are closer to the goal in the proof, for all the 15 problems in the imo ag 30 benchmark that\ncan be solved by Newclid’s DDARN module (with breadth-first-search).\n19\nFigure7: TheDDARNsymbolsgraphofthesameproblemasinFigure5,generatedbyNewclid.\nThe essential relationships present in the problem can be easily read from the symbols graph.\n4.4 Reasoning Engine Improvements\nTheguidingprincipleofDDARwastobeabletoapplytheoremstoaprobleminabreadth-first\nsearch (BFS). To execute this idea, a series of technical challenges have arisen regarding how to\nstructure and store the mathematical information and how to implement the search. A big part\nof our effort focused on creating good, flexible code structures that could execute the breadth-\nfirst strategy that DDARN employs in a better way than AlphaGeometry. In order to do so, we\nimplemented and modified the structures described below.\n4.4.1 Predicates\nOne major step in giving the code flexibility was to create the Predicate class and to organize\nthe most fundamental reasoning terminology of Newclid as a collection of subclasses, with a\nstructurethatcanbeexpandedifneededandeasilymodified. Predicatesaremorecomplexthan\ndefinitions, so a Predicate class is more complex than a definition statement on the defs.txt\nfile, but the philosophy we followed was that the former should be as easily found and modified\nas the latter.\nA Predicate class contains methods to:\n• Put the arguments of the predicate in a canonical order (preparse).\n• Parse its arguments from strings to geometrical points (parse).\n• Find a dependency structure that can justify the existence of that predicate and do the sym-\nbolic check (why, add).\n• Checknumericallyforthevalidityofthatpredicate,dothenumericalcheck(check numerical).\n• Process the representation of that predicate when writing the proof, generating diagrams, or\nreceiving and passing information to the LLM (pretty).\n20\nThis list is typical but not exhaustive, as some predicates may demand extra processing\nfunctions in the background.\nFor example, in order to apply Pythagoras’ theorem, as can be seen in the rules.txt file\npertaining to this example, two predicates were created, PythagoreanPremises to represent the\npremises (the presence of a right-angled triangle), and PythagoreanConclusions to represent\nthe conclusion (the sum of the squares of the legs). The PythagorasConclusions predicate has\namethodtoextractthedistanceofthemissingsideofthetriangle(iftherearetwoknownsides)\nnumerically and add the corresponding lconst statement to the proof state, avoiding the need\nfor manipulating an equation. This method, of course, does not have an equivalent in other\npredicates, but the fact that predicates are classes adds this flexibility to their definition while\nkeeping all clauses needed in one place.\n4.4.2 Algebra Reasoning\nOneofthemaincontributionsoftheauthorsof[Trinhetal.,2024]tothedevelopmentofageom-\netry reasoning engine was the addition of the algebraic reasoning module (AR) in tandem with\nthe deductive database (DD) resulting in the DDAR solver, that increases the range of state-\nmentsfoundcomparedtoDD.ARisasymbolicengineforcheckingandgettingthejustification\nof statements based on an internal set of linear equations.\nThe original engine was built on three sets of linear equations, called tables: one storing\ninformation about angles, one storing information about ratios, and one storing information\n(cid:80)\nabout lengths. Each internal linear equation is of the form y = q x +constant, where only\ni i\nthe q ’s are stored explicitly. When a new equation is given, it is simplified so that it contains\ni\nonlyfreevariablesontheright-handside,withonevariable,y,todependonothers, ifnecessary.\n(cid:80)\nThe goal of the AR module is to find new equations of the form b x = Constant, corre-\ni i\nsponding to new predicates not present in the previous equations. This involves resolving the\ndependency structure of the predicate found to minimize proofs at the time of the traceback.\nDifferent procedures are applied at each of those stages.\nTo find the new statements, as described in the original work by [Trinh et al., 2024], the\nengine applies Gaussian elimination at each table, a process that can result in a new statement\nor not. Each table stores information about all occurrences of predicates feeding it, but not\nall of them necessarily relate to the new statement found. Once a goal is found, to weed out\nunrelated statements in the table, the engine uses linear programming techniques to find the\nminimal system that satisfies the new statement, aiming at a shorter proof.\nAll those procedures are part of AlphaGeometry. In order to have a clearer algebraic module\nthatiseasiertounderstandandmodifyandthatismorerobustagainstmistakes,wemademinor\nchanges.\nThe most notable one was the removal of the length table. The lengths of segments were\nargumentsinboththetableoflengthsandtheoneofratios(inthiscase,ratiosarelinearizedby\nthe application of logarithms as described in [Trinh et al., 2024]). The table of lengths, though,\nhad only simple information about the equality of segment lengths, information that we easily\nincorporatedintothetableofratioswithoutfurthernegativeconsequences,reducingthenumber\nof tables to two.\nAs this table now has to deal with information on constant lengths, but the entries are log-\narithms of lengths for the linearization of ratios, we end up having to deal with the logarithms\nof constants. To minimize numerical instabilities and simplify symbolic manipulations, instead\nof storing those throughout the Gaussian elimination process, we retrieve them through nu-\nmerical checks whenever the proof state has dependencies supporting the corresponding lconst\nstatements(see Subsection 3.4.4).\n21\n4.4.3 Matching\nAtfirstlook, aBFSsearchforanautomatictheoremprovermaylookascostlyasthenumberof\ntheoremsithastogothroughwhileperformingthesearch. OurexperiencewithAlphaGeometry\nshows that this is only part of the story. In fact, the process of using theorems can be separated\ninto one that matches the theorem, that is, looks for arguments to fit the predicates in the\nhypothesis of the theorem, and one that applies the theorem generating a new statement from\nthe theorem’s conclusion. The matching is the combinatorially expensive step of the process,\nand it can make some theorems consume significantly more resources than others.\nGenerally, to reduce the amount of resources needed for running a loop in a symbolic solver\nthat is responsible for the application of theorems, one could either improve the search strategy,\nwhich has been done, for example, by the use of reinforcement learning and Monte Carlo tree-\nsearch in unrelated earlier work, e.g. by Lample et al. [2022], but this is a more difficult task.\nA different strategy that is more easily implemented is to reduce the space of possible mappings\nfor the theorems.\nWe implemented the latter strategy in two ways. First, we implemented a matching cache.\nThe idea here is that the matching only takes into account real statements, instead of all com-\nbinations of arguments present in the problem, by numerically checking all possibly matched\nstatements and caching the true ones in the disk at the beginning of the problem. This way,\nthe full cost of matching is concentrated at the beginning of the process of solving the problem\nfor the first time, which makes the time spent in the BFS loop itself really short. This reduces\nthe overall time to solve a problem by a bit, and makes debugging and improving the code a lot\nfaster, even if one tests features on large theorems, as the matching time for building the cache\nis only spent in the first iteration of the problem.\nAnother strategy we used for reducing the time spent in matching was to reorder the state-\nmentsinthehypothesisoftheoremsintherules.txtfileinsuchawaythatthefirststatements\nare the ones with fewer arguments. The guiding principle was: if the rule checking is going to\nfail, we want it to fail faster, i.e. without checking all the premises. We thus put the premises\nwithfewerargumentsaheadinthecheckingloop,astheseareresolvedfaster. Thus,timedoesn’t\nneed to be spent on the remaining premises with more arguments, which take longer to resolve.\nThisway,failuresoftheoremshappenfaster,savingunnecessarytimespentonslowermatch-\ning statements with more arguments. This also has the advantage of being easily tested, as one\ncan perform experiments simply by generating an alternative rules.txt file. Testing a reorga-\nnization of the rules’ hypothesis against the imo ag 30 benchmark shows a reduction of a little\nmore than 10% on those problems, see Figure 8.\n5 Reproducibility\nFor a third-party checking of the experimental results presented in [Trinh et al., 2024], given the\nnatureofthesoftware, therearetwodifferentaspectstobeconsidered: ononehand, oneshould\nbe able to run the problems on AlphaGeometry’s code in order to get the same outcomes, on\ntheotherhand,someonewiththepropermathematicalknowledgeshouldbeabletoknowwhich\nsteps were taken by the engine and verify if the proof written was mathematically correct. We\nidentifiedissuesinAlphaGeometry(andDDARspecifically, sincetheLLMissecondarytothese\nissues) regarding both aspects and tried to introduce improvements in both the possibility of\nreproducing results and verifying their soundness. We elaborate on these below and highlight\nhow the new additions made in previous sections aid reproducibility.\nWhenitcomestounderstandingandverifyingproofs,DDARpresentedsomeissues. Themost\nvisible one was that some proof steps were presented without justification; that is, the recorded\n22\n(a) Percentage distribution of time spent on matching predicates with rules written in the old order,\nwith a clear prevalence of time spent on the costly eqratio and eqangle predicates.\n(b) Percentage distribution of time spent on matching predicates with rules written in the new order,\nwith more time spent on the quicker same clock predicate.\nFigure 8: The profiling of the level of functions where the matching of predicates occurs in the\ncode, for the problems in the imo ag 30 benchmark. It clearly shows that most of the time is\nspent on matching specific predicates, which do not depend on the nature of the problem. More\ntime spent on quicker predicates, as can be seen at the bottom, results in a shorter overall time\nfor solving problems.\n23\nproofs did not explicitly state which rules justified each implication. While it is true that it is\ncommon in mathematics that arguments are sometimes presented with little to no justification,\nassuming the reader can complete the argument with previous knowledge, an automatic prover\nhastosatisfyahigherlevelofrigourbecauseitmakesithardtounderstandtheinnerworkingsof\na symbolic engine (and therefore to anticipate potential weaknesses) from proof trace inspection\nif there are gaps. In the case of DDAR, this issue is even deeper, as some steps in the proof use\nintrinsic rules, which are not made explicit anywhere.\nOne of our first tasks was to try to fill this gap (which led us to uncover the dependency\nstructure of proofs, mentioned in Subsection 4.3.1). We were only able to have fully descriptive\nproofs once we rebuilt the dependency graph of the problems, with full control of how depen-\ndencies, inparticulartheonesgeneratedinthebackground, weretransmittedtostatements. By\ncontrast, in DDARN a user can fully evaluate the statements derived at each step and decide if\nany given step is sound or not.\nA more subtle issue we found when trying to run problems with DDAR at different times\nwas that the proofs written are not deterministic; that is, proofs change between iterations even\nwithout changes in the parameters. (We emphasize that this happens in DDAR alone, even\nwhere proofs are carried out without the intervention of the LLM, which naturally introduces\nnondeterminism.) Investigating this unexpected phenomenon, we found that the assignment of\ncoordinatestopointsduringthebuildingoftheproblemcontainedrandomness,andthatseemed\ntobetheonlysourceofrandomnessintheDDARpipeline. Inprinciple,thisrandomnessshould\nnotchangethesymbolicnatureoftheproofstate. However,inpractice,itcanalterthepredicates\nthatareobtainedfromnumericalchecksofthediagrambuiltattheinstantiationoftheproblem.\nIn particular, it can generally, with a 50% chance, change the orientation of triangles.\nNow, therewasnoexplicitconditionontheorientationofverticesoftrianglestobefoundon\nthe rules or to be identified as a predicate. However, when checking conditions for the similarity\nand congruence of triangles, because of the use of the concept of total angles in DDAR, the\norientationofverticesoftrianglesisrelevant. Indeed,hiddeninsidethespecifictheoremmatching\nfunctions,onecouldfindchecksfortheorientationofverticesofthetrianglesbeingcompared(see\nthe same clock functions, which turn these hidden functions in explicit predicates, mentioned\nin Subsection 3.4.1), and those influenced the final shape of the proofs.\nIn more extreme cases, for example, in the proof of Problem 2 of the IMO 2009 exam, given\nin the Supplementary Material to the AlphaGeometry paper Trinh et al. [2024], page 29-30, the\nvery correctness of the proof depends on a choice made at random by the software. Specifically,\none of the auxiliary points described there, D, is given by the intersection of two circles. Now,\na pair of circles intersect at two points, and in that case, the solver makes the choice of which\npoint to use at random (without making it explicit). It so happens that one can find errors in\nthe written proof if the point not chosen (but that also satisfies the defining conditions of D)\nwere to be considered by the AlphaGeometry software: In that case, the statement proved in\nstep 11 of the proof (∠MLK = ∠DML) is false if one considers full angles, and the statement\nproved in step 15 (∠(LD,CO) = ∠QBO) is false under any formal definition of angles. Thus,\nthe proof in the Supplementary Material, as written, must have been arrived at from the choice\nof the correct point in the intersection of the circles, although this fact is not explicitly noted.\nTo address those issues, we took extra care to make every step explicit. First, we added\nthe mentioned same clock predicate as a numerically checked predicate and enunciated it as a\nhypothesison therulesconcerning thesimilarity andcongruenceof triangles. Asaconsequence,\nthe proof will explicitly show the choice made and the use of facts about the orientation of the\nvertices of the triangle in the proof.\nIndeed, combining that with the functionality we added for checking multiple goals, one\ncan steer the random choices of the orientation of triangles in the problem, and doing that for\n24\nProblem 2 of the 2009 IMO exam, one can verify that DDAR would not have been able to find\na solution for the problem with the other different choice of D, even if both provide the same\nstatements to the proof state by the prescribed auxiliary point.\nSeparately,tocontroltherandomnessoftheengine,weintroducedaseedthatcancontrolthe\nrandomchoicesofNewclid,whichmustbedonecarefully. Therandomizationoftheprescription\nof coordinates to points is not a trivial aspect of the building of a problem. In fact, every time\ncoordinates are prescribed in the construction of a numerical representation of the problem, the\nengine will check the correctness of the goals, and if a goal is not numerically true, the software\nwill scrap the coordinates and try to assign new ones. This can be repeated a finite number\nof times before Newclid gives up (this is currently set to be repeated 10000 times, but it only\nmatters that it is a sufficiently large number), in contrast to the original version of the software\nthatusedawhileloop,riskingapotentiallyinfiniteloopforproblemsthathadfalsegoals. This\nisimportantnotonlyasasanitycheckbutalsobecausesomeassumptionsneededforaproblem\nare not contemplated by the language available to Newclid, for example, an open constraint on\nthe relative sides of two segments or the fact that a point is internal or external to a triangle. If\nthe space of points satisfying those conditions has a positive measure in the space of all possible\nconfigurations within the random choices of the problem, the good configuration can be reached\nrandomly, given sufficiently many tries, and that is what the randomization allows. Of course,\nfor testing, it is useful to be able to fix a good seed and have better control of the problem.\n6 The 5 Missing Problems From imo ag 30.txt\nInAlphaGeometrypaperbyTrinhetal.[2024],theauthorscompileacollectionof30problemsin\ntheAlphaGeometryformatfrom27uniqueproblemsfromtheIMOexamsbetween2000and2022\n(thelastofficiallyreleasedexambeforethewritingofthepaper). Thethreeremainingproblems\narise from splitting three of the problems in the set of 27 problems into two problems. From\nthose, the (original) DDAR engine solved 14/30 problems, while the full AlphaGeometry (i.e.,\nDDARandtheLLMworkingintandem)atfullcomputingcapacitycouldsolve25/30problems.\nTheadaptationsandsolutionstothose30problemsarecollectedintheSupplementaryMaterial\nof [Trinh et al., 2024], their formulation into the language used by AlphaGeometry is contained\nin the file imo ag 30.txt of the original AlphaGeometry codebase on GitHub.\nStudying the five problems that AlphaGeometry was not able to solve (2008 P1B, 2008 P6,\n2011 P6, 2019 P2, and 2021 P3) is instructive and provides insights regarding the capabilities\nand limitations of AlphaGeometry both as a concrete software, with its technical and specific\ndesignlimitations,andasanoverallprojectofacoordinateagnosticautomaticreasoningsystem.\nBelow, we discuss each of these five problems, highlight what was missing for the engine to\nsolve them, or the reason for their non-solvability when that is the case.\nOneshouldkeepinmindthatthereisalevelofstochasticityintheanalysisofwhyproblems\nfail,asonecanonlyspeculateontheprecisereasonsaprobability-basedmachinesuchasanLLM\ntakes a specific path in comparison to another one. Also, the axiomatic reasoning developed by\nDDAR, which is also incorporated in DDARN, despite being deterministic in principle, is highly\nsensitive to changes in the formulation of problems and rules, so it is to be expected that other\nmodificationsdifferentfromtheonesweproposedcanhavethesamepositiveoutcomeasaresult.\nProblem2fromIMO2019isalreadydiscussedintheExtendedData,Figure4,oftheoriginal\npaper, so it is briefly mentioned here for completeness only.\n25\n6.1 IMO 2008 P1B\nProblem (Original Formulation of P1 2008 (Evan Chen’s Solution Notes)). Let H be the or-\nthocenter of the acute-angled triangle ABC. The circle Γ centered at the midpoint of BC and\nA\npassing through H intersects the sideline BC at points A and A . Similarly, define the points\n1 2\nB , B , C , and C . Prove that six points A , A , B , B , C , C are concyclic.\n1 2 1 2 1 2 1 2 1 2\nExplanation of our translation of P1 2008 (with auxiliary points in red): Consider\nthe triangle ABC, and that also\n• H is the orthocenter of ABC.\n• D is the midpoint of BC.\n• E is the midpoint of AC.\n• F is the midpoint of AB.\n• A is the first intersection of the circle of center D through H and line BC.\n1\n• A is the second intersection of the circle of center D through H and line BC.\n2\n• B is the first intersection of the circle of center E through H and line AC.\n1\n• B is the second intersection of the circle of center E through H and line AC.\n2\n• C is the first intersection of the circle of center F through H and line AB.\n1\n• C is the second intersection of the circle of center F through H and line AB.\n2\n• O is the point on the line perpendicular to EF, through H, such that the distance from E\n1\nto O is the distance from E to H (the reflection of H across the line EF).\n1\n• O is the point on the line perpendicular to ED, through H, such that the distance from E\n2\nto O is the distance from E to H (the reflection of H across the line ED).\n2\n• O is the point on the line perpendicular to FD, through H, such that the distance from F\n3\nto O is the distance from F to H (the reflection of H across the line FD).\n3\n• O is the center of the circle through C , C , and B .\n1 2 1\nThen, prove that A , A , B , B , C , C are concyclic.\n1 2 1 2 1 2\nFormal translation of our problem:\na b c = triangle a b c;\nh = orthocenter h a b c;\nd = midpoint d b c;\ne = midpoint e a c;\nf = midpoint f a b;\na1 = on circle a1 d h, on line a1 b c;\na2 = on circle a2 d h, on line a2 b c;\nb1 = on circle b1 e h, on line b1 c a;\nb2 = on circle b2 e h, on line b2 c a;\nc1 = on circle c1 f h, on line c1 a b;\nc2 = on circle c2 f h, on line c2 a b;\n26\nFigure 9: Diagram for the statement of Problem 1 of the IMO 2008 exam.\no1 = eqdistance o1 e e h, on tline o1 h e f;\no2 = eqdistance o2 e e h, on tline o2 h e d;\no3 = eqdistance o3 f f h, on tline o3 h f d;\no = circle o c1 c2 b1 ? cyclic c1 c2 b1 b2 a1 a2\nDiscussion: Problem 1 of the 2008 IMO exam asked to prove that a collection of six points\n(A , A , B , B , C , and C in the original formulation) lied in the same circle. In terms of the\n1 2 1 2 1 2\ninternal language of AlphaGeometry, that should be expressed by a cyclic predicate.\nIn the original formulation by Trinh et al. [2024], problem 1 from the 2008 IMO exam was\nsplit into two problems, one asking for cyclic B1 B2 C1 C2 (2008 P1A) and the other asking\nfor cyclic C1 C2 B1 A1 (2008 P1B), choice that was probably motivated by the fact that the\n“natural” presentation of the cyclic predicate has four arguments, as any triple of points in\ngeneral position determines a circle. In case both problems were solved, still some human vision\nwould be needed to understand that proving both facts is enough for the complete problem, as\nthey cover the two possible configurations of quadruples of points distributed pairwise on the\nsides of a triangle. So the full problem could be proven “analogously”. Of course, a larger issue\nis that AlphaGeometry was only able to solve P1A, but not P1B.\nTryingtounderstandwhatAlphaGeometrymissedforthisproblem,thefirstthingtoobserve\nis that cyclic is a predicate that accepts any list of points, so one can straight away ask for\ncyclic A1 A2 B1 B2 C1 C2 as a goal in the formulation, without the need to split the problem\nintwo. Ofcourse,asAlphaGeometrycouldnotsolveP1B,itcannotsolvetheunifiedformulation\n27\neither, even if provided via a new clause with the additional clauses that allowed the solution of\nP1A.\nBut observing the clause suggestedfor the proof of P1A, wecanget a good outline of how to\nproceedinsolvingthisproblem: P1AwassolvedbyaddingthepointO (O inourformulation),\n1\nthe reflection of the orthocenter H of the triangle by a line connecting midpoints E and F of\nsides AC and AB, respectively. Those are exactly the sides where points B1, B2, C1, and C2,\nmentioned in the goal of P1A, lie. One way to prove that all the points mentioned lie in a single\ncyclewouldbetoreproveP1Aforthethreepairsofadjacentsidesofthetriangleandthenshow\nthat all the circles found are the same.\nWith this in mind, we prescribed O1, O2, and O3, the reflections of H along the three lines\nconnectingmidpointsofsidesofthetriangle,extendingthesuggestiongivenforP1A.Thisproved\nnot to be enough for DDARN to prove all six points lie on the same circle, so we also added O,\nthe center of the circle through C1, C2, and B1 (and the common center to all circles already\ndetected by the solver analogously to P1A). Then DDARN could find a solution to the problem.\nThe existence of this solution suggests a better understanding both of the behaviour of the\nLLMandofthelimitationsoftheoriginalrulesofDDAR.FortheLLM,itisplausibletoassume\nthat, as it did find a good clause O for 2008 P1A in the original run described in [Trinh et al.,\n2024], it could propose O1, O2, and O3 in our construction, as they all play the same role, up\nto a cyclic permutation of the sides of the triangle. The problem, of course, is that there is\nno evidence that the LLM can profit from such symmetry of points, so it would need to repeat\nwhateverreasoningbroughtitO thrice,demandingtripleresources. Thisdoesnotmeanitcould\ndecidetosuggestour O,thecenterofthecircleaskedinthegoal,althoughthatisalsoanatural\npointtosuggest. Simplymakingallthosedecisionswoulddemandtoomuchdepthinthesearch.\nOn the other hand, we did try to run our new formulation of 2008 P1 with the original set of\nrules from DDAR, and it still exhausted the DDAR search without finding a proof. Reviewing\nour proof, on the other hand, reveals the use of rules r49 and r50 (the need for rule r50, in\nfact,wasdetectedbystudyingthisveryproblem);seeAppendixA.Thosetworulescontainvery\nsimple facts about circles: that points lying on the same circle are equidistant from the center\nandthattheintersectionoftheperpendicularbisectorsofnon-parallelchordsofacirclehappens\nat its center. Nonetheless, those facts were unknown to the original DDAR formulation, and\ntheir addition is necessary for the solution of some problems involving circumferences and cyclic\npoints, such as 2008 P1.\nA full output of the solution of Newclid for this problem can be found in Appendix B.\n6.2 IMO 2008 P6\nProblem (Original Formulation of P6 2008 (Evan Chen’s Solution Notes)). Let ABCD be a\nconvex quadrilateral with BA ̸= BC. Denote the incircles of triangles ABC and ADC by ω\n1\nand ω respectively. Suppose that there exists a circle ω tangent to ray BA beyond A and to\n2\nthe ray BC beyond C, which is also tangent to the lines AD and CD. Prove that the common\nexternal tangents to ω and ω intersect on ω.\n1 2\nExplanation of AlphaGeometry’s translation of P6 2008: Consider the triangle XYZ\nwith prescribed coordinates (they will determine the circle ω), and also that\n• O is the center of the circle through X, Y, and Z.\n• W is a point on the circle with center O through X, with prescribed coordinates.\n• A is the intersection of the line perpendicular to OZ at Z with the line perpendicular to OX\nat X (so AZ is tangent to ω at Z and AX is tangent to ω at X).\n28\n• B is the intersection of the line perpendicular to OZ at Z with the line perpendicular to OW\nat W.\n• C is the intersection of the line perpendicular to OY at Y with the line perpendicular to OW\nat W.\n• D is the intersection of the line perpendicular to OX at X and the line perpendicular to OY\nat Y.\n• I is the incenter of the triangle ABC.\n1\n• I is the incenter of the triangle ACD.\n2\n• F is the orthogonal projection of I onto the side AC (so ω has center I and goes through\n1 1 1 1\nF ).\n1\n• F is the orthogonal projection of I onto the side AC (so ω has center I and goes through\n2 2 2 2\nF ).\n2\n• Q is the point of tangency to the circle ω and T is the point of tangent to the circle ω of a\n1 2\ncommon tangent to both cicles.\n• P is the point of tangency to the circle ω and S is the point of tangency to the circle ω of a\n1 2\ncommon tangent to both circles.\n• K is the intersection of lines QT and PS.\nThen, prove that OK =OX.\nFormal translation of the problem:\nx@4.96 −0.13 y@−1.0068968328888160 −1.2534881080682770\nz@−2.8402847238575120 −4.9117762734006830 = triangle x y z;\no = circle o x y z;\nw@6.9090049230038776 −1.3884003936987552 = on circle w o x;\na = on tline a z o z, on tline a x o x;\nb = on tline b z o z, on tline b w o w;\nc = on tline c y o y, on tline c w o w;\nd = on tline d x o x, on tline d y o y;\ni1 = incenter i1 a b c;\ni2 = incenter i2 a c d;\nf1 = foot f1 i1 a c;\nf2 = foot f2 i2 a c;\nq t p s = cc tangent q t p s i1 f1 i2 f2;\nk = on line k q t, on line k p s ? cong o k o x\nDiscussion: Problem6ofthe2008IMOexamisanexampleofaproblemwhere, fortechnical\nreasons, not all the premises given in the problem can be well described by the symbolic system\nused in DDAR, and that results in anambiguity that cannotbe solved within the design choices\nof the pseudo-axiomatic system used by AlphaGeometry, and there is no simple way to fix those\nlimitations.\nTheproblempresentstwocircles,W1andW2,andaskssomethingaboutK,theintersection\nof the common external tangents to W1 and W2 specifically, that it lies on a third circle W.\n29\nFigure 10: Diagram for the statement of Problem 6 of the IMO 2008 exam.\n30\nThe issue here is that there are four common tangents to the pair of circles, which results in 6\nintersections of pairs of common tangents to the circles. Of those, only one of them lies on W.\nFor a human, it is not hard to make this distinction and find good arguments that fit the\ncorrectdrawingandthatleadtowardsproof. Butthisinvolvesacollectionofunsaidassumptions\naboutthatspecificpairoflinesthatarenotavailableforthecomputer. Eveniftheconstruction\ncreated in AlphaGeometry to represent a situation like this (definition cc tangent) generates a\nbackground coordinate representation of the problem that effectively assumes the choice of the\nexternal tangents, there is no symbolical information in terms of predicates that separates the\n“good”choiceofthepairoftangentsfromthe“bad”choices. Inpracticalterms,thismeansthat\nif we could write a proof for this problem, each step of it would apply as well to the other five\npoints that are intersections of common tangents to W1 and W2. But those do not lie in W,\nand the proof would be false.\nTryingtoupdatethefoundationstoencompassasolutionforthisproblemwouldinvolvefirst\ncreatingpredicatesthatwouldallowthedistinctionbetweenthedifferentlineconfigurationsand\nthen assuring that we have a powerful set of deduction rules that allows for consequences of\nsuch predicates to be derived up to the desired results. As the current version of both DDAR\nand DDARN are not equipped to prescribe and recognize in-betweenness, we envision it will be\ndifficult to devise an axiomatic system that could deal with this problem.\nAs it remains now, 2008 P6 is a case of undecidability of DDAR as well as DDARN.\n6.3 IMO 2011 P6\nProblem (Original Formulation of P6 2011 (IMO Shortlist File - G8)). Let ABC be an acute\ntrianglewithcircumcircleω. Lettbeatangentlinetoω. Lett , t , andt bethelinesobtained\na b c\nby reflecting t in the lines BC, CA, and AB, respectively. Show that the circumcircle of the\ntriangle determined by the lines t , t , and t is tangent to the circle ω.\na b c\nExplanation of AlphaGeometry’s translation of P6 2011: Consider triangle ABC, and\nalso that\n• O is the circumcenter of ABC.\n• P is a point on the circle centered in O through A.\n• Q is a point on the line perpendicular to OP at P (the tangent line to the circle centered at\nO at P). So the line PQ is t.\n• P is the image of P reflected through BC.\na\n• P is the image of P reflected through CA.\nb\n• P is the image of P reflected through AB.\nc\n• Q is the image of Q reflected through BC (so the line P Q is t ).\na a a a\n• Q is the image of Q reflected through CA (so the line P Q is t ).\nb b b b\n• Q is the image of Q reflected through AB (so the line P Q is t ).\nc c c c\n• A is the intersection of t and t .\n1 b c\n• B is the intersection of t and t .\n1 b c\n31\n• C is the intersection of t and t .\n1 a b\n• O is the circumcenter of A B C .\n1 1 1 1\n• X is a point in the intersection of the circles of center O through A and of center O through\n1\nA .\n1\nThen, prove that X, O, and O are collinear (if the centers of two circles and an intersection\n1\npoint of theirs are collinear, the intersection point is a tangency point of the pair of circles).\nFormal translation of our problem:\na b c = triangle a b c;\no = circle o a b c;\np = on circle p o a;\nq = on tline q p o p;\npa = reflect pa p b c;\npb = reflect pb p c a;\npc = reflect pc p a b;\nqa = reflect qa q b c;\nqb = reflect qb q c a;\nqc = reflect qc q a b;\na1 = on line a1 pb qb, on line a1 pc qc;\nb1 = on line b1 pa qa, on line b1 pc qc;\nc1 = on line c1 pa qa, on line c1 pb qb;\no1 = circle o1 a1 b1 c1;\nx = on circle x o a, on circle x o1 a1 ? coll x o o1\nDiscussion: After many attempts to solve this problem through the addition of extra points,\nnoclearcandidateforanewminorfixoftheengineprovedtobeasolution. Neitherthereseems\nto be a good reason for it to be undecidable. The only commentary that can be made after a\nlongeffortisthatthereseemstobealackoflinksbetweentheinformationassociatedwithpoint\nX, defined as the intersection of the two circumcircles, and the rest of the problem.\nIn fact, the proof suggested in the 2011 IMO shortlist file, see [Smit et al., 2011], uses the\ndefinition of an alternative point, for example, a point K, the intersection of another pair of\ncircles, and proceeds to prove K =X. This is essentially a proof by contradiction (two distinct\npointsexistthenprovethattheyarethesame),aschemethatisnotavailableforAlphaGeometry\nfor two reasons: first, there are checks to prevent the instantiation of two overlapping points,\nand second, there is no set of axioms that can perform a logical chain ending in “two points are\nthe same”. It is not impossible to imagine that adaptations could be made to Newclid to allow\nthis sort of argument, but that would take us too far from the scope chosen for this project.\n6.4 IMO 2019 P2\nThis problem had a solution presented in the original paper [Trinh et al., 2024], given by the\nmanual provision of three extra points (which the LLM module could not find), after which the\noriginal formulation of DDAR can write a proof.\nThehuman-aidedsolutiontothisproblemwasprovidedbytheauthorsintheirSupplementary\nMaterial, and a conjecture on why the transformer could not detect the suggested points in the\nExtended Data Fig. 4 of the original paper.\n32\nFigure 11: Diagram for the statement of Problem 6 of the IMO 2011 exam.\n6.5 IMO 2021 P3\nProblem (OriginalFormulationofP32021(EvanChen’sSolutionNotes)). LetDbeaninterior\npoint of the acute triangle ABC with AB >AC so that ∠DAB =∠CAD. The point E on the\nsegment AC satisfies ∠FDA = ∠DBC, and the point X on the line AC satisfies CX = BX.\nLet O and O be the circumcenters of the triangles ADC and EXD, respectively. Prove that\n1 2\nthe lines BC, EF, and O O are concurrent.\n1 2\nExplanation of AlphaGeometry’s translation of P3 2021: Consider triangle ABC, and\nalso\n• D a point in the bisector of angle ∠BAC.\n• E a point on line AC such that ∠EDA=∠DCB.\n• F a point on line AB such that ∠FDA=∠DBC.\n• X a point on the intersection of the bisector of segment BC with line AC.\n• O the center of the circle through A, D, and C.\n1\n• O the center of the circle through E, X, and D.\n2\n• Y the intersection of lines EF and BC.\nThen, prove that O , O , and Y are collinear.\n1 2\n33\nFigure 12: Diagram for the statement of Problem 3 of the IMO 2021 exam.\nFormal translation of the problem:\na b c = triangle a b c;\nd = angle bisector b a c;\ne = on aline d a d c b, on line a c;\nf = on aline d a d b c, on line a b;\nx = on bline b c, on line a c;\no1 = circle a d c;\no2 = circle e x d;\ny = on line e f, on line b c ? coll o1 o2 y\nDiscussion: This problem, as 2008 P6, presents a premise that cannot be expressed by Al-\nphaGeometry’s engine, namely that point D is interior to the triangle. In general, those kinds\nof open premises on geometry problems are usually associated with non-degeneracy conditions\nfor the construction of the points of the problem, a situation AlphaGeometry can handle by cre-\nating an explicit instance of the problem before starting the solution and checking numerically\nfor the expected goal. If it fails at that point, it will try again with some random variation\nwithin its degrees of freedom in the hope that, eventually, it will find a good regime for the con-\nstruction. Another possible reason for adding open conditions is to avoid a multiplicity of cases\nthat would take too much unnecessary time for the person solving the problem, a consideration\nAlphaGeometry does not have to deal with.\nThe case of problem 3 of the 2021 IMO exam is different. Here, if the non-degeneracy\nconditionisviolated,wedonothavetheconstructionbreakingdown,butrather,ifD isexternal\nto ABC, the goal becomes false, while all the conditions of the problem remain in place. This\nmeans AlphaGeometry will be able to build an instance of the problem and try to proceed\nto the proof, but as in the case of problem 2008 P6, there is no symbolic difference within\nAlphaGeometry’s symbolic engine between the regime where the goal of the problem is true\n34\nand where it is false. As a consequence, if a proof were written down for the regime where the\nproblem is true, it would also hold for the regime where the problem is false, hence it would be\nincorrect. It is also a case of undecidability of the axiomatic system.\nAgain, to be able to handle such problems is not simply a matter of designing definitions\nthat allow the insertion of information like “D internal to ABC” into the engine. A whole\ncollection of deduction rules must be developed to allow the consequences of that information to\nbe transmitted through the reasoning.\n7 Limitations and Future Work\nGeoGebra input ThereareacoupleofdrawbacksrelatedtousingtheGeoGebraconstructor.\nFirst, one has to understand how to perform the geometric construction of the problem with\nastraightedgeandcompasssense. Nonetheless,thisisalsooftenthecasewhenwritingproblems\nin formal language, as the order of the points constructed often has to be coherent with the\ngeometric dependency of some points on others.\nSecond, because of the flexibility of calling all numerical tools available to Python when\nwriting a definition, there is a greater flexibility of definitions when proposing a problem with\nthe formal language when compared to the closed set of tools available in GeoGebra. That\nsaid, we do believe the ease of use surpasses such drawbacks, especially as the vast majority of\nproblems in plane geometry should admit a GeoGebra construction.\nNewclid’s interface. Currently, Newclid’s user interface is very rudimentary, albeit straight-\nforward. For a normal user, Newclid can import a geometric construction from a GeoGebra file\nand solve the problem via DDARN, which runs using breadth-first-search or using a Human\nAgent.\nWeplantoimprovetheinterfaceofNewclidtocompleteitasapublictraininggymforauxil-\niary points finding using AI approaches (including, but not limited to, an LLM-based approach,\nsuch as the one from AlphaGeometry), with both text description and geometrical graphics as\ninput and auxiliary points as output.\nNewclid’s LLM module. Our work to date focused on improving DDAR, which resulted in\nthenewsystemDDARN.Ourmotivationforthischoice,asarguedintheintroduction,wasthat\nmost of the performance benefits of AlphaGeometry come from DDAR. AlphaGeometry’s LLM\niswritteninMeliad. WeplantoreleaseaPyTorchversionoftheLLM,withthesameweightsas\nthe original model, so that the LLM can be easily integrated and used in the Newclid interface.\n8 Conclusion\nWe have presented an improved and expanded version of AlphaGeometry, called Newclid, that\nenables user-friendly interaction to solve IMO-level geometry and an agentic interface that can\neasily be augmented by various agents to guide how DDARN solves problems. Further, we\npresentamuch-improvedcodebasethathasbetterdebuggingcapabilities, andweencouragethe\ncommunity to improve and extend our codebase to enable more user-friendly interactions.\n35\nAcknowledgments\nWe thank Ronald Cardenas Acosta for their helpful support during the development of this\nproject.\nA List of rules\nIn this section, we have the content of the unabridged rules.txt file, containing the largest\ncollectionofruleswerethatusedandexperimentedwithinNewclid. Thecurrentimplementation\nof the rules.txt file contains r01, r03-r07, r11-r29, r34, r3, r42, r49, and r51-r63 and\nrepresents the rules that are used by DDARN. The missing numbers in the rules.txt file\ncorrespondtothoserulesofDDAR,listedin[Trinhetal.,2024]thatcontainthenowunsupported\npredicates simtri* and contri*. They were replaced by new rules that make the logical steps\nof the triangle similarity arguments fully explicit. More information on the history of each rule\ncan be found in the relevant documentation section.3\nList of rules with names:\nr00 Perpendiculars give parallel\nperp A B C D, perp C D E F, ncoll A B E => para A B E F\nr01 Definition of circle\ncong O A O B, cong O B O C, cong O C O D => cyclic A B C D\nr02 Parallel from inclination\neqangle A B P Q C D P Q => para A B C D\nr03 Arc determines internal angles\ncyclic A B P Q => eqangle P A P B Q A Q B\nr04 Congruent angles are in a circle\neqangle P A P B Q A Q B, ncoll P Q A B => cyclic A B P Q\nr05 Same arc same chord\ncyclic A B C P Q R, eqangle C A C B R P R Q => cong A B P Q\nr06 Base of half triangle\nmidp E A B, midp F A C => para E F B C\nr07 Thales Theorem I\npara A B C D, coll O A C, coll O B D => eqratio3 A B C D O O\nr08 Right triangles common angle I\nperp A B C D, perp E F G H, npara A B E F => eqangle A B E F C D G H\nr09 Sum of angles of a triangle\neqangle a b c d m n p q, eqangle c d e f p q r u => eqangle a b e f m n\nr u\nr10 Ratio cancellation\n3https://lmcrc.github.io/Newclid/manual/default_files/index.html\n36\neqratio a b c d m n p q, eqratio c d e f p q r u => eqratio a b e f m n\nr u\nr11 Bisector theorem I\neqratio d b d c a b a c, coll d b c, ncoll a b c => eqangle a b a d a d\na c\nr12 Bisector theorem II\neqangle a b a d a d a c, coll d b c, ncoll a b c => eqratio d b d c a b\na c\nr13 Isosceles triangle equal angles\ncong O A O B, ncoll O A B => eqangle O A A B A B O B\nr14 Equal base angles imply isosceles\neqangle A O A B B A B O, ncoll O A B => cong O A O B\nr15 Arc determines inscribed angles (tangent)\ncircle O A B C, perp O A A X => eqangle A X A B C A C B\nr16 Same arc giving tangent\ncircle O A B C, eqangle A X A B C A C B => perp O A A X\nr17 Central angle vs inscribed angle I\ncircle O A B C, midp M B C => eqangle A B A C O B O M\nr18 Central angle vs inscribed angle II\ncircle O A B C, coll M B C, eqangle A B A C O B O M => midp M B C\nr19 Hypothenuse is diameter\nperp A B B C, midp M A C => cong A M B M\nr20 Diameter is hypotenuse\ncircle O A B C, coll O A C => perp A B B C\nr21 Cyclic trapezoid\ncyclic A B C D, para A B C D => eqangle A D C D C D C B\nr22 Bisector Construction\nmidp M A B, perp O M A B => cong O A O B\nr23 Bisector is perpendicular\ncong A P B P, cong A Q B Q => perp A B P Q\nr24 Cyclic kite\ncong A P B P, cong A Q B Q, cyclic A B P Q => perp P A A Q\nr25 Diagonals of parallelogram I\nmidp M A B, midp M C D => para A C B D\nr26 Diagonals of parallelogram II\nmidp M A B, para A C B D, para A D B C => midp M C D\n37\nr27 Thales theorem II\neqratio O A A C O B B D, coll O A C, coll O B D, ncoll A B C, sameside A\nO C B O D => para A B C D\nr28 Overlapping parallels\npara A B A C => coll A B C\nr29 Midpoint is an eqratio\nmidp M A B, midp N C D => eqratio M A A B N C C D\nr30 Right triangles common angle II\neqangle A B P Q C D U V, perp P Q U V => perp A B C D\nr31 Denominator cancelling\neqratio A B P Q C D U V, cong P Q U V => cong A B C D\nr34 AA Similarity of triangles (direct)\neqangle B A B C Q P Q R, eqangle C A C B R P R Q, ncoll A B C, sameclock\nA B C P Q R => simtri A B C P Q R\nr35 AA Similarity of triangles (reverse)\neqangle B A B C Q R Q P, eqangle C A C B R Q R P, ncoll A B C, sameclock\nA B C P R Q => simtrir A B C P Q R\nr36 ASA Congruence of triangles (direct)\neqangle B A B C Q P Q R, eqangle C A C B R P R Q, ncoll A B C, cong A B\nP Q, sameclock A B C P Q R => contri A B C P Q R\nr37 ASA Congruence of triangles (reverse)\neqangle B A B C Q R Q P, eqangle C A C B R Q R P, ncoll A B C, cong A B\nP Q, sameclock A B C P R Q => contrir A B C P Q R\nr41 Thales theorem III\npara a b c d, coll m a d, coll n b c, eqratio m a m d n b n c, sameside\nm a d n b c => para m n a b\nr42 Thales theorem IV\npara a b c d, coll m a d, coll n b c, para m n a b => eqratio m a m d n\nb n c\nr43 Orthocenter theorem\nperp a b c d, perp a c b d => perp a d b c\nr44 Pappus’s theorem\ncoll a b c, coll p q r, coll x a q, coll x p b, coll y a r, coll y p c,\ncoll z b r, coll z c q => coll x y z\nr45 Simson’s line theorem\ncyclic a b c p, coll a l c, perp p l a c, coll m b c, perp p m b c, coll\nn a b, perp p n a b => coll l m n\nr46 Incenter theorem\neqangle a b a x a x a c, eqangle b a b x b x b c, ncoll a b c => eqangle\n38\nc b c x c x c a\nr47 Circumcenter theorem\nmidp m a b, perp x m a b, midp n b c, perp x n b c, midp p c a => perp x\np c a\nr48 Centroid theorem\nmidp m a b, coll m x c, midp n b c, coll n x a, midp p c a => coll x p b\nr49 Recognize center of cyclic (circle)\ncircle O A B C, cyclic A B C D => cong O A O D\nr50 Recognize center of cyclic (cong)\ncyclic A B C D, cong O A O B, cong O C O D, npara A B C D => cong O A O C\nr51 Midpoint splits in two\nmidp M A B => rconst M A A B 1/2\nr52 Properties of similar triangles (Direct)\nsimtri A B C P Q R => eqangle B A B C Q P Q R, eqratio B A B C Q P Q R\nr53 Properties of similar triangles (Reverse)\nsimtrir A B C P Q R => eqangle B A B C Q R Q P, eqratio B A B C Q P Q R\nr54 Definition of midpoint\ncong M A M B, coll M A B => midp M A B\nr55 Properties of midpoint (cong)\nmidp M A B => cong M A M B\nr56 Properties of midpoint (coll)\nmidp M A B => coll M A B\nr57 Pythagoras theorem\nPythagoreanPremises a b c => PythagoreanConclusions a b c\nr58 Same chord same arc I\ncyclic a b c p q r, cong a b p q, sameclock c a b r p q, sameside c a b\nr p q => eqangle c a c b r p r q\nr59 Same chord same arc II\ncyclic a b c p q r, cong a b p q, sameclock c b a r p q, nsameside c b a\nr p q => eqangle c a c b r q r p\nr60 SSS Similarity of triangles (Direct)\neqratio B A B C Q P Q R, eqratio C A C B R P R Q, ncoll A B C, sameclock\nA B C P Q R => simtri A B C P Q R\nr61 SSS Similarity of triangles (Reverse)\neqratio B A B C Q P Q R, eqratio C A C B R P R Q, ncoll A B C, sameclock\nA B C P R Q => simtrir A B C P Q R\nr62 SAS Similarity of triangles (Direct)\n39\neqratio B A B C Q P Q R, eqangle B A B C Q P Q R, ncoll A B C, sameclock\nA B C P Q R => simtri A B C P Q R\nr63 SAS Similarity of triangles (Reverse)\neqratio B A B C Q P Q R, eqangle B A B C Q P Q R, ncoll A B C, sameclock\nA B C P R Q => simtrir A B C P Q R\nr64 SSS Congruence of triangles (Direct)\ncong A B P Q, cong B C Q R, cong C A R P, ncoll A B C, sameclock A B C P\nQ R => contri A B C P Q R\nr65 SSS Congruence of triangles (Reverse)\ncong A B P Q, cong B C Q R, cong C A R P, ncoll A B C, sameclock A B C P\nR Q => contrir A B C P Q R\nr66 SAS Congruence of triangles (Direct)\ncong A B P Q, cong B C Q R, eqangle B A B C Q P Q R, ncoll A B C,\nsameclock A B C P Q R => contri A B C P Q R\nr67 SAS Congruence of triangles (Reverse)\ncong A B P Q, cong B C Q R, eqangle B A B C Q P Q R, ncoll A B C,\nsameclock A B C P R Q => contrir A B C P Q R\nr68 Similarity without scaling (Direct)\neqratio B A B C Q P Q R, eqratio C A C B R P R Q, ncoll A B C, cong A B\nP Q, sameclock A B C P Q R => contri A B C P Q R\nr69 Similarity without scaling (Reverse)\neqratio B A B C Q P Q R, eqratio C A C B R P R Q, ncoll A B C, cong A B\nP Q, sameclock A B C P R Q => contrir A B C P Q R\n40\nB Full Solution IMO 2008 P1\nHerewepresentthefullproofofproblem1fromtheIMO2008examdiscussedinSubsection6.1,\nas generated by Newclid. The auxiliary constructions were added by a human. DDAR was not\nable to solve this problem even if provided the extra points.\n==========================\n∗ From theorem premises:\nA B C H D E F A1 A2 B1 B2 C1 C2 : Points\nAH ⊥ BC [00]\nBH ⊥ AC [01]\nB,C,D are collinear [02]\nDB = DC [03]\nA,E,C are collinear [04]\nEA = EC [05]\nB,A,F are collinear [06]\nFA = FB [07]\nB,A 1,C are collinear [08]\nDA 1 = DH [09]\nB,A 2,C are collinear [10]\nDA 2 = DH [11]\nA,B 1,C are collinear [12]\nEB 1 = EH [13]\nA,C,B 2 are collinear [14]\nEB 2 = EH [15]\nB,A,C 1 are collinear [16]\nFC 1 = FH [17]\nB,A,C 2 are collinear [18]\nFC 2 = FH [19]\n∗ Auxiliary Constructions:\nO1 O2 O3 O : Points\nO 1E = EH [20]\nO 1H ⊥ EF [21]\nO 2E = EH [22]\nDE ⊥ HO 2 [23]\nO 3F = FH [24]\nHO 3 ⊥ DF [25]\nOC 1 = OC 2 [26]\nOC 2 = OB 1 [27]\n∗ Proof steps:\n001. OC 1 = OC 2 [26] & OC 2 = OB 1 [27] (why cong resolution)⇒ OB 1 =\nOC 1 [28]\n002. C 1O = B 1O [28] & OC 1 = OC 2 [26] (why circle resolution)⇒ O is\nthe circumcenter of \\Delta C 1B 1C 2 [29]\n003. A,C,B 2 are collinear [14] & A,C,B 1 are collinear [12] (i04)⇒\nA,B 1,B 2 are collinear [30]\n004. B,A,C 2 are collinear [18] & B,A,C 1 are collinear [16] (i04)⇒\nB,A,C 2,C 1 are collinear [31]\n005. EB 1 = EH [13] & O 1E = EH [20] & EB 2 = EH [15] (i01)⇒\nO 1,B 1,B 2,H are concyclic [32]\n006. O 1,B 1,B 2,H are concyclic [32] (r03)⇒ ∠O 1B 2B 1 = ∠O 1HB 1 [33]\n007. ∠O 1B 2B 1 = ∠O 1HB 1 [33] & A,B 1,B 2 are collinear [30] (i08)⇒ ∠\n41\n(AB 1−B 2O 1) = ∠B 1HO 1 [34]\n008. ∠O 1B 2B 1 = ∠O 1HB 1 [33] & A,B 1,B 2 are collinear [30] (i08)⇒ ∠\nHO 1B 2 = ∠HB 1A [35]\n009. B,A 2,C are collinear [10] & B,C,A 1 are collinear [08] (i04)⇒\nB,A 1,A 2 are collinear [36]\n010. B,A 2,C are collinear [10] & B,A 2,A 1 are collinear [36] (i04)⇒\nB,A 1,C,A 2 are collinear [37]\n011. AH ⊥ BC [00] ()⇒ ∠(AH−BC) = ∠(BC−AH) [38]\n012. B,A 1,C are collinear [08] ()⇒ BC ∥ A 1B [39]\n013. ∠(AH−BC) = ∠(BC−AH) [38] & BC ∥ A 1B [39] ( why perp repr)⇒ AH ⊥\nA 1B [40]\n014. B,A 1,A 2,C are collinear [37] & AH ⊥ A 1B [40]\n(why perp resolution)⇒ AH ⊥ A 2C [41]\n015. O 1H ⊥ EF [21] & AH ⊥ A 2C [41] (r08)⇒ ∠O 1HA = ∠(EF−A 2C) [42]\n016. ∠O 1HA = ∠(EF−A 2C) [42] & B,A 1,C,A 2 are collinear [37] (i08)⇒ ∠\n(EF−A 1B) = ∠O 1HA [43]\n017. F,A,B are collinear [06] & FA = FB [07] (why midp resolution)⇒ F\nis midpoint of AB [44]\n018. E,A,C are collinear [04] & EA = EC [05] (why midp resolution)⇒ E\nis midpoint of AC [45]\n019. F is midpoint of AB [44] & E is midpoint of AC [45] (r06)⇒ FE ∥ BC\n[46]\n020. FE ∥ BC [46] & B,A 1,C are collinear [08] (i05)⇒ EF ∥ A 1B [47]\n021. ∠(EF−A 1B) = ∠O 1HA [43] & EF ∥ A 1B [47] (i03)⇒ HO 1 ∥ AH [48]\n022. ∠(AB 1−B 2O 1) = ∠B 1HO 1 [34] & HO 1 ∥ AH [48]\n( why eqangle eqangle)⇒ ∠(AB 1−B 2O 1) = ∠B 1HA [49]\n023. A,B 2,B 1 are collinear [30] & ∠(AB 1−B 2O 1) = ∠B 1HA [49]\n(why eqangle6 resolution)⇒ ∠AB 2O 1 = ∠B 1HA [50]\n024. HA ∥ HO 1 [48] (r28)⇒ A,H,O 1 are collinear [51]\n025. ∠HO 1B 2 = ∠HB 1A [35] & HO 1 ∥ AH [48] ( why eqangle eqangle)⇒ ∠\n(AH−B 2O 1) = ∠HB 1A [52]\n026. O 1,H,A are collinear [51] & ∠(AH−B 2O 1) = ∠HB 1A [52]\n(why eqangle6 resolution)⇒ ∠AO 1B 2 = ∠HB 1A [53]\n027. ∠AB 2O 1 = ∠B 1HA [50] & ∠AO 1B 2 = ∠HB 1A [53] (Similar Triangles\n35)⇒ AB 2:AO 1 = AH:AB 1 [54]\n028. O 2E = EH [22] & EB 1 = EH [13] & EB 2 = EH [15]\n(why circle resolution)⇒ E is the circumcenter of \\Delta B 1O 2B 2\n[55]\n029. O 2E = EH [22] & EB 1 = EH [13] & EB 2 = EH [15] (i01)⇒\nB 2,B 1,H,O 2 are concyclic [56]\n030. A,C,B 2 are collinear [14] & A,C,B 1 are collinear [12] & A,C,E are\ncollinear [04] (i04)⇒ A,B 1,B 2,E are collinear [57]\n031. A,B 1,B 2,E are collinear [57] (why coll resolution)⇒ E,B 1,B 2\nare collinear [58]\n032. E is the circumcenter of \\Delta B 1O 2B 2 [55] & E,B 1,B 2 are\ncollinear [58] (r20)⇒ B 1O 2 ⊥ B 2O 2 [59]\n033. B 2,B 1,H,O 2 are concyclic [56] (r03)⇒ ∠B 1HB 2 = ∠B 1O 2B 2 [60]\n034. B 2,B 1,H,O 2 are concyclic [56] (r03)⇒ ∠B 2HO 2 = ∠B 2B 1O 2 [61]\n035. AH ⊥ BC [00] & B 1O 2 ⊥ B 2O 2 [59] & ∠B 1HB 2 = ∠B 1O 2B 2 [60]\n()⇒ ∠B 1HB 2 = ∠(BC−AH) [62]\n036. ∠B 1HB 2 = ∠(BC−AH) [62] & BC ∥ A 1B [39] ( why eqangle eqangle)⇒ ∠\nB 1HB 2 = ∠(A 1B−AH) [63]\n037. B,A 1,A 2,C are collinear [37] & ∠B 1HB 2 = ∠(A 1B−AH) [63]\n42\n(why eqangle resolution)⇒ ∠B 1HB 2 = ∠(A 2C−AH) [64]\n038. B 1,B 2,H,O 1 are concyclic [32] & O 2,B 1,B 2,H are concyclic [56]\n(why cyclic resolution)⇒ B 2,B 1,O 2,O 1 are concyclic [65]\n039. B 2,B 1,O 2,H are concyclic [56] & B 2,B 1,O 2,O 1 are concyclic\n[65] (i11)⇒ B 1,B 2,O 2,O 1,H are concyclic [66]\n040. B 1,B 2,O 2,O 1,H are concyclic [66] (why cyclic resolution)⇒\nO 1,B 2,H,O 2 are concyclic [67]\n041. B 1,B 2,O 2,O 1,H are concyclic [66] (why cyclic resolution)⇒\nO 1,O 2,H,B 1 are concyclic [68]\n042. O 1,B 2,H,O 2 are concyclic [67] (r03)⇒ ∠HO 1O 2 = ∠HB 2O 2 [69]\n043. ∠HB 2O 2 = ∠HO 1O 2 [69] & HO 1 ∥ AH [48] (why eqangle resolution)⇒\n∠HB 2O 2 = ∠(AH−O 1O 2) [70]\n044. ∠B 1HB 2 = ∠(A 2C−AH) [64] & ∠HB 2O 2 = ∠(AH−O 1O 2) [70] (r09)⇒ ∠\n(HB 1−B 2O 2) = ∠(A 2C−O 1O 2) [71]\n045. ∠(HB 1−B 2O 2) = ∠(A 2C−O 1O 2) [71] & B,A 1,C,A 2 are collinear\n[37] (i08)⇒ ∠(B 1H−B 2O 2) = ∠(A 1B−O 1O 2) [72]\n046. ∠(B 1H−B 2O 2) = ∠(A 1B−O 1O 2) [72] & EF ∥ A 1B [47] (i09)⇒ ∠\n(B 1H−B 2O 2) = ∠(EF−O 1O 2) [73]\n047. ∠B 1HB 2 = ∠B 1O 2B 2 [60] & B 1O 2 ⊥ B 2O 2 [59]\n(why eqangle resolution)⇒ ∠B 2O 2B 1 = ∠B 1HB 2 [74]\n048. EH = EB 2 [15] (r13)⇒ ∠EHB 2 = ∠HB 2E [75]\n049. ∠EHB 2 = ∠HB 2E [75] & A,B 1,B 2,E are collinear [57] (i08)⇒ ∠\nEHB 2 = ∠(B 2H−AB 1) [76]\n050. ∠B 2HO 2 = ∠B 2B 1O 2 [61] & A,B 1,B 2 are collinear [30] (i08)⇒ ∠\n(AB 1−B 2H) = ∠B 1O 2H [77]\n051. ∠B 2HE = ∠(AB 1−B 2H) [76] & ∠(AB 1−B 2H) = ∠B 1O 2H [77]\n(why eqangle resolution)⇒ ∠B 1O 2H = ∠B 2HE [78]\n052. ∠B 2O 2B 1 = ∠B 1HB 2 [74] & ∠B 1O 2H = ∠B 2HE [78] (r09)⇒ ∠\n(B 2O 2−B 1H) = ∠O 2HE [79]\n053. ∠(B 1H−B 2O 2) = ∠(EF−O 1O 2) [73] & ∠(B 1H−B 2O 2) = ∠EHO 2 [79]\n()⇒ ∠EHO 2 = ∠(EF−O 1O 2) [80]\n054. FC 1 = FH [17] & FC 2 = FH [19] (why cong resolution)⇒ C 2F = C 1F\n[81]\n055. C 2F = C 1F [81] & C 2O = C 1O [26] (r23)⇒ C 2C 1 ⊥ FO [82]\n056. D,C,B are collinear [02] & DB = DC [03] (why midp resolution)⇒ D\nis midpoint of CB [83]\n057. D is midpoint of CB [83] & E is midpoint of CA [45] (r06)⇒ DE ∥ AB\n[84]\n058. C 1,B,A,C 2 are collinear [31] & DE ∥ AB [84]\n(why para resolution)⇒ C 2C 1 ∥ DE [85]\n059. C 2C 1 ⊥ FO [82] & DE ⊥ HO 2 [23] & C 2C 1 ∥ DE [85] (i00)⇒ FO ∥\nHO 2 [86]\n060. ∠EHO 2 = ∠(EF−O 1O 2) [80] & HO 2 ∥ FO [86] & EF ∥ A 1B [47]\n( why eqangle eqangle)⇒ ∠(EH−FO) = ∠(A 1B−O 1O 2) [87]\n061. B,A 1,A 2,C are collinear [37] & ∠(EH−FO) = ∠(A 1B−O 1O 2) [87]\n(why eqangle resolution)⇒ ∠(EH−FO) = ∠(A 2C−O 1O 2) [88]\n062. O 1,O 2,B 2,B 1 are concyclic [65] (r03)⇒ ∠B 2O 1B 1 = ∠B 2O 2B 1\n[89]\n063. O 1,O 2,B 2,B 1 are concyclic [65] (r03)⇒ ∠O 1B 1B 2 = ∠O 1O 2B 2\n[90]\n064. ∠B 2O 1B 1 = ∠B 2O 2B 1 [89] & B 1O 2 ⊥ B 2O 2 [59]\n(why eqangle resolution)⇒ ∠B 1O 2B 2 = ∠B 2O 1B 1 [91]\n065. EB 1 = EH [13] & O 1E = EH [20] (why cong resolution)⇒ EO 1 = EB 1\n43\n[92]\n066. EO 1 = EB 1 [92] (r13)⇒ ∠EO 1B 1 = ∠O 1B 1E [93]\n067. A,C,B 1 are collinear [12] & A,C,E are collinear [04] (i04)⇒\nA,B 1,E are collinear [94]\n068. ∠EO 1B 1 = ∠O 1B 1E [93] & A,B 1,E are collinear [94] (i08)⇒ ∠\nEO 1B 1 = ∠O 1B 1A [95]\n069. ∠O 1B 1B 2 = ∠O 1O 2B 2 [90] & A,B 1,B 2 are collinear [30] (i08)⇒\n∠AB 1O 1 = ∠B 2O 2O 1 [96]\n070. ∠B 1O 1E = ∠AB 1O 1 [95] & ∠AB 1O 1 = ∠B 2O 2O 1 [96]\n(why eqangle resolution)⇒ ∠B 2O 2O 1 = ∠B 1O 1E [97]\n071. ∠B 1O 2B 2 = ∠B 2O 1B 1 [91] & ∠B 2O 2O 1 = ∠B 1O 1E [97] (r09)⇒ ∠\n(B 1O 2−B 2O 1) = ∠O 2O 1E [98]\n072. AH ⊥ BC [00] & B 1O 2 ⊥ B 2O 2 [59] & ∠B 2O 1B 1 = ∠B 2O 2B 1 [89]\n()⇒ ∠B 2O 1B 1 = ∠(BC−AH) [99]\n073. ∠B 2O 1B 1 = ∠(BC−AH) [99] & BC ∥ A 1B [39] ( why eqangle eqangle)⇒\n∠B 2O 1B 1 = ∠(A 1B−AH) [100]\n074. B,A 1,A 2,C are collinear [37] & ∠B 2O 1B 1 = ∠(A 1B−AH) [100]\n(why eqangle resolution)⇒ ∠B 2O 1B 1 = ∠(A 2C−AH) [101]\n075. O 1,O 2,H,B 1 are concyclic [68] (r03)⇒ ∠O 1HO 2 = ∠O 1B 1O 2 [102]\n076. ∠O 1B 1O 2 = ∠O 1HO 2 [102] & HO 1 ∥ AH [48]\n(why eqangle resolution)⇒ ∠O 1B 1O 2 = ∠AHO 2 [103]\n077. ∠B 2O 1B 1 = ∠(A 2C−AH) [101] & ∠O 1B 1O 2 = ∠AHO 2 [103] (r09)⇒ ∠\n(O 1B 2−B 1O 2) = ∠(A 2C−HO 2) [104]\n078. ∠(O 1B 2−B 1O 2) = ∠(A 2C−HO 2) [104] & B,A 1,C,A 2 are collinear\n[37] (i08)⇒ ∠(B 2O 1−B 1O 2) = ∠(A 1B−HO 2) [105]\n079. ∠(B 2O 1−B 1O 2) = ∠(A 1B−HO 2) [105] & EF ∥ A 1B [47] & FO ∥ HO 2\n[86] (i09)⇒ ∠(B 1O 2−B 2O 1) = ∠(HO 2−EF) [106]\n080. ∠(B 1O 2−B 2O 1) = ∠O 2O 1E [98] & ∠(B 1O 2−B 2O 1) = ∠(HO 2−EF)\n[106] ()⇒ ∠(HO 2−EF) = ∠O 2O 1E [107]\n081. ∠(HO 2−EF) = ∠O 2O 1E [107] & HO 2 ∥ FO [86] & EF ∥ A 1B [47]\n( why eqangle eqangle)⇒ ∠(FO−A 1B) = ∠O 2O 1E [108]\n082. B,A 1,A 2,C are collinear [37] & ∠(FO−A 1B) = ∠O 2O 1E [108]\n(why eqangle resolution)⇒ ∠(FO−A 2C) = ∠O 2O 1E [109]\n083. ∠(EH−FO) = ∠(A 2C−O 1O 2) [88] & ∠(FO−A 2C) = ∠O 2O 1E [109] (r09)⇒\n∠(EH−A 2C) = ∠(A 2C−EO 1) [110]\n084. ∠(EH−A 2C) = ∠(A 2C−EO 1) [110] & B,A 1,C,A 2 are collinear [37]\n(i08)⇒ ∠(EH−A 1B) = ∠(A 1B−EO 1) [111]\n085. ∠(EH−A 1B) = ∠(A 1B−EO 1) [111] & EF ∥ A 1B [47] (i09)⇒ ∠HEF = ∠\nFEO 1 [112]\n086. HE = O 1E [20] & ∠HEF = ∠FEO 1 [112] (SAS 33)⇒ FH = FO 1 [113]\n087. FC 2 = FH [19] & O 3F = FH [24] & FH = FO 1 [113] (i01)⇒\nC 2,O 1,H,O 3 are concyclic [114]\n088. FC 1 = FH [17] & O 3F = FH [24] & FC 2 = FH [19] (i01)⇒\nC 2,H,O 3,C 1 are concyclic [115]\n089. FC 1 = FH [17] & O 3F = FH [24] & FC 2 = FH [19]\n(why circle resolution)⇒ F is the circumcenter of \\Delta C 2O 3C 1\n[116]\n090. C 2,O 1,H,O 3 are concyclic [114] & C 2,H,O 3,C 1 are concyclic\n[115] (i11)⇒ O 1,C 1,C 2,H are concyclic [117]\n091. O 1,C 1,C 2,H are concyclic [117] (r03)⇒ ∠O 1C 2C 1 = ∠O 1HC 1\n[118]\n092. ∠O 1C 2C 1 = ∠O 1HC 1 [118] & B,A,C 2,C 1 are collinear [31] &\nA,H,O 1 are collinear [51] (i08)⇒ ∠(C 2O 1−AB) = ∠AHC 1 [119]\n44\n093. ∠O 1C 2C 1 = ∠O 1HC 1 [118] & B,A,C 2,C 1 are collinear [31] &\nA,H,O 1 are collinear [51] (i08)⇒ ∠(C 2O 1−AH) = ∠(AB−C 1H) [120]\n094. B,A,C 2 are collinear [18] & ∠AHC 1 = ∠(C 2O 1−AB) [119]\n(why eqangle6 resolution)⇒ ∠AHC 1 = ∠O 1C 2A [121]\n095. C 1,A,B are collinear [16] & O 1,H,A are collinear [51] & ∠\n(AB−C 1H) = ∠(C 2O 1−AH) [120] (why eqangle6 resolution)⇒ ∠AC 1H = ∠\nC 2O 1A [122]\n096. ∠AHC 1 = ∠O 1C 2A [121] & ∠AC 1H = ∠C 2O 1A [122] (Similar\nTriangles 35)⇒ AH:AC 1 = AC 2:AO 1 [123]\n097. OC 1 = OC 2 [26] (r13)⇒ ∠OC 1C 2 = ∠C 1C 2O [124]\n098. ∠OC 1C 2 = ∠C 1C 2O [124] & B,A,C 2,C 1 are collinear [31] (i08)⇒ ∠\n(C 1O−AB) = ∠(AB−C 2O) [125]\n099. C 1,A,B are collinear [16] & B,A,C 2 are collinear [18] & ∠\n(C 1O−AB) = ∠(AB−C 2O) [125] (why eqangle6 resolution)⇒ ∠OC 1A = ∠\nBC 2O [126]\n100. HO 2 ⊥ DE [23] ()⇒ ∠(DE−HO 2) = ∠(HO 2−DE) [127]\n101. ∠(DE−HO 2) = ∠(HO 2−DE) [127] & DE ∥ AB [84] & HO 2 ∥ FO [86]\n( why eqangle eqangle)⇒ ∠(AB−FO) = ∠(FO−AB) [128]\n102. A,F,B are collinear [06] & ∠(AB−FO) = ∠(FO−AB) [128]\n(why eqangle6 resolution)⇒ ∠BFO = ∠OFA [129]\n103. BF = AF [07] & ∠BFO = ∠OFA [129] (SAS 33)⇒ ∠FBO = ∠OAF [130]\n104. ∠FBO = ∠OAF [130] & B,A,F are collinear [06] (i08)⇒ ∠ABO = ∠OAB\n[131]\n105. C 1,A,B are collinear [16] & C 2,A,B are collinear [18] & ∠OAB = ∠\nABO [131] (why eqangle6 resolution)⇒ ∠OAC 1 = ∠C 2BO [132]\n106. ∠OC 1A = ∠BC 2O [126] & ∠OAC 1 = ∠C 2BO [132] (Similar Triangles\n35)⇒ C 1O:C 2O = C 1A:C 2B [133]\n107. C 1O:C 2O = C 1A:C 2B [133] & C 1O = C 2O [26] (i02)⇒ C 1A = C 2B\n[134]\n108. AH:AC 1 = AC 2:AO 1 [123] & C 1A = C 2B [134] (i10)⇒ AH:C 2B =\nAC 2:AO 1 [135]\n109. AB 2:AO 1 = AH:AB 1 [54] & AH:C 2B = AC 2:AO 1 [135] (Ratio chase)⇒\nAB 1:C 2B = AC 2:AB 2 [136]\n110. AC 2:AB 2 = AB 1:C 2B [136] & C 1A = C 2B [134]\n(why eqratio6 resolution)⇒ AC 2:AB 2 = AB 1:AC 1 [137]\n111. F is midpoint of BA [44] & D is midpoint of BC [83] (r06)⇒ FD ∥ AC\n[138]\n112. FD ∥ AC [138] & A,B 1,C are collinear [12] (i05)⇒ DF ∥ AB 1 [139]\n113. DE ∥ AB [84] & DF ∥ AB 1 [139] ( why eqangle eqangle)⇒ ∠BAB 1 = ∠\nBAB 1 [140]\n114. B,A,C 2 are collinear [18] & A,B 2,B 1 are collinear [30] & C 1,A,B\nare collinear [16] & ∠BAB 1 = ∠BAB 1 [140] (why eqangle6 resolution)⇒\n∠C 2AB 2 = ∠C 1AB 1 [141]\n115. AC 2:AB 2 = AB 1:AC 1 [137] & ∠C 2AB 2 = ∠C 1AB 1 [141] (Similar\nTriangles 39)⇒ ∠AC 2B 2 = ∠C 1B 1A [142]\n116. ∠AC 2B 2 = ∠C 1B 1A [142] & B,A,C 2 are collinear [18] (i08)⇒ ∠\n(AB−B 2C 2) = ∠C 1B 1A [143]\n117. A,B 2,B 1 are collinear [30] & C 1,B,A,C 2 are collinear [31] & ∠\nC 1B 1A = ∠(AB−B 2C 2) [143] (why eqangle6 resolution)⇒ ∠C 1B 1B 2 =\n∠C 1C 2B 2 [144]\n118. ∠C 1B 1B 2 = ∠C 1C 2B 2 [144] (r04)⇒ C 1,B 1,C 2,B 2 are concyclic\n[145]\n119. O is the circumcenter of \\Delta C 1B 1C 2 [29] & C 1,B 1,C 2,B 2\n45\nare concyclic [145] (r49)⇒ OC 1 = OB 2 [146]\n120. O is the circumcenter of \\Delta C 1B 1C 2 [29] & C 1,B 1,C 2,B 2\nare concyclic [145] (r49)⇒ B 1O = B 2O [147]\n121. C 1,O 3,H,C 2 are concyclic [115] (r03)⇒ ∠C 1HO 3 = ∠C 1C 2O 3\n[148]\n122. C 1,O 3,H,C 2 are concyclic [115] (r03)⇒ ∠C 1C 2H = ∠C 1O 3H [149]\n123. C 1,O 3,H,C 2 are concyclic [115] (r03)⇒ ∠C 2HC 1 = ∠C 2O 3C 1\n[150]\n124. ∠C 1HO 3 = ∠C 1C 2O 3 [148] & B,A,C 2,C 1 are collinear [31] (i08)⇒\n∠O 3HC 1 = ∠(C 2O 3−AB) [151]\n125. ∠C 1HO 3 = ∠C 1C 2O 3 [148] & B,A,C 2,C 1 are collinear [31] (i08)⇒\n∠(AB−C 1H) = ∠C 2O 3H [152]\n126. BH ⊥ AC [01] ()⇒ ∠(BH−AC) = ∠(AC−BH) [153]\n127. A,B 1,C are collinear [12] ()⇒ AC ∥ AB 1 [154]\n128. ∠(BH−AC) = ∠(AC−BH) [153] & AC ∥ AB 1 [154] ( why perp repr)⇒ BH ⊥\nAB 1 [155]\n129. E,A,B 1 are collinear [94] & BH ⊥ AB 1 [155] (why perp resolution)⇒\nHB ⊥ EA [156]\n130. HB ⊥ EA [156] & HO 3 ⊥ DF [25] (r08)⇒ ∠BHO 3 = ∠(EA−DF) [157]\n131. HB ⊥ EA [156] & HO 3 ⊥ DF [25] (r08)⇒ ∠(DF−HB) = ∠(HO 3−EA) [158]\n132. ∠BHO 3 = ∠(EA−DF) [157] & A,B 1,E are collinear [94] (i08)⇒ ∠\n(AB 1−DF) = ∠BHO 3 [159]\n133. ∠(AB 1−DF) = ∠BHO 3 [159] & AB 1 ∥ DF [139] (i03)⇒ BH ∥ HO 3 [160]\n134. ∠(C 2O 3−AB) = ∠O 3HC 1 [151] & HO 3 ∥ BH [160]\n( why eqangle eqangle)⇒ ∠(C 2O 3−AB) = ∠BHC 1 [161]\n135. B,A,C 2 are collinear [18] & ∠(C 2O 3−AB) = ∠BHC 1 [161]\n(why eqangle6 resolution)⇒ ∠O 3C 2B = ∠BHC 1 [162]\n136. HO 3 ∥ HB [160] (r28)⇒ O 3,H,B are collinear [163]\n137. DE ∥ AB [84] ( why eqangle eqangle)⇒ ∠HBA = ∠HBA [164]\n138. O 3,H,B are collinear [163] & C 2,A,B are collinear [18] & C 1,A,B\nare collinear [16] & ∠HBA = ∠HBA [164] (why eqangle6 resolution)⇒ ∠\nO 3BC 2 = ∠HBC 1 [165]\n139. ∠O 3C 2B = ∠BHC 1 [162] & ∠O 3BC 2 = ∠HBC 1 [165] (Similar\nTriangles 35)⇒ O 3C 2:O 3B = C 1H:C 1B [166]\n140. ∠O 3C 2B = ∠BHC 1 [162] & ∠O 3BC 2 = ∠HBC 1 [165] (Similar\nTriangles 35)⇒ O 3C 2:C 2B = C 1H:HB [167]\n141. C 1,A,B are collinear [16] & B,A,C 2 are collinear [18] & ∠\n(C 1O−AB) = ∠(AB−C 2O) [125] (why eqangle6 resolution)⇒ ∠OC 1B = ∠\nAC 2O [168]\n142. C 1,A,B are collinear [16] & B,A,C 2 are collinear [18] & ∠OBA = ∠\nBAO [131] (why eqangle6 resolution)⇒ ∠OBC 1 = ∠C 2AO [169]\n143. ∠OC 1B = ∠AC 2O [168] & ∠OBC 1 = ∠C 2AO [169] (Similar Triangles\n35)⇒ C 1O:C 2O = C 1B:C 2A [170]\n144. C 1O:C 2O = C 1B:C 2A [170] & C 1O = C 2O [26] (i02)⇒ C 1B = C 2A\n[171]\n145. O 3C 2:O 3B = C 1H:C 1B [166] & C 1B = C 2A [171] (i10)⇒\nO 3C 2:O 3B = C 1H:AC 2 [172]\n146. B,A,C 1 are collinear [16] & B,A,F are collinear [06] (i04)⇒\nB,A,F,C 1 are collinear [173]\n147. B,A,F,C 1 are collinear [173] & B,A,C 2 are collinear [18]\n(why coll resolution)⇒ F,C 2,C 1 are collinear [174]\n148. F is the circumcenter of \\Delta C 2O 3C 1 [116] & F,C 2,C 1 are\ncollinear [174] (r20)⇒ C 2O 3 ⊥ C 1O 3 [175]\n46\n149. C 2O 3 ⊥ C 1O 3 [175] & HO 3 ⊥ DF [25] (why eqangle resolution)⇒ ∠\n(DF−HO 3) = ∠C 2O 3C 1 [176]\n150. C 2O 3 ⊥ C 1O 3 [175] & HO 3 ⊥ DF [25] (r08)⇒ ∠(DF−C 2O 3) = ∠\nHO 3C 1 [177]\n151. ∠C 1C 2H = ∠C 1O 3H [149] & B,A,C 2,C 1 are collinear [31] (i08)⇒ ∠\n(C 1O 3−AB) = ∠O 3HC 2 [178]\n152. A,F,B are collinear [06] & ∠O 3HC 2 = ∠(C 1O 3−AB) [178]\n(why eqangle resolution)⇒ ∠O 3HC 2 = ∠(C 1O 3−AF) [179]\n153. ∠(DF−HO 3) = ∠C 2O 3C 1 [176] & ∠O 3HC 2 = ∠(C 1O 3−AF) [179]\n(r09)⇒ ∠(DF−HC 2) = ∠(O 3C 2−AF) [180]\n154. ∠(DF−HC 2) = ∠(O 3C 2−AF) [180] & B,A,F are collinear [06] (i08)⇒ ∠\n(DF−C 2H) = ∠(C 2O 3−AB) [181]\n155. O 3F = FH [24] & FC 2 = FH [19] (why cong resolution)⇒ FC 2 = FO 3\n[182]\n156. FC 2 = FO 3 [182] (r13)⇒ ∠FC 2O 3 = ∠C 2O 3F [183]\n157. B,A,C 2 are collinear [18] & B,A,F are collinear [06] (i04)⇒\nB,A,F,C 2 are collinear [184]\n158. ∠FC 2O 3 = ∠C 2O 3F [183] & B,A,F,C 2 are collinear [184] (i08)⇒ ∠\n(AB−C 2O 3) = ∠C 2O 3F [185]\n159. ∠(DF−C 2H) = ∠(C 2O 3−AB) [181] & ∠(C 2O 3−AB) = ∠FO 3C 2 [185]\n(why eqangle resolution)⇒ ∠FO 3C 2 = ∠(DF−HC 2) [186]\n160. C 2O 3 ⊥ C 1O 3 [175] & ∠C 2HC 1 = ∠C 2O 3C 1 [150]\n(why eqangle resolution)⇒ ∠C 2HC 1 = ∠C 1O 3C 2 [187]\n161. FC 1 = FH [17] (r13)⇒ ∠FC 1H = ∠C 1HF [188]\n162. ∠FC 1H = ∠C 1HF [188] & B,A,F,C 1 are collinear [173] (i08)⇒ ∠\n(AB−C 1H) = ∠C 1HF [189]\n163. ∠(AB−C 1H) = ∠C 2O 3H [152] & ∠(AB−C 1H) = ∠C 1HF [189]\n(why eqangle resolution)⇒ ∠C 1HF = ∠C 2O 3H [190]\n164. ∠C 2HC 1 = ∠C 1O 3C 2 [187] & ∠C 1HF = ∠C 2O 3H [190] (r09)⇒ ∠\nC 2HF = ∠C 1O 3H [191]\n165. ∠C 2HF = ∠C 1O 3H [191] & ∠(C 2O 3−DF) = ∠C 1O 3H [177]\n(why eqangle resolution)⇒ ∠(O 3C 2−DF) = ∠C 2HF [192]\n166. ∠FO 3C 2 = ∠(DF−HC 2) [186] & ∠(O 3C 2−DF) = ∠C 2HF [192] (r09)⇒ ∠\nO 3FD = ∠DFH [193]\n167. O 3F = HF [24] & ∠O 3FD = ∠DFH [193] (SAS 33)⇒ DO 3 = DH [194]\n168. DA 1 = DH [09] & DO 3 = DH [194] & DA 2 = DH [11] (i01)⇒\nA 2,H,O 3,A 1 are concyclic [195]\n169. A 2,H,O 3,A 1 are concyclic [195] (r03)⇒ ∠A 2O 3H = ∠A 2A 1H [196]\n170. ∠A 2O 3H = ∠A 2A 1H [196] & O 3,H,B are collinear [163] & B,A 1,A 2\nare collinear [36] (i08)⇒ ∠(A 2O 3−BH) = ∠BA 1H [197]\n171. ∠A 2O 3H = ∠A 2A 1H [196] & O 3,H,B are collinear [163] & B,A 1,A 2\nare collinear [36] (i08)⇒ ∠(A 2O 3−A 1B) = ∠BHA 1 [198]\n172. B,H,O 3 are collinear [163] & ∠(BH−A 2O 3) = ∠HA 1B [197]\n(why eqangle6 resolution)⇒ ∠BO 3A 2 = ∠HA 1B [199]\n173. A 1,A 2,B are collinear [36] & ∠(A 1B−A 2O 3) = ∠A 1HB [198]\n(why eqangle6 resolution)⇒ ∠BA 2O 3 = ∠A 1HB [200]\n174. ∠BO 3A 2 = ∠HA 1B [199] & ∠BA 2O 3 = ∠A 1HB [200] (Similar\nTriangles 35)⇒ O 3B:A 2B = A 1B:HB [201]\n175. O 3C 2:O 3B = C 1H:AC 2 [172] & O 3C 2:C 2B = C 1H:HB [167] &\nO 3B:A 2B = A 1B:HB [201] (Ratio chase)⇒ AC 2:A 2B = A 1B:C 2B [202]\n176. AC 2:A 2B = A 1B:C 2B [202] & C 1B = AC 2 [171]\n(why eqratio6 resolution)⇒ BC 1:BA 2 = BA 1:BC 2 [203]\n177. DE ∥ AB [84] & EF ∥ A 1B [47] ( why eqangle eqangle)⇒ ∠ABA 1 = ∠\n47\nABA 1 [204]\n178. C 1,A,B are collinear [16] & A 1,A 2,B are collinear [36] & C 2,A,B\nare collinear [18] & ∠ABA 1 = ∠ABA 1 [204] (why eqangle6 resolution)⇒\n∠C 1BA 2 = ∠C 2BA 1 [205]\n179. BC 1:BA 2 = BA 1:BC 2 [203] & ∠C 1BA 2 = ∠C 2BA 1 [205] (Similar\nTriangles 39)⇒ ∠BC 1A 2 = ∠C 2A 1B [206]\n180. ∠BC 1A 2 = ∠C 2A 1B [206] & B,A,C 1 are collinear [16] (i08)⇒ ∠\n(AB−A 2C 1) = ∠C 2A 1B [207]\n181. C 1,B,A,C 2 are collinear [31] & A 1,B,A 2 are collinear [36] & ∠\n(AB−A 2C 1) = ∠C 2A 1B [207] (why eqangle6 resolution)⇒ ∠C 2C 1A 2 =\n∠C 2A 1A 2 [208]\n182. ∠C 2C 1A 2 = ∠C 2A 1A 2 [208] (r04)⇒ C 1,C 2,A 1,A 2 are concyclic\n[209]\n183. B,C,D are collinear [02] & B,A 1,C are collinear [08]\n(why coll resolution)⇒ B,A 1,D are collinear [210]\n184. B,A 1,A 2 are collinear [36] & B,A 1,D are collinear [210]\n(why coll resolution)⇒ B,A 2,D are collinear [211]\n185. B,A 2,C are collinear [10] & B,A 2,A 1 are collinear [36] & B,A 2,D\nare collinear [211] (i04)⇒ B,A 1,A 2,D are collinear [212]\n186. B,A 1,A 2,D are collinear [212] (why coll resolution)⇒ D,A 2,A 1\nare collinear [213]\n187. D,A 2,A 1 are collinear [213] & DA 1 = DH [09] & DA 2 = DH [11]\n(why midp resolution)⇒ D is midpoint of A 2A 1 [214]\n188. ∠(DF−HB) = ∠(HO 3−EA) [158] & A,B 1,E are collinear [94] (i08)⇒ ∠\n(DF−BH) = ∠(HO 3−AB 1) [215]\n189. ∠(DF−BH) = ∠(HO 3−AB 1) [215] & A,B 1,C are collinear [12] & DF ∥\nAB 1 [139] (i09)⇒ ∠(AC−BH) = ∠(HO 3−DF) [216]\n190. EB 2 = EH [15] & EB 1 = EH [13] (why cong resolution)⇒ B 1E = B 2E\n[217]\n191. B 1E = B 2E [217] & B 1O = B 2O [147] (r23)⇒ B 1B 2 ⊥ EO [218]\n192. ∠(AC−BH) = ∠(HO 3−DF) [216] & AC ∥ DF [138] & HO 3 ∥ BH [160]\n(why perp resolution)⇒ DF ⊥ BH [219]\n193. A,B 2,B 1 are collinear [30] & DF ∥ AB 1 [139]\n(why para resolution)⇒ B 1B 2 ∥ DF [220]\n194. B 1B 2 ⊥ EO [218] & DF ⊥ BH [219] & B 1B 2 ∥ DF [220] (i00)⇒ EO ∥\nBH [221]\n195. BH ∥ HO 3 [160] & EO ∥ BH [221] ()⇒ HO 3 ∥ EO [222]\n196. ∠(AC−BH) = ∠(HO 3−DF) [216] & AC ∥ DF [138] & BH ∥ EO [221] & HO 3 ∥\nEO [222] (why perp resolution)⇒ DF ⊥ EO [223]\n197. ∠(DE−HO 2) = ∠(HO 2−DE) [127] & HO 2 ∥ FO [86]\n(why perp resolution)⇒ DE ⊥ FO [224]\n198. DF ⊥ EO [223] & DE ⊥ FO [224] (r43)⇒ FE ⊥ DO [225]\n199. FE ⊥ DO [225] & EF ⊥ HO 1 [21] (i00)⇒ DO ∥ HO 1 [226]\n200. DO ∥ HO 1 [226] & A,H,O 1 are collinear [51] (i05)⇒ DO ∥ AH [227]\n201. ∠(AH−BC) = ∠(BC−AH) [38] & AH ∥ DO [227] & BC ∥ A 1B [39]\n( why perp repr)⇒ DO ⊥ A 1B [228]\n202. A 1,A 2,B are collinear [36] & DO ⊥ A 1B [228]\n(why perp resolution)⇒ OD ⊥ A 2A 1 [229]\n203. D is midpoint of A 2A 1 [214] & OD ⊥ A 2A 1 [229] (r22)⇒ OA 1 =\nOA 2 [230]\n204. C 1,C 2,A 1,A 2 are concyclic [209] & OC 1 = OC 2 [26] & OA 1 =\nOA 2 [230] (r50)⇒ OC 1 = OA 1 [231]\n205. OC 1 = OB 2 [146] & OC 1 = OC 2 [26] & OC 1 = OA 1 [231] (i01)⇒\n48\nC 1,B 2,A 1,C 2 are concyclic [232]\n206. C 1,B 2,A 1,C 2 are concyclic [232] & C 1,A 1,C 2,A 2 are concyclic\n[209] (i11)⇒ C 1,B 2,A 1,A 2 are concyclic [233]\n207. C 1,B 2,A 1,C 2 are concyclic [232] & C 1,B 2,A 1,A 2 are concyclic\n[233] & C 1,B 2,C 2,B 1 are concyclic [145] (i11)⇒\nA 2,B 2,C 1,A 1,B 1 are concyclic [234]\n208. A 2,B 2,C 1,A 1,B 1 are concyclic [234] (why cyclic resolution)⇒\nC 1,B 2,A 1,B 1 are concyclic [235]\n209. C 1,B 2,A 1,C 2 are concyclic [232] & C 1,B 2,A 1,A 2 are concyclic\n[233] & C 1,B 2,A 1,B 1 are concyclic [235] (i11)⇒\nC 1,C 2,B 1,B 2,A 1,A 2 are concyclic\n==========================\n49\nC orthocenter aux Problem\nFigures 4 and 5 of the symbols graphs and the dependency graphs in the paper refer to the\nproblem orthocenter aux, present in the examples.txt problem file already in the original\nAlphaGeometry codebase. Here we present a description of the problem.\nThe problem is to prove the existence of the orthocenter of the triangle, that is, the common\nintersection of the three heights:\nProblem. Given a triangle ABC and D the intersection of the heights of the triangle with\nrespect to sides AC and AB, prove that D is also in the height relative to side BC. Take as an\nauxiliary point E, the foot of the vertex B with respect to side AC.\nExplanation of AlphaGeometry’s translation of the orthocenter aux problem: Con-\nsider the triangle ABC and that\n• D is the intersection of the line perpendicular to AC through B with the line perpendicular\nto AB through C.\n• E is the intersection of line AC with line BD.\nThen, prove that line AD is perpendicular to line BC.\nFormal translation of the problem:\na b c = triangle a b c;\nd = on tline d b a c, on tline d c a b;\ne = on line e a c, on line e b d ? perp a d b c\n50\nReferences\nShang-Ching Chou, Xiao-Shan Gao, and Jing-Zhong Zhang. A deductive database approach to\nautomated geometry theorem proving and discovering. Journal of Automated Reasoning, 25\n(3):219–246, 2000.\nGuillaumeLample,TimotheeLacroix,Marie-AnneLachaux,AurelienRodriguez,AmauryHayat,\nThibautLavril,GabrielEbner,andXavierMartinet.Hypertreeproofsearchforneuraltheorem\nproving. Advances in neural information processing systems, 35:26337–26349, 2022.\nShiven Sinha, Ameya Prabhu, Ponnurangam Kumaraguru, Siddharth Bhat, and Matthias\nBethge. Wu’s Method can Boost Symbolic AI to Rival Silver Medalists and AlphaGeome-\ntry to Outperform Gold Medalists at IMO Geometry. arXiv preprint arXiv:2404.06405, 2024.\nBartdeSmit,IlyaBogdanov, JohanBosman,AndriesBrouwer,GabrieleDellaTorre,G´ezaK´os,\nHendrik Lenstra, Charles Leytem, Ronald van Luijk, Christian Reiher, Eckard Specht, Hans\nSterk, and Lenny Taelman. 52nd International Mathematical Olympiad Problem: Shortlist\nWith Solutions. Technical report, International Mathematical Olympiad (IMO), Amsterdam,\nJuly 2011. URL https://www.imo-official.org/problems/IMO2011SL.pdf.\nTrieu H. Trinh, Yuhuai Wu, Quoc V. Le, He He, and Thang Luong. Solving olympiad geometry\nwithout human demonstrations. Nature, 625(7995):476–482, January 2024. ISSN 0028-0836,\n1476-4687. URL https://www.nature.com/articles/s41586-023-06747-5.\nWen-Tsu¨n Wu. On the decision problem and the mechanization of theorem-proving\nin elementary geometry. Scientia Sinica, 21(2):159–172, 1978. URL http:\n//utest.sciengine.com/publisher/ScienceChinaPress/journal/ScientiaSinica/\n21/2/10.1360/ya1978-21-2-159.\nZheng Ye, Shang-Ching Chou, and Xiao-Shan Gao. An Introduction to Java Geometry Expert.\nIn Automated Deduction in Geometry: 7th International Workshop, ADG 2008, Shanghai,\nChina, September 22-24, 2008. Revised Papers 7, pages 189–195. Springer, 2011.\n51",
    "pdf_filename": "Newclid_A_User-Friendly_Replacement_for_AlphaGeometry.pdf"
}