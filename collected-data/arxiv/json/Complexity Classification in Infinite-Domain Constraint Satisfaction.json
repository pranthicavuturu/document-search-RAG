{
    "title": "Complexity Classification in Infinite-Domain Constraint Satisfaction",
    "context": "",
    "body": "Complexity Classiﬁcation in Inﬁnite-Domain\nConstraint Satisfaction\nM´emoire pour l’obtention d’une habilitation `a diriger des recherches\nUniversit´e Paris Diderot – Paris 7\nSp´ecialit´e Informatique\npr´esent´e par\nManuel Bodirsky\nsoutenue publiquement le 19 janvier 2012, devant le jury compos´e de :\nArnaud\nDURAND\nUniversit´e Paris 7, IMJ, ´Equipe Logique Math´ematique\nChristoph\nD¨URR\nCNRS / LIP6, Universit´e Paris 6\nMarkus\nJUNKER\nMathematisches Institut, Albert-Ludwigs-Universit¨at Freiburg\nPascal\nKOIRAN\nENS Lyon\nLuc\nSEGOUFIN\nINRIA / LSV, CNRS+ENS Cachan\nLes rapporteurs sont :\nV´ıctor\nDALMAU\nUniversit´e Pompeu Fabra, Barcelone, Espagne\nArnaud\nDURAND\nUniversit´e Paris 7, IMJ, ´Equipe Logique Math´ematique\nPeter\nJONSSON\nUniversit´e de Link¨oping, Suede\narXiv:1201.0856v10  [cs.CC]  20 Apr 2019\n\n2\nAcknowledgements. I want to thank my institution, the CNRS, for the great\nfreedom in research that allowed me to write this text. The research leading to the\nresults presented here has also received funding from the European Research Coun-\ncil under the European Community’s Seventh Framework Program (FP7/2007-2013\nGrant Agreement no. 257039). I also want to thank all of my constraint satisfaction\nco-authors for the good time we had with our joint work.\nMy ﬁrst address at the ´Equipe de Logique Math´ematique has always been Arnaud\nDurand, and I am indebted to him for his great help with many things over the years,\nincluding the process of the habilitation. Many thanks also to Micha l Wrona, Fran¸cois\nBossi`ere, Trung van Pham, Antoine Mottet, Johannes Greiner, Michael Kompatscher,\nChristian Pech, and Florian Starke for reporting mistakes in earlier versions of this\ntext.\nSpecial thanks to Christoph D¨urr for the permission to include his wonderful\npictures at the beginning of many chapters. More of his artwork can be found under\nhttp://picasaweb.google.com/xtof.durr/LaVieEstDurr.\nThe pictures for Chapters 6, 9, and 10 are drawings that I kept from discussions with\nJan K´ara, Martin Kutz, and Jaroslav Neˇsetˇril. The picture for Chapter 4 is by Lewin\nBodirsky, Summer 2010, and the picture for Chapter 7 is by Otto Bodirsky, Summer\n2011.\n\nContents\nChapter 1.\nIntroduction\n1\n1.1.\nThe Homomorphism Perspective\n4\n1.2.\nThe Sentence Evaluation Perspective\n7\n1.3.\nThe Satisﬁability Perspective\n11\n1.4.\nThe Existential Second-Order Perspective\n17\n1.5.\nExamples\n22\n1.6.\nOverview\n30\n1.7.\nUncovered Topics\n30\nChapter 2.\nPreliminaries in Logic\n35\nChapter 3.\nModel Theory\n45\n3.1.\nω-categorical Structures\n46\n3.2.\nFra¨ıss´e Amalgamation\n50\n3.3.\nOligomorphic Permutation Groups\n53\n3.4.\nPreservation Theorems\n59\n3.5.\nExistential Positive Completion\n65\n3.6.\nQuantiﬁer-elimination, Model-completeness, Cores\n67\nChapter 4.\nExamples\n79\n4.1.\nPhylogeny Constraints and Homogeneous C-relations\n79\n4.2.\nBranching-Time Constraints\n82\n4.3.\nSet Constraints\n82\n4.4.\nSpatial Reasoning\n84\n4.5.\nCSPs and Fragments of SNP\n84\nChapter 5.\nUniversal Algebra\n91\n5.1.\nOligomorphic Clones\n92\n5.2.\nThe Inv-Pol Galois Connection\n93\n5.3.\nEssential Arity\n95\n5.4.\nSchaefer’s Theorem\n101\n5.5.\nPseudo-varieties and Primitive Positive Interpretations\n104\n5.6.\nVarieties\n114\nChapter 6.\nEquality Constraint Satisfaction Problems\n121\n6.1.\nIndependence of Disequality\n122\n6.2.\nTwo-transitive Templates\n124\n6.3.\nHorn Formulas\n125\n6.4.\nClassiﬁcation\n127\nChapter 7.\nTopology\n129\n7.1.\nTopological Spaces\n129\n7.2.\nTopological Groups\n131\n7.3.\nOligomorphic Groups\n135\n3\n\n4\nCONTENTS\n7.4.\nBi-interpretations\n137\nChapter 8.\nRamsey Theory\n141\n8.1.\nRamsey Classes\n142\n8.2.\nExtremely Amenable Groups\n145\n8.3.\nCanonization\n150\n8.4.\nDecidability Results for Meta-Problems\n156\nChapter 9.\nSchaefer’s Theorem for Graphs\n161\n9.1.\nMotivation and the Result\n161\n9.2.\nEndomorphisms\n163\n9.3.\nFirst-order Expansions of (V; E, N)\n165\n9.4.\nFirst-order Expansions of (V; R(3), S(3))\n181\n9.5.\nFirst-order Expansions of (V; R(4), S(4))\n187\n9.6.\nFirst-order Expansions of (V; R(5), S(5))\n188\n9.7.\nAlgorithms for Graph-SAT problems\n189\n9.8.\nClassiﬁcation\n202\nChapter 10.\nTemporal Constraint Satisfaction Problems\n207\n10.1.\nIntroduction\n207\n10.2.\nPreliminaries\n208\n10.3.\nEndomorphisms\n211\n10.4.\nLex-closed Constraints\n212\n10.5.\nShuﬄe-closed Constraints\n224\n10.6.\nClassiﬁcation\n242\nChapter 11.\nNon-Dichotomies\n247\n11.1.\nArithmetical Templates\n248\n11.2.\nCSPs in SNP\n249\n11.3.\ncoNP-intermediate ω-categorical Templates\n250\nChapter 12.\nFuture Work\n255\nBibliography\n257\n\nCHAPTER 1\nIntroduction\nConstraint satisfaction problems (CSPs) appear in almost every area of theo-\nretical computer science, for instance in artiﬁcial intelligence, scheduling, compu-\ntational linguistics, computational biology, veriﬁcation, and algebraic computation.\nMany computational problems studied in those areas can be modeled by appropriately\nchoosing a set of constraint types, the constraint language, that are allowed in the\ninput instance of a CSP. In the last decade, huge progress was made to ﬁnd general\ncriteria for constraint languages that imply that the corresponding CSP can be solved\neﬃciently [12,61,63,64,66,95,123].\nLately, the complexity of the CSP became a topic that vitalizes the ﬁeld of uni-\nversal algebra, since it turned out that questions about the computational complexity\nof CSPs translate to important universal-algebraic questions about algebras that can\nbe associated to CSPs. This approach is now known as the algebraic approach to\nconstraint satisfaction complexity. The algebraic approach has raised questions that\nare of central importance in universal algebra.\nAnother reason why the complexity of CSPs attracts attention is an exciting con-\njecture due to Feder and Vardi [95], which is still unresolved, and which is known\nas the dichotomy conjecture. This conjecture says that every CSP with a ﬁnite do-\nmain is either polynomial-time tractable (i.e., in P) or NP-complete. According to\na well-known result by Ladner, it is known that there are NP-intermediate compu-\ntational problems, i.e., problems in NP that are neither tractable nor NP-complete\n(unless P=NP). But the known NP-intermediate problems are extremely artiﬁcial. It\nwould be interesting from a complexity theoretic perspective to discover more natural\ncandidates for NP-intermediate problems. Unlike many questions in computational\n\n2\n1. INTRODUCTION\ncomplexity that are wide open, the dichotomy conjecture allows many promising par-\ntial results and diﬀerent approaches (see the collection of survey articles in [80]), and\ntherefore is an attractive research topic.\nAny outcome of the dichotomy conjecture is signiﬁcant: a negative answer might\nprovide relatively natural NP-intermediate problems, which would be interesting for\ncomplexity theorists. A positive answer probably comes with a criterion which de-\nscribes the NP-hard CSPs (and it would probably even provide algorithms for the\npolynomial-time tractable CSPs). But then we would have a fascinatingly rich cata-\nlogue of computational problems where the computational complexity is known. Such\na catalogue would be a valuable tool for deciding the complexity of computational\nproblems: since CSPs are abundant, one might derive algorithmic results by reducing\nthe problem of interest to a known tractable CSP, and one might derive hardness\nresults by reducing a known NP-hard CSP to the problem of interest.\nEven though very powerful partial results on the dichotomy conjecture have been\nobtained in recent years, the impact of constraint satisfaction complexity theory on\nother ﬁelds in theoretical computer science has so far been modest. A reason might\nbe that the range of problems in the literature that can be described by specifying a\nconstraint language over a ﬁnite domain, and that have been studied independently\nfrom the CSP framework, is quite limited, and mostly focussed on specialized graph\ntheoretic problems or Boolean satisﬁability problems.\nIf we consider the class of all problems that can be formulated by specifying a\nconstraint language over an inﬁnite domain, the situation changes drastically. Many\nproblems that have been studied independently in temporal reasoning, spatial reason-\ning, phylogenetic reconstruction, and computational linguistics can be directly formu-\nlated as CSPs. Also feasibility problems in linear (and also non-linear) programming\n(over the rationals, the integers, or other domains) can be cast as CSPs.\nThe goal of this thesis is to generalize the universal-algebraic approach to inﬁnite\ndomains. It turns out that this is possible when the constraint language, viewed as a\nrelational structure B with an inﬁnite domain, is ω-categorical. Many of the CSPs in\nthe mentioned application areas can be formulated with ω-categorical constraint lan-\nguages — in particular, problems coming from so-called qualitative calculi in artiﬁcial\nintelligence tend to have formulations with ω-categorical constraint languages. While\nω-categoricity is a quite strong assumption from a model-theoretic point of view (and,\nfor example, constraint languages for linear programming cannot be ω-categorical),\nthe class of computational problems that can be formulated with ω-categorical con-\nstraint languages is still a very large generalization of the class of CSPs that can\nbe formulated with a constraint language over a ﬁnite domain. This will be amply\ndemonstrated by examples of ω-categorical constraint languages from many diﬀerent\nareas in computer science in Chapter 4.\nThere are several general results for ω-categorical structures that are relevant\nwhen studying the computational complexity of the respective CSPs.\nEvery ω-\ncategorical structure is homomorphically equivalent to an ω-categorical structure\nwhich is model-complete and a core. Model-complete cores have many good prop-\nerties: for example, those structures have quantiﬁer elimination once expanded by all\nprimitive positive deﬁnable relations; this is treated in Chapter 3. Since homomorphi-\ncally equivalent structures have the same CSP, we can therefore focus on constraint\nlanguages that have those properties.\nMoreover, it can be shown that the so-called polymorphism clone of an ω-categorical\nstructure B fully captures the computational complexity of the corresponding CSP\n(Chapter 5). By this observation, universal-algebraic techniques can be used to ana-\nlyze the computational complexity of the CSP for B. Indeed, the study of CSPs has\n\n1. INTRODUCTION\n3\ntriggered questions that are of central interest in universal algebra, and that have led\nto considerable new activity (see e.g. [13,22,159,187]).\nAnother tool that becomes useful speciﬁcally for polymorphisms over inﬁnite\ndomains is Ramsey theory (Chapter 8). The basic idea here is to apply Ramsey theory\nto show that polymorphisms must act canonically on large parts of their domain.\nTypically there are only ﬁnitely many possibilities for canonical behavior, and so this\ntechnique allows to perform combinatorial analysis when proving classiﬁcation results.\nWith this approach we can also show that, under further assumptions on B, many\nquestions about the expressive power of B become decidable, such as the question\nwhether a given quantiﬁer-free ﬁrst-order formula is in B equivalent to a primitive\npositive formula.\nAn important feature of the universal-algebraic approach is that tractability of\na CSP can be linked to the existence of polymorphisms of the constraint language.\nThis link can be exploited in several directions: ﬁrst, when we already know that a\nconstraint language of interest has a polymorphism satisfying good properties, then\nthis polymorphism can guide the search for an eﬃcient algorithm for the correspond-\ning CSP. Another direction is that we already have an algorithm (or an algorithmic\ntechnique), and that we want to know for which CSPs the algorithm is a correct\ndecision procedure: again, polymorphisms are the key tool for this task. Finally, we\nmight use the absence of polymorphisms with good properties to prove that a CSP\nis NP-hard. There are several instances where these three directions of the algebraic\napproach have been used very successfully for CSPs with ﬁnite domain constraint\nlanguages [12,64,73,123] or ω-categorical constraint languages [41,52].\nIn Chapter 9 and Chapter 10 we use polymorphisms to classify the computational\ncomplexity in some large families of constraint satisfaction problems. In Chapter 9, we\nstudy constraint languages deﬁnable over the random graph, and in Chapter 10 con-\nstraint languages deﬁnable over (Q; <). Even though the two underlying structures\nare very diﬀerent from a model-theoretic point of view, and even though the classiﬁ-\ncation proofs are very diﬀerent in both cases, we can give a common formulation of\nthe two classiﬁcation results that delineates also the border between polynomial-time\nsolvable and NP-complete CSPs.\nChapter outline. Constraint satisfaction problems can appear in several diﬀer-\nent forms, because there are several ways how CSPs can be formalized. The diﬀerences\nin formalizing constraint satisfaction problems are related to the way how instances\nare coded and to how the problem itself is described. In the next sections we present\nfour formalisms; each of those formalisms is attached to a diﬀerent line of research.\nIn later sections some arguments are more natural from one perspective than from\nthe other, so it will be convenient to have them all discussed here. See Figure 1.1 for\nan illustration how the four perspectives we discuss can be put into relationship to\neach other.\nPerspective\nInstance\nProblem Description\nHomomorphism\nStructure\nStructure\nSentence Evaluation\nSentence\nStructure\nSatisﬁability\nSentence\nSentences\nExistential Second-Order\nStructure\nSentence\nFigure 1.1. The four perspectives on the deﬁnition of CSPs.\n\n4\n1. INTRODUCTION\n1.1. The Homomorphism Perspective\nA relational signature τ is a set of relation symbols Ri, each of which has an\nassociated ﬁnite arity ki. A relational structure A over the signature τ (also called\nτ-structure) consists of a set A (the domain or base set) together with a relation\nRA ⊆Ak for each relation symbol R of arity k from τ. It causes no harm to allow\nstructures whose domain is empty.\nA homomorphism h from a structure A with domain A to a structure B with\ndomain B and the same signature τ is a mapping from A to B that preserves each\nrelation for the symbols in τ; that is, if (a1, . . . , ak) is in RA, then (h(a1), . . . , h(ak))\nmust be in RB. An isomorphism is a bijective homomorphism h such that the inverse\nmapping h−1 : B →A that sends h(x) to x is a homomorphism, too.\nIn this thesis, a (non-uniform) constraint satisfaction problem (CSP) is a compu-\ntational problem that is speciﬁed by a single structure with a ﬁnite relational signa-\nture, called the template (or the constraint language; the name ‘constraint language’\nis typically used in the context of the second perspective on CSPs that we present in\nSection 1.2).\nDefinition 1.1.1 (CSP(B)). Let B be a (possible inﬁnite) structure with a ﬁnite\nrelational signature τ. Then CSP(B) is the computational problem to decide whether\na given ﬁnite τ-structure A homomorphically maps to B.\nCSP(B) can be considered to be a class — the class of all ﬁnite τ-structures that\nhomomorphically map to B.\nA homomorphism from a given τ-structure A to B is called a solution of A\nfor CSP(B).\nIt is in general not clear how to represent solutions for CSP(B) on\na computer; however, for the deﬁnition of the problem CSP(B) we do not need\nto represent solutions, since we only have to decide the existence of solutions. To\nrepresent an input structure A of CSP(B) we can ﬁx any representation of the relation\nsymbols in the signature τ, due to the assumption that τ is ﬁnite. Thus, CSP(B) is a\nwell-deﬁned computational problem for any inﬁnite structure B with ﬁnite relational\nsignature.\nExample 1.1.2 (Digraph acyclicity). Next, consider the problem CSP((Z; <)).\nHere, the relation < denotes the strict linear order of the integers Z. An instance A\nof this problem can be viewed as a directed graph (also called digraph), potentially\nwith loops. It is easy to see that A homomorphically maps to (Z; <) if and only if\nthere is no directed cycle in A (loops are considered to be directed cycles, too). It\nis easy to see and well-known that this can be tested in linear time, for example by\nperforming a depth-ﬁrst search on the digraph A.\n□\nExample 1.1.3 (Betweenness). The so-called betweenness problem [170] can be\nmodeled as CSP((Z; Betw)) where Betw is the ternary relation\n{(x, y, z) ∈Z3 | (x < y < z) ∨(z < y < x)} .\nThis problem is one of the NP-complete problems listed in the book of Garey and\nJohnson [101].\n□\nExample 1.1.4 (Cyclic-Ordering). The Cyclic-order problem [99] can be modeled\nas CSP((Z; Cycl)) where Cycl is the ternary relation\n{(x, y, z) ∈Z3 | (x < y < z) ∨(y < z < x) ∨(z < x < y)} .\nThis problem is again NP-complete and can be found in [101].\n□\nExample 1.1.5 (H-coloring problems). Let H be an (undirected) graph. We view\nundirected graphs as τ-structures where τ contains a single binary relation symbol E,\n\n1.1. THE HOMOMORPHISM PERSPECTIVE\n5\nwhich denotes a symmetric and anti-reﬂexive relation. Then the H-coloring problem\nis the computational problem to decide for a given ﬁnite graph G whether there exists\na homomorphism from G to H. For instance, if H is the graph K3 (the complete graph\non three vertices), then the H-coloring problem is the famous 3-colorability problem\n(see e.g. [101]). Similarly, for every ﬁxed k, the k-colorability problem can be modeled\nas CSP(H), for an appropriate graph H.\n□\nThe next lemma (Lemma 1.1.7) is a useful test to determine whether a compu-\ntational problem can be formulated as CSP(B) for an inﬁnite relational structure B.\nAn (induced) substructure of a τ-structure A is a τ-structure B with B ⊆A and\nRB = RA ∩Bn for each n-ary R ∈τ; we also say that B is induced by B in A,\nand write A[B] for B. The union of two τ-structures A, B is the τ-structure A ∪B\nwith domain A ∪B and relations RA∪B = RA ∪RB for all R ∈τ. The intersection\nA ∩B of A and B is deﬁned analogously. A disjoint union of A and B is the union\nof isomorphic copies of A and B with disjoint domains. As disjoint unions are unique\nup to isomorphism, we usually speak of the disjoint union of A and B, and denote it\nby A⊎B. The disjoint union of a set of τ-structures C is deﬁned analogously (and the\ndisjoint union of an empty set of structures is the τ-structure with empty domain). A\nstructure is called connected if it is not the disjoint union of two non-empty structures.\nA maximal connected substructure of B is called a connected component of B.\nDefinition 1.1.6. We say that a class C of relational structures is\n• closed under homomorphisms iﬀwhenever A ∈C and A homomorphically\nmaps to B then B ∈C;\n• closed under inverse homomorphisms iﬀwhenever B ∈C and A homomor-\nphically maps to B then A ∈C;\n• closed under (ﬁnite) disjoint unions iﬀwhenever A, B ∈C then the disjoint\nunion of A and B is also in C.\nNote that a class C of τ-structures is closed under inverse homomorphisms if and\nonly if its complement in the class of all τ-structures is closed under homomorphisms.\nWhen a class is closed under inverse homomorphisms, or closed under homomor-\nphisms, it is in particular closed under isomorphisms. The following is a simple, but\nfundamental lemma for CSPs. When N is a class of τ-structures, we say that a struc-\nture A is N-free if no B ∈N homomorphically maps to A. The class of all ﬁnite\nN-free structures we denote by Forb(N).\nLemma 1.1.7. Let τ be a ﬁnite relational signature, and C a class of ﬁnite τ-\nstructures. Then the following are equivalent.\n(1) C = CSP(B) for some τ-structure B.\n(2) C = Forb(N) for a class of ﬁnite connected τ-structures N.\n(3) C is closed under disjoint unions and inverse homomorphisms.\n(4) C = CSP(B) for a countably inﬁnite τ-structure B.\nProof. It suﬃces to prove the implications (1) ⇒(2) ⇒(3) ⇒(4). For the im-\nplication from (1) to (2), let N be the class of all ﬁnite connected τ-structures that do\nnot homomorphically map to B. Then by transitivity of the homomorphism relation,\na τ-structure A homomorphically maps to B if and only if no C ∈N homomorphically\nmaps to A.\n(2) implies (3). Suppose (2), and let A1 and A2 be two structures from Forb(N).\nIf there were a homomorphism from one of the structures C ∈N into A1 ⊎A2, then\nbecause C is connected, it must already be a homomorphism into A1 or A2, which is\nimpossible. Hence, Forb(N) is closed under disjoint unions. Closure under inverse\n\n6\n1. INTRODUCTION\nTriangle-Freeness\nINSTANCE: An undirected graph G\nQUESTION: Is G triangle-free?\nAcyclic-Bipartition\nINSTANCE: A digraph G\nQUESTION: Is there a partition V = V1 ⊎V2 of the vertices V of G such that\nboth G[V1] and G[V2] are acyclic?\nNo-Mono-Tri\nINSTANCE: An undirected graph G\nQUESTION: Is there a partition V = V1 ⊎V2 of the vertices V of G such that\nboth G[V1] and G[V2] are triangle-free?\nFigure 1.2. Three computational problems that are closed under\ndisjoint unions and inverse homomorphisms.\nhomomorphisms follows straightforwardly from transitivity of the homomorphism re-\nlation.\n(3) implies (4). Suppose that C is a class of ﬁnite relational structures that is\nclosed under disjoint unions and inverse homomorphisms. Let C′ be a subclass of C\nwhere we select one structure from each isomorphism class of structures in C. Let B\nbe the (countably inﬁnite) disjoint union over all structures in C′ (if C is empty then B\nis by deﬁnition the empty structure1). Clearly, every structure in C homomorphically\nmaps to B. Now, let A be a ﬁnite structure with a homomorphism h to B. By\nconstruction of B, the set h(A) is contained in the disjoint union C of a ﬁnite set\nof structures from C. Since C is closed under disjoint unions, C is in C. Clearly, A\nhomomorphically maps to C, and because C is closed under inverse homomorphisms,\nA is in C as well.\n□\nExample 1.1.8. The computational problems in Figure 1.2 are closed under\ndisjoint unions and inverse homomorphisms. Hence, Lemma 1.1.7 shows that they\ncan be formulated as CSP(B) for some relational structure B. It is easy to see that\nnone of those three problems can be formulated as CSP(B) for a ﬁnite structure B.\nWe verify this for the problem of Triangle-freeness. For a ﬁxed n, consider the\ngraph that contains vertices x1, . . . , xn, and that contains for every pair i, j with 1 ≤\ni < j ≤n two additional vertices ui,j, vi,j and the edges (xi, ui,j), (ui,j, vi,j), (vi,j, xj).\nThe resulting graph is clearly triangle-free. But note that every homomorphism f from\nthis graph to a graph H with strictly less than n vertices must identify at least two of\nthe vertices x1, . . . , xn. So suppose that f(xi) = f(xj). Because f is a homomorphism,\nwe have that (f(xi), f(ui,j)), (f(ui,j, f(vi,j)), (f(vi,j), f(xj)) are edges in H. Hence,\nH either contains a triangle or a loop. In both cases, H cannot be the template for\nTriangle-Freeness. Hence we have ruled out all templates of size n−1. This concludes\nthe proof since n was chosen arbitrarily.\n□\nWe close with an important concept for ﬁnite structures B, the notion of core\nstructures; generalizations to inﬁnite structures B are presented in Section 3.6.3. Two\nstructures A and B are called homomorphically equivalent if there exists a homomor-\nphism from A to B and vice versa. An embedding of A into B is an injective map\n1Structures with an empty domain are often forbidden in model theory. Lemma 1.1.7 is one of\nthe places that motivates our decision to allow them in this text.\n\n1.2. THE SENTENCE EVALUATION PERSPECTIVE\n7\nf : A →B such that (a1, . . . , ak) is in RA if and only if (f(a1), . . . , f(ak)) is in RB.\nAn endomorphism of a structure B is a homomorphism from B to B.\nDefinition 1.1.9. A structure B is a core if all its endomorphisms are embed-\ndings2. For structures A, B of the same signature, the structure B is called a core of\nA if B is a core and homomorphically equivalent to A.\nIn fact, we speak of the core of a ﬁnite structure A, due to the following fact,\nwhose proof is easy and left to the reader.\nProposition 1.1.10. Every ﬁnite structure A has a core.\nAll cores of A are\nisomorphic.\nCore structures B have many pleasant properties when it comes to studying\nthe computational complexity of CSP(B) (see for instance Proposition 1.2.9 below).\nClearly, when A and B are homomorphically equivalent, then CSP(A) = CSP(B).\nTherefore, and because of Proposition 1.1.10, we can assume without loss of generality\nthat a ﬁnite structure B is a core when studying CSP(B). We ﬁnally remark that\nstructures with a one-element core have a trivial CSP.\nProposition 1.1.11. Let B be a relational structure with a ﬁnite relational sig-\nnature and a one-element core. Then CSP(B) is in P.\nProof. Let C be the core of B, and let c be the unique element of C.\nThe\nproblem CSP(B) can be solved as follows. Let A be an input structure of CSP(B). If\nthere is (t1, . . . , tn) ∈RA such that (c, . . . , c) /∈RC, then reject. Otherwise accept.\n□\n1.2. The Sentence Evaluation Perspective\nLet τ be a relational signature. A ﬁrst-order τ-formula φ(x1, . . . , xn) is called\nprimitive positive if it is of the form\n∃xn+1, . . . , xm(ψ1 ∧· · · ∧ψl)\nwhere ψ1, . . . , ψl are atomic τ-formulas, i.e., formulas of the form R(y1, . . . , yk) with\nR ∈τ and yi ∈{x1, . . . , xm}, of the form y = y′ for y, y′ ∈{x1, . . . , xm}, of the form\n⊥or ⊤for false and true, respectively. Note that if the domain is non-empty then\nwe do not need a symbol ⊤for true, since we can use the primitive positive sentence\n∃x. x = x to express it. As usual, formulas without free variables are called sentences.\nFrom a model-checking perspective, CSPs are deﬁned as follows. We will see (in\nPropositions 1.2.4 and 1.2.5) that this deﬁnition is essentially the same deﬁnition as\nDeﬁnition 1.1.1, and that the diﬀerences are a matter of formalization3.\nDefinition 1.2.1. Let B be a (possibly inﬁnite) structure with a ﬁnite relational\nsignature τ. Then CSP(B) is the computational problem to decide whether a given\nprimitive positive τ-sentence φ is true in B.\n2For ﬁnite structures B, injective self-maps must be bijective, and in fact every injective homo-\nmorphism of a structure B must be an isomorphism. For inﬁnite structures, however, this need not\nbe true, and for reasons that become clear in Chapter 3 we chose the present deﬁnition.\n3A small diﬀerence between the homomorphism perspective and the sentence evaluation prob-\nlem results from the fact that we do allow equality in primitive positive formulas; as we will see,\nadding equality to the constraint language does not aﬀect the complexity of the CSP up to log-space\nreductions. There are articles, though, that study the complexity of CSPs at an even ﬁner level\nthan logspace-reducibility, and in those papers equality is not automatically allowed in the input to\na constraint satisfaction problem.\n\n8\n1. INTRODUCTION\n3SAT\nINSTANCE: A propositional formula in conjunctive normal form (CNF) with\nat most three literals per clause\nQUESTION: Is there a Boolean assignment for the variables such that in each\nclause at least one literal is true?\nPositive 1-in-3-3SAT\nINSTANCE: A propositional 3SAT formula with only positive literals\nQUESTION: Is there a Boolean assignment for the variables such that in each\nclause exactly one literal is true?\nPositive Not-All-Equal-3SAT\nINSTANCE: A propositional 3SAT formula with only positive literals\nQUESTION: Is there a Boolean assignment for the variables such that in each\nclause neither all three literals are true nor all three are false?\nFigure 1.3. Three Boolean satisﬁability problems from the list of\nNP-complete problems of [101] that can be formulated as CSP(B)\nfor appropriate B.\nThe given primitive positive τ-sentence φ is also called an instance of CSP(B).\nThe conjuncts of an instance φ are called the constraints of φ. A mapping from the\nvariables of φ to the elements of B that is a satisfying assignment for the quantiﬁer-free\npart of φ is also called a solution to φ.\nSome authors omit the (existential) quantiﬁer-preﬁx in instances φ of CSP(B),\nand the question is then whether φ is satisﬁable over B.\nClearly, this is just re-\nphrasing the problem above, but it explains the terminology of satisﬁable and unsat-\nisﬁable (rather than true and false) instances of CSP(B).\nExample 1.2.2 (Boolean satisﬁability problems). There are many Boolean sat-\nisﬁability problems that can be cast as CSPs. Well-known examples are 3SAT (see\nFigure 1.3), and the restricted versions of 3SAT called 1-in-3-3SAT and NOT-ALL-\nEQUAL-3SAT [101]. These three problems are NP-complete. An interesting feature\nof the last two problems is that they remain NP-complete even when all clauses in\nthe input only contain positive literals. With this additional restriction, the problems\nare called positive 1-in-3-3SAT and positive NOT-ALL-EQUAL-3SAT, and their def-\ninition can be found in Figure 1.3.\nAll of these problems can be formulated as CSP(B), for an appropriate 2-element\nstructure B. Positive 1-in-3-3SAT can be formulated as CSP(B) for the template\nB = ({0, 1}; 1IN3)\nwhere 1IN3 = {(0, 0, 1), (0, 1, 0), (1, 0, 0)} ,\nand Positive-Not-All-Equal-3SAT as CSP(B) for the template\nB = ({0, 1}, NAE)\nwhere NAE = {0, 1}3 \\ {(0, 0, 0), (1, 1, 1)} .\nThese problems can also be formulated as CSPs if we do not impose the restriction\nthat all literals are positive; the corresponding problems are then called 1-in-3-3SAT\nand Not-All-Equal-3SAT, respectively. The idea is to use a diﬀerent ternary relation\nfor each of the eight ways how three distinct variables in a clause with three literals\nmight be negated. In this way, we can also model the classical problem of 3SAT\n(again, see Figure 1.3) as a CSP. Clauses of the type x ∨y ∨¬z in the 3SAT problem\nwill then be viewed as constraints R++−(x, y, z), where R++−= {0, 1}3 \\ {(0, 0, 1)}\n\n1.2. THE SENTENCE EVALUATION PERSPECTIVE\n9\n(here, x, y, z are not necessarily distinct variables). Similarly, the well-known 2SAT\nproblem can be viewed as CSP(({0, 1}; R++, R+−, R−+, R−−)) where\nR++ = {(0, 1), (1, 0), (1, 1)},\nR+−= {(0, 0), (1, 1), (1, 0)},\nR−+ = {(1, 1), (0, 0), (0, 1)}, and\nR−−= {(1, 0), (0, 1), (0, 0)} .\n□\nExample 1.2.3 (Disequality constraints). Consider the problem CSP((N; =, ̸=)).\nAn instance of this problem can be viewed as an (existentially quantiﬁed) set of\nvariables, some linked by equality, some by disequality4 constraints. Such an instance\nis false in (N; =, ̸=) if and only if there is a path x1, . . . , xn from a variable x1 to\na variable xn that uses only equality edges, i.e., ‘xi = xi+1’ is a constraint in the\ninstance for each 1 ≤i ≤n −1, and additionally ‘x1 ̸= xn’ is a constraint in the\ninstance. Clearly, it can be tested in linear time in the size of the input instance\nwhether the instance contains such a path.\n□\n1.2.1. Canonical conjunctive queries. To every ﬁnite relational τ-structure\nA we can associate a τ-sentence, called the canonical conjunctive query of A, and\ndenoted by Q(A). The variables of this sentence are the elements of A, all of which\nare existentially quantiﬁed in the quantiﬁer preﬁx of the formula, which is followed\nby the conjunction of all formulas of the form R(a1, . . . , ak) for R ∈τ and tuples\n(a1, . . . , ak) ∈RA.\nFor example, the canonical conjunctive query Q(K3) of the complete graph on\nthree vertices K3 is the formula\n∃u∃v∃w\n\u0000E(u, v) ∧E(v, u) ∧E(v, w) ∧E(w, v) ∧E(u, w) ∧E(w, u)\n\u0001\n.\nThe proof of the following proposition is straightforward.\nProposition 1.2.4. Let B be a structure with ﬁnite relational signature τ, and\nlet A be a ﬁnite τ-structure. Then there is a homomorphism from A to B if and only\nif Q(A) is true in B.\n1.2.2. Canonical databases. To present a converse of Proposition 1.2.4, we\ndeﬁne the canonical database D(φ) of a primitive positive τ-formula, which is a re-\nlational τ-structure deﬁned as follows. We require that φ does not contain ⊥. If φ\ncontains an atomic formula of the form x = y, we remove it from φ, and replace all\noccurrences of x in φ by y. Repeating this step if necessary, we may assume that φ\ndoes not contain atomic formulas of the form x = y.\nThen the domain of D(φ) is the set of variables (both the free variables and the\nexistentially quantiﬁed variables) that occur in φ. There is a tuple (v1, . . . , vk) in a\nrelation R of D(φ) iﬀφ contains the conjunct R(v1, . . . , vk). The following is similarly\nstraightforward as Proposition 1.2.4.\nProposition 1.2.5. Let B be a structure with signature τ, and let φ be a prim-\nitive positive τ-sentence other than ⊥.\nThen φ is true in B if and only if D(φ)\nhomomorphically maps to B.\nDue to Proposition 1.2.5 and Proposition 1.2.4, we may freely switch between the\nhomomorphism and the logic perspective whenever this is convenient. In particular,\n4We deliberately use the word disequality instead of inequality, since we reserve the word in-\nequality for the relation x ≤y.\n\n10\n1. INTRODUCTION\ninstances of CSP(B) can from now on be either ﬁnite structures A or primitive positive\nsentences φ.\n1.2.3. Expansions. Let A be a τ-structure, and let A′ be a τ ′-structure with\nτ ⊆τ ′. If A and A′ have the same domain and RA = RA′ for all R ∈τ, then A is\ncalled the τ-reduct (or simply reduct) of A′, and A′ is called a τ ′-expansion (or simply\nexpansion) of A. When A is a structure, and R is a relation over the domain of A,\nthen we denote the expansion of A by R by (A, R).\nThe following lemma says that we can expand structures by primitive positive\ndeﬁnable relations without changing the complexity of the corresponding CSP. Hence,\nprimitive positive deﬁnitions are an important tool to prove NP-hardness: to show\nthat CSP(B) is NP-hard, it suﬃces to show that there is a primitive positive deﬁnition\nof a relation R such that CSP((B, R)) is already known to be NP-hard. Stronger tools\nto prove NP-hardness of CSPs will be introduced in Section 5.5.\nLemma 1.2.6. Let B be a structure with ﬁnite relational signature, and let R be a\nrelation that has a primitive positive deﬁnition in B. Then CSP(B) and CSP((B, R))\nare linear-time equivalent.\nThey are also equivalent under deterministic log-space\nreductions.\nProof. It is clear that CSP(B) reduces to the new problem. So suppose that\nφ is an instance of CSP((B, R)). Replace each conjunct R(x1, . . . , xl) of φ by its\nprimitive positive deﬁnition ψ(x1, . . . , xl).\nMove all quantiﬁers to the front, such\nthat the resulting formula is in prenex normal form and hence primitive positive.\nFinally, equalities can be eliminated one by one: for equality x = y, remove y from\nthe quantiﬁer preﬁx, and replace all remaining occurrences of y by x. Let ψ be the\nformula obtained in this way.\nIt is straightforward to verify that φ is true in (B, R) if and only if ψ is true in\nB, and it is also clear that ψ can be constructed in linear time in the representation\nsize of φ. For the observation that the reduction is deterministic log-space, we need\nthe recent result that undirected reachability can be decided in deterministic log-\nspace [178].\n□\nExample 1.2.7. The relation NAE(x1, x2, x3) has the following primitive positive\ndeﬁnition in ({0, 1}; 1IN3).\n∃u1, u2, u3, v1, v2, v3, z1, z2, z3\n\u00001IN3(x1, u1, v1) ∧1IN3(x2, u2, v2) ∧1IN3(x3, u3, v3)\n∧1IN3(v1, u2, z1) ∧1IN3(v2, u3, z2) ∧1IN3(v3, u1, z3) ∧1IN3(z1, z2, z3)\n\u0001\nTo see that this works, note that when x1 = x2 = x3 = 1, then the ﬁrst three\nconjuncts imply that u1 = v1 = u2 = v2 = u3 = v3 = 0, and the next three\nconjuncts imply that z1 = z2 = z3 = 1, and hence the last conjunct is violated. When\nx1 = x2 = x3 = 0, then the ﬁrst conjunct implies that u1 = 0 and v1 = 1, or u1 = 1\nand v1 = 0. In both cases, the fourth conjunct implies that z1 = 0. Similarly, we can\ninfer that z2 = z3 = 0. Whence, the last conjunct is violated.\nNow consider the case when exactly one out of x1, x2, x3 is 0. Since the formula\nis symmetric with respect to x1, x2, x3, we assume without loss of generality that\nx1 = 0, x2 = 1, x3 = 1. Then we can set u1 = z1 = z2 = 1, and v1 = u2 = v2 = u3 =\nv3 = z3 = 0 and satisfy all conjuncts. Similarly, when exactly two out of x1, x2, x3 are\n0, we assume without loss of generality that x1 = 1, x2 = x3 = 0. Then we can set\nu1 = v1 = u2 = u3 = z2 = z3 = 0 and z1 = v2 = v3 = 1 and satisfy all conjuncts.\n□\nAn automorphism of a structure B with domain B is an isomorphism between\nB and itself. When applying an automorphism α to an element b from B we omit\nbrackets, that is, we write αb instead of α(b). The set of all automorphisms α of B\n\n1.3. THE SATISFIABILITY PERSPECTIVE\n11\nis denoted by Aut(B), and α−1 denotes the inverse map of α. Let (b1, . . . , bk) be a\nk-tuple of elements of B. A set of the form S = {(αb1, . . . , αbk) | α ∈Aut(B)} is\ncalled an orbit of k-tuples (the orbit of (b1, . . . , bk)).\nLemma 1.2.8. Let B be a structure with a ﬁnite relational signature and do-\nmain B, and let R = {(b1, . . . , bk)} be a k-ary relation that only contains one tuple\n(b1, . . . , bk) ∈Bk. If the orbit of (b1, . . . , bk) in B is primitive positive deﬁnable, then\nthere is a polynomial-time reduction from CSP((B, R)) to CSP(B).\nProof. Let φ be an instance of CSP((B, R)) with variable set V . If φ contains\ntwo constraints R(x1, . . . , xk) and R(y1, . . . , yk), then replace each occurrence of y1\nby x1, then each occurrence of y2 by x2, and so on, and ﬁnally each occurrence of\nyk by xk. We repeat this step until all constrains that involve R are imposed on the\nsame tuple of variables (x1, . . . , xk). Replace R(x1, . . . , xk) by the primitive positive\ndeﬁnition θ of its orbits in B. Finally, move all quantiﬁers to the front, such that\nthe resulting formula ψ is in prenex normal form and thus an instance of CSP(B).\nClearly, ψ can be computed from φ in polynomial time. We claim that φ is true in\n(B, R) if and only if ψ is true in B.\nSuppose φ has a solution s: V →B. Let s′ be the restriction of s to the variables\nof V that also appear in φ. Since (b1, . . . , bn) satisﬁes θ, we can extend s′ to the\nexistentially quantiﬁed variables of θ to obtain a solution for ψ.\nIn the opposite\ndirection, suppose that s′ is a solution to ψ over B. Let s be the restriction of s′ to\nV . Because (s(x1), . . . , s(xk)) satisﬁes θ it lies in the same orbit as (b1, . . . , bk). Thus,\nthere exists an automorphism α of B that maps (s(x1), . . . , s(xk)) to (b1, . . . , bk).\nThen the extension of the map x 7→αs(x) that maps variables yi of φ that have been\nreplaced by xi in ψ to the value bi is a solution to φ over (B, R).\n□\nRecall from Section 1.1 that every ﬁnite structure C is homomorphically equivalent\nto a core structure B, which is unique up to isomorphism. For core structures, all\norbits are primitive positive deﬁnable. This fact has a simple proof for ﬁnite structures\nB; however, the same fact is true for a large class of inﬁnite structures, and presented\nin Chapter 3, Theorem 3.6.11. Since Theorem 3.6.11 implies the following proposition,\nwe omit the proof at this point.\nProposition 1.2.9. Let B be a ﬁnite core structure. Then orbits of k-tuples of\nB are primitive positive deﬁnable.\nProposition 1.2.9 and Lemma 1.2.8 have the following well-known consequence.\nCorollary 1.2.10. Let B be a ﬁnite core structure with elements b1, . . . , bn and\nﬁnite signature.\nThen CSP(B) and CSP((B, {b1}, . . . , {bn})) are polynomial time\nequivalent.\n1.3. The Satisﬁability Perspective\nYet another perspective on the constraint satisfaction problem translates not only\nthe instances, but also the template of the CSP into logic. This leads to a natural\nperspective for various model-theoretic considerations in Chapter 3. Moreover, this\nperspective is convenient when discussing the literature that uses relation algebras in\nthe context of constraint satisfaction [88, 142]; the connection will be described in\nSection 1.3.2 and Section 1.3.3.\nWe use the opportunity to introduce some inevitable terminology from logic. We\nassume that the reader is already familiar with basic terminology of ﬁrst-order logic;\na highly recommendable text-book is Hodges [120].\n\n12\n1. INTRODUCTION\n1.3.1. Theories. A (ﬁrst-order) theory is a set of ﬁrst-order sentences. When\nthe ﬁrst-order sentences are over the signature τ, we also say that T is a τ-theory.\nA model of a τ-theory T is a τ-structure B such that B satisﬁes all sentences in T.\nTheories that have a model are called satisﬁable.\nDefinition 1.3.1. Let τ be a ﬁnite relational signature, and let T be a τ-theory.\nThen CSP(T) is the computational problem to decide for a given primitive positive\nτ-sentence φ whether T ∪{φ} is satisﬁable.\nThe satisﬁability perspective on CSPs stresses the fact that the problem CSP(B)\nis fully determined by the ﬁrst-order theory of B, that is, by the theory that contains\nexactly those sentences that are true in B. In fact, it is already determined by the\nprimitive positive sentences that are false in B.\nExample 1.3.2. Let T be the theory that consists of the following sentences.\n∀x, y, z ((x < y ∧y < z) →x < z)\n(transitivity)\n∀x, y ¬(x < x)\n(irreﬂexivity)\n∀x, y, z ((x < y) ∨(y < x) ∨(x = y))\n(totality)\nIt is straightforward to verify that CSP(T) equals CSP((Z; <)) (Example 1.1.2).\n□\nWhen T is a theory and φ a sentence, we say that T entails φ, in symbols T |= φ,\nif every model of T satisﬁes φ. The following is clear from the deﬁnitions.\nProposition 1.3.3. Let τ be a ﬁnite relational signature, and let T be a τ-theory.\nSuppose that T entails exactly those negations of primitive positive sentences φ such\nthat B |= φ. Then CSP(T) and CSP(B) are the same problem.\nWe have already seen that two structures that are homomorphically equivalent\nhave the same CSP; the following provides a necessary and suﬃcient condition that\ndescribes when two theories have the same CSP. Its proof is simple once the relevant\nnotions from logic are introduced, and will be given in Section 2.1.3.\nProposition 1.3.4. Let T and T ′ be two ﬁrst-order theories. Then the following\nare equivalent.\n• CSP(T) equals CSP(T ′).\n• Every model of T ′ has a homomorphism to some model of T, and every\nmodel of T has a homomorphism to some model of T ′.\n• T and T ′ entail the same negations of primitive positive sentences.\nWe now present a couple of basic observations relating the deﬁnition of CSP(T)\nfor a theory T with the deﬁnition of CSP(B) for a relational structure B. We start\nwith the observation that there are theories T such that CSP(T) cannot be formulated\nas CSP(B).\nExample 1.3.5. Let τ be the signature {R, G}, where R and G are unary relation\nsymbols, and let T be the τ-theory {∀x, y ¬(R(x) ∧G(y))}. There is no structure\nB such that CSP(B) equals CSP(T). To see this, observe that T ∪{∃x.R(x)} is\nsatisﬁable, and T ∪{∃x.G(x)} is satisﬁable. But any structure B that satisﬁes both\n∃x.R(x) and ∃x.G(x) also satisﬁes ∃x, y(R(x)∧R(y)), which shows that CSP(B) and\nCSP(T) are diﬀerent.\n□\nWe next characterize those satisﬁable theories T that have a model B such that\nCSP(B) and CSP(T) are the same problem.\nProposition 1.3.6. Let τ be a ﬁnite relational signature, and let T be a satisﬁable\nﬁrst-order τ-theory. The following are equivalent.\n\n1.3. THE SATISFIABILITY PERSPECTIVE\n13\n(1) There is a structure B such that CSP(B) and CSP(T) are the same problem.\n(2) There is a model B of T such that CSP(B) and CSP(T) are the same\nproblem.\n(3) For all primitive positive τ-sentences φ1 and φ2, if T ∪{φ1} is satisﬁable\nand T ∪{φ2} is satisﬁable then T ∪{φ1, φ2} is satisﬁable as well.\n(4) T has the Joint Homomorphism Property (JHP), that is, when T has models\nA and B, then it also has a model C such that both A and B homomorphically\nmap to C.\nWe defer the proof of this fact to Section 2.1.3 when we have some more concepts\nfrom logic available.\n1.3.2. Relation Algebras. Many interesting inﬁnite-domain CSPs, in partic-\nular in spatial and temporal reasoning, have been studied in the context of relation\nalgebras (many examples will be given in Section 1.5 and Chapter 4). In Artiﬁcial\nIntelligence, relation algebras are used as a framework to formalize and study qual-\nitative reasoning problems [88, 117, 142]. From the perspective of this thesis, the\nrelation algebra approach does not bring substantially new tools, and Section 1.3.2\nand Section 1.3.3 can be safely skipped. Here we nonetheless give a quick introduction\nin order to link the relation algebra terminology with the satisﬁability perspective on\nthe CSP (Section 1.3.3).\nRelation algebras are designed to handle binary relations in an algebraic way; we\nfollow the presentation in [117].\nDefinition 1.3.7. A proper relation algebra is a domain D together with a set\nB of binary relations over D such that\n(1) Id := {(x, x) | x ∈D} ∈B;\n(2) If B1 and B2 are from B, then B1 ∨B2 := B1 ∪B2 ∈B;\n(3) 1 := S\nB∈B B ∈B;\n(4) 0 := ∅∈B;\n(5) If B ∈B, then −B := 1 \\ B ∈B;\n(6) If B ∈B, then B⌣:= {(x, y) | (y, x) ∈B} ∈B;\n(7) If B1 and B2 are from B, then B1 ◦B2 ∈B; where\nB1 ◦B2 := {(x, z) | ∃y((x, y) ∈B1 ∧(y, z) ∈B2)} .\nWe want to point out that in this standard deﬁnition of proper relation algebras\nit is not required that 1 denotes D2 (and this will be used for instance in the proof of\nProposition 1.3.16). However, in most examples that we encounter, 1 indeed denotes\nD2. The minimal non-empty elements of B with respect to set-wise inclusion are\ncalled the basic relations of the relation algebra.\nExample 1.3.8 (The Point Algebra). Let D = Q be the set of rational numbers,\nand consider\nB = {∅, =, <, >, ≤, ≥, ̸=, Q2} .\nThose relations form a proper relation algebra (with atoms <, >, =, and where 1\ndenotes Q2) which is one of the most fundamental relation algebras and known under\nthe name point algebra.\n□\nWhen B is ﬁnite, every relation in B can be written as a ﬁnite union of basic rela-\ntions, and we abuse notation and sometimes write R = {B1, . . . , Bk} when B1, . . . , Bk\nare basic relations, R ∈B, and R = B1 ∪· · · ∪Bk. Note that composition of basic\nrelations determines the composition of all relations in the relation algebra, since\nR1 ◦R2 =\n[\nB1∈R1,B2∈R2\nB1 ◦B2 .\n\n14\n1. INTRODUCTION\n◦\n=\n<\n>\n=\n=\n<\n>\n<\n<\n<\n1\n>\n>\n1\n>\nFigure 1.4. The composition table for the basic relations in the\npoint algebra.\nAn abstract relation algebra (Deﬁnition 1.3.9 below) is an algebra with signature\n{∨, −, 0, 1, ◦,⌣, Id} that satisﬁes laws that we expect from those operators in a proper\nrelation algebra.\nDefinition 1.3.9 (Compare [88,117,142]). An (abstract) relation algebra A is\nan algebra with domain A and signature {∨, −, 0, 1, ◦,⌣, Id} such that\n• the structure (A; ∨, ∧, −, 0, 1) is a Boolean algebra where ∧is deﬁned by\n(x, y) 7→−(−x ∨−y) from −and ∨;\n• ◦is an associative binary operation on A;\n• (a⌣)⌣= a for all a ∈A;\n• a ◦(b ∨c) = a ◦b ∨a ◦c;\n• (a ∨b)⌣= a⌣∨b⌣;\n• (−a)⌣= −(a⌣);\n• (a ◦b)⌣= b⌣◦a⌣;\n• (a ◦b) ∧c⌣= 0 ⇔(b ◦c) ∧a⌣= 0.\nWe deﬁne x ≤y by x ∧y = x. A subalgebra B of a relation algebra A with\ndomain A is a relation algebra with domain B ⊂A such that for every function f of\nA, the element obtained by applying f to elements from B is again in B.\nA representation (D, i) of A consists of a set D and a mapping i from the domain\nA of A to binary relations over D such that the image of i induces a proper relation\nalgebra B, and i is an isomorphism with respect to the functions (and constants)\n{∨, −, 0, 1, ◦,⌣, Id}. In this case, we also say that A is the abstract relation algebra\nof B.\nThere are ﬁnite relation algebras that do not have a representation [151]. Note\nthat when (D, i) is a representation of A, then i(a) is a basic relation of the induced\nproper relation algebra if and only if a ̸= 0, and for every b ≤a we have b = a or\nb = 0; we call a an atom of A. Using the axioms of relation algebras, it can be shown\nthat the composition operator is uniquely determined by the composition operator\non the atoms. Similarly, the inverse of an element a ∈A is the disjunction of the\ninverses of all the atoms below a.\nExample 1.3.10. The (abstract) point algebra is a relation algebra with 8 ele-\nments and 3 atoms, =, <, and >, and can be described as follows. The composition\noperator of the basic relations of the point algebra is shown in the table of Figure 1.4.\nBy the observation we just made, this table determines the full composition table.\nThe inverse of < is >, and Id denotes = which is its own inverse. This fully determines\nthe relation algebra.\nWe can obtain a representation of the abstract point algebra from the point\nalgebra with domain Q presented in Example 1.3.8 in the obvious way.\n□\n1.3.3. Network Satisfaction Problems. The central computational problems\nthat have been studied for relation algebras are network satisfaction problems [88,117,\n142]. Let A be a ﬁnite relation algebra with domain A. An (A-) network N = (V ; f)\nconsists of a ﬁnite set of nodes V and a partial function f : V 2 →A. Here, we slightly\n\n1.3. THE SATISFIABILITY PERSPECTIVE\n15\ndeviate from the deﬁnition given in the papers listed above in that we allow f to be\nundeﬁned on some pairs of nodes.\nTwo types of network satisfaction problems have been studied for A-networks.\nThe ﬁrst is the network satisfaction problem for a (ﬁxed) representation of A, deﬁned\nas follows.\nDefinition 1.3.11. Let (D, i) be a representation of a ﬁnite relation algebra A.\nThen the network satisfaction problem for (D, i) is the computational problem to\ndecide whether a given A-network N = (V ; f) is satisﬁable with respect to (D, i),\nthat is, whether there exists a mapping s: V →D such that (s(u), s(v)) ∈i(f(u, v))\nfor all u, v ∈V where f is deﬁned.\nThe second problem is the (general) network satisfaction problem for A.\nDefinition 1.3.12. Let A be a ﬁnite relation algebra. Then the network satisfac-\ntion problem for A is the computational problem to decide whether a given A-network\nN is satisﬁable, i.e., whether there exists a representation (D, i) of A such that N is\nsatisﬁable with respect to (D, i).\nIt is not surprising that every network satisfaction problem for a ﬁxed repre-\nsentation is closely related to a corresponding constraint satisfaction problem; this\ncorrespondence will be described in the following. It is maybe less obvious that the\nsame also applies to the general network satisfaction problem: every ﬁnite relation\nalgebra A that has a representation also has a representation (D, i) such that the\ngeneral network satisfaction problem for A and the network satisfaction problem for\n(D, i) are one and the same problem (Proposition 1.3.16).\nTo present the link between network satisfaction problems and CSPs as deﬁned\nearlier we need the following notation. Let τA be a signature consisting of a binary\nrelation symbol Ra for each element a ∈A. When (D, i) is a representation of τA,\nthen this gives rise to a τA-structure BD,i in a natural way: the domain of the\nstructure is D, and the relation symbol Ra is interpreted by i(a). We can associate\nto each A-network N = (V ; f) a primitive positive τA-sentence φN, in the following\nstraightforward way: the variables of φN are V , and φ contains the conjunct Ra(u, v)\niﬀf(u, v) = a. Conversely, we can associate to each primitive positive τA-sentence φ\nwith variables V a network Nφ as follows. The domain of Nφ is V . Let u, v ∈V , and\nlist by a1, . . . , ak all those elements a of A such that φ contains the conjunct Ra(u, v).\nThen deﬁne f(u, v) = a for a = (a1 ∧a2 ∧· · ·∧ak); if k = 0, then f(u, v) is undeﬁned.\nThe following link between the network satisfaction problem for a ﬁxed represen-\ntation (D, i) of A, and the constraint satisfaction problem for BD,i is straightforward\nfrom the deﬁnitions.\nProposition 1.3.13. Let A be a ﬁnite relation algebra with representation (D, i).\nThen an A-network N is satisﬁable with respect to (D, i) if and only if BD,i |= φN.\nConversely, BD,i satisﬁes a primitive positive τA-sentence φ if and only if Nφ is\nsatisﬁable with respect to (D, i).\nProposition 1.3.13 shows that network satisfaction problems for ﬁxed representa-\ntions essentially are constraint satisfaction problems, and that the diﬀerences are only\na matter of formalization. To also relate the general network satisfaction problem for\na ﬁnite relation algebra A to a constraint satisfaction problem, we deﬁne in Figure 1.5\nthe ﬁrst-order τA-theory TA (as in [117], Section 2.3). The models of TA correspond\nto the representations of A, as described in the following.\nProposition 1.3.14. Let A be a ﬁnite relation algebra. When B models TA, then\n(B, i) where B is the domain of B and i is given by i(a) = RB\na is a representation of\n\n16\n1. INTRODUCTION\nTA :=\n\b\n∀x, y(¬0(x, y) ∧(Id(x, y) ⇔x = y))\n\t\n(1)\n∪\n\b\n∀x, y(1(x, y) ⇔\n_\na∈A\nRa(x, y))\n\t\n(2)\n∪\n[\na∈A\n\b\n∀x, y(Ra⌣(x, y) ⇔Ra(y, x) ∧(R−a(x, y) ⇔¬Ra(x, y))\n\t\n(3)\n∪\n[\na,b∈A\n\b\n∀x, y(Ra∨b(x, y) ⇔(Ra(x, y) ∨Rb(x, y)))\n\t\n(4)\n∪\n[\na,b∈A\n\b\n∀x, z(Ra◦b(x, z) ⇔∃y(Ra(x, y) ∧Rb(y, z)))\n\t\n(5)\nFigure 1.5. The deﬁnition of the τA-theory TA.\nA. Conversely, for every representation (D, i) of A the τA-structure BD,i is a model\nof TA.\nProof. The proof is straightforward by matching the sentences in TA with the\nitems of Deﬁnition 1.3.7.\n□\nCorollary 1.3.15. Let A be a ﬁnite relation algebra. Then an A-network N\nis satisﬁable if and only if φN ∪TA is satisﬁable. Conversely, when φ is a primitive\npositive τA-sentence, then the A-network Nφ is satisﬁable if and only if φ ∪TA is\nsatisﬁable.\nIt is easy to see that TA has the Joint Homomorphism Property (JHP, introduced\nin Proposition 2.4.6); in fact, the disjoint union of two models of TA is again a model\nof TA.\nProposition 1.3.16. Every ﬁnite relation algebra A that has a representation\nalso has a representation (D; i) whose network satisfaction problem is the same prob-\nlem as the general network satisfaction problem for A.\nProof. Since A has a representation, and by Proposition 1.3.14, the theory TA\nis satisﬁable. Since TA also has the JHP, we can apply Proposition 2.4.6 to obtain\na model B of TA with domain B be such that CSP(B) and CSP(TA) are the same\nproblem. Then by Proposition 1.3.14, for i given by i(a) = RB\na , the relation algebra\nA has the representation (B, i).\nWe then have for all A-networks N the following equivalences.\nN is satisﬁable ⇔φN ∪TA is satisﬁable\n(Corollary 1.3.15)\n⇔B |= φN\n(by the properties of B)\n⇔φN is satisﬁable wrt. (B, i)\n(Proposition 1.3.13)\nThis concludes the proof that the representation (B, i) of A has a network satisfaction\nproblem that equals the general network satisfaction problem for A.\n□\nIn combination with Proposition 1.3.13, this implies that also every general net-\nwork satisﬁability problem is essentially the same problem as a CSP for an inﬁnite\ntemplate.\nWe close this section by discussing the weaknesses of the relation algebra approach\nto constraint satisfaction. First of all, the class of problems that can be formulated as\na network satisﬁability problem for ﬁnite relation algebra A is severely restricted. The\nrelations that we allow in the input network are closed under unions; this introduces\n\n1.4. THE EXISTENTIAL SECOND-ORDER PERSPECTIVE\n17\na sort of restricted disjunction that quickly leads to NP-hardness, and indeed only\na few exceptional situations have a polynomial-time tractable network satisﬁability\nproblem [117].\nThe typical work-around here is to introduce another parameter,\nwhich is a subset B of the domain of A, and to study the network satisfaction problem\nfor networks N = (V ; f) where the image of f is contained in B. Such subsets B are\noften called a fragment of A. Note that such an additional parameter is not necessary\nfor CSPs as studied in this thesis: with the techniques of this section, we can also\nformulate the network satisfaction problems for fragments of A as CSPs.\nAlso note that the network satisfaction problem is restricted to binary relations,\nwhereas many important CSPs can only be formulated in a natural way with relations\nof higher arity (see e.g. Section 1.5.2 or Section 1.5.8). As we have seen in Proposi-\ntion 1.3.16, every network satisfaction problem can be formulated as CSP(B) for an\nappropriate inﬁnite structure B; but as the above remarks show, only a very small\nfraction of CSPs can be formulated as a network satisfaction problem. Even though\nonly very speciﬁc CSPs can be formulated as the network satisfaction problem for\na ﬁnite relation algebra A, there are hardly any additional techniques available for\nstudying network satisfaction problems. The tools we have for network satisfaction\nusually also apply to constraint satisfaction problems.\nThe study of composition of relations in the context of the network satisﬁability\nproblem is usually justiﬁed by the fact that a network with constraints over the\nrelation R ◦S can be simulated by networks that only have constraints over the\nrelation R and over the relation S. To study the computational complexity of the\nnetwork satisfaction problem for a fragment B of a relation algebra A, one therefore\ntypically computes the closure of B under the operations of the relation algebra.\nBut note that every binary relation in the closure of B is also primitive positive\ndeﬁnable in any representation of A, and that the converse of this statement is false.\nSince the computational complexity is preserved also for expansions by primitive\npositive deﬁnable relations (see Lemma 1.2.6), primitive positive deﬁnitions therefore\nappear to be the more appropriate tool for studying network satisfaction problems.\nApart from being more powerful, primitive positive deﬁnability has another advantage\nin comparison to closure in relation algebras: while the latter is intricate and not\nwell-understood, we can oﬀer a powerful Galois theory to study primitive positive\ndeﬁnability of relations (see Chapter 5).\n1.4. The Existential Second-Order Perspective\nBy a famous result of Fagin, which will be reviewed below, the complexity class NP\ncorresponds exactly to those problems that can be formulated in existential second-\norder logic (ESO). An important fragment of ESO that is particularly natural when\nit comes to the formulation of CSPs is the logic called SNP (for strict NP; see [172]\nand [95]), introduced by Kolaitis and Vardi under the name strict Σ1\n1 [135].\nAn\nexistential second-order sentence is in SNP if its ﬁrst-order part is universal. There\nare many links between constraint satisfaction and the complexity class SNP; many\nof those go back to [95] and [96], some others that we present here are new.\nSNP is often a convenient way to specify CSPs. However, not every problem\nin SNP is a CSP. In this section we present a syntactic condition that implies that\nan SNP sentence describes a problem of the form CSP(B) for an inﬁnite structure\nB. Conversely, if an SNP sentence describes a CSP, then there is an equivalent SNP\nsentence that satisﬁes the syntactic condition.\nThe special case in which all existentially quantiﬁed relations are unary, known\nas monadic SNP, deserves special attention, and will be discussed at the end of this\nsection.\n\n18\n1. INTRODUCTION\n1.4.1. Fagin’s theorem. We start by reviewing Fagin’s theorem (see e.g. [90]).\nFix a ﬁnite relational signature τ. Let C be a class of ﬁnite τ-structures that is closed\nunder isomorphisms (that is, if B ∈C, and A is isomorphic to B, then A ∈C). We\nalso ﬁx some standard way to code relational structures as ﬁnite strings so that they\ncan be given as an input to a Turing machine, see again [90]. We say that C is in NP\nwhen there exists a non-deterministic polynomial time algorithm that accepts exactly\nthe structures from C under this representation.\nA sentence of the form ∃R1, . . . , Rm. φ where φ is a ﬁrst-order sentence with\nsignature τ ∪{R1, . . . , Rm} is called an existential second-order sentence. When a\nstructure A satisﬁes Φ (and this is deﬁned in the obvious way, see e.g. [90]), we write\nA |= Φ.\nTheorem 1.4.1 (Fagin’s Theorem, see e.g. [90]). An isomorphism-closed class\nof ﬁnite τ-structures is in NP if and only if there exists an existential second-order\nsentence Φ that describes C in the sense that\nA ∈C if and only if A |= Φ .\n1.4.2. SNP. An SNP sentence is an existential second-order sentence with a\nuniversal ﬁrst-order part, i.e., a sentence of the form\n∃R1, . . . , Rk. ∀x1, . . . , xn. φ\nwhere φ is quantiﬁer-free and over the signature τ ∪{R1, . . . , Rk}.\nThe class of\nproblems that can be described by SNP sentences is called SNP, too.\nExample 1.4.2. The problem CSP((Z; <)) can be described by the following\nSNP sentence.\n∃T ∀x, y, z\n\u0000(x < y ⇒T(x, y))\n∧\n\u0000(T(x, y) ∧T(y, z)) ⇒T(x, z)\n\u0001\n∧¬T(x, x)\n\u0001\n□\nExample 1.4.3. The Betweenness problem CSP((Z; Betw)) (Example 1.1.3) can\nbe described by the following SNP sentence.\n∃T ∀x, y, z\n\u0000¬T(x, x) ∧\n\u0000(T(x, y) ∧T(y, z)) ⇒T(x, z)\n\u0001\n∧\n\u0000Betw(x, y, z) ⇒\n\u0000(T(x, y) ∧T(y, z)) ∨(T(z, y) ∧T(y, x))\n\u0001\u0001\n□\nExample 1.4.4. The problem whether a given undirected graph can be parti-\ntioned into two triangle-free graphs (this problem has been called No-Mono-Tri in\nExample 1.1.8) can be described by the SNP sentence.\n∃M ∀x, y, z\n\u0000¬\n\u0000M(x) ∧M(y) ∧M(z) ∧E(x, y) ∧E(y, z) ∧E(z, x)\n\u0001\n∧¬\n\u0000¬M(x) ∧¬M(y) ∧¬M(z) ∧E(x, y) ∧E(y, z) ∧E(z, x)\n\u0001\u0001\nThe following fundamental lemma for SNP sentences is due to Feder and Vardi [96],\nand can be shown by a simple compactness argument (Theorem 2.3.1).\nLemma 1.4.5 (from [96]). Let A be an inﬁnite structure, and Φ an SNP sentence.\nThen A |= Φ if and only if A′ |= Φ for all ﬁnite induced substructures A′ of A.\nSince every ﬁnite induced substructure of B homomorphically maps to B, and\ntherefore satisﬁes Φ, we have the following consequence.\nCorollary 1.4.6. Let Φ be an SNP sentence that describes CSP(B) for a struc-\nture B. Then B itself satisﬁes Φ.\n\n1.4. THE EXISTENTIAL SECOND-ORDER PERSPECTIVE\n19\n1.4.3. SNP and CSPs. We say that two SNP sentences Φ and Ψ are equivalent\nif for all structures (equivalently: all ﬁnite structures) A we have A |= Φ if and only\nif A |= Ψ. We assume in the following that the ﬁrst-order part φ of Φ is written in\nconjunctive normal form.\nDefinition 1.4.7. Let Φ be an SNP sentence whose unquantiﬁed relation symbols\nare from the signature τ. Then Φ is called monotone if each literal of Φ with a symbol\nfrom τ ∪{=} is negative, that is, of the form ¬R(¯x), for R ∈(τ ∪{=}).\nIn particular, monotone SNP sentences do not contain literals of the form x = y\n(hence, in the terminology of Feder and Vardi [95], we work here with monotone\nSNP without inequality; the reason why Feder and Vardi add the attribute without\ninequalities is that for them, SNP sentences are written in negation normal form, so\nforbidding literals of the form x = y amounts to forbidding inequalities in negation\nnormal form).\nWe also assume that monotone SNP sentences do not contain literals of the form\nx ̸= y.\nThis is without loss of generality, since every monotone SNP sentence is\nequivalent to one which does not contain literals of the form x ̸= y. To obtain the\nequivalent sentence, we remove literals of the form x ̸= y and replace all occurrences\nof y in the same clause by x. Note that the SNP sentences given in Example 1.4.2,\n1.4.3, and 1.4.4 can be easily re-written into equivalent monotone SNP sentences.\nThe class of structures that satisfy a given monotone SNP sentences is clearly\nclosed under inverse homomorphisms. The converse is a result by Feder and Vardi [96];\nit shows that for SNP, the semantic restriction of closure under inverse homomor-\nphisms and the syntactic restriction of monotonicity match.\nTheorem 1.4.8 (from [96]). Let Φ be an SNP sentence. Then the class of struc-\ntures that satisfy Φ is closed under inverse homomorphisms if and only if Φ is equiv-\nalent to a monotone SNP sentence.\nDefinition 1.4.9 (Connected SNP). When ψ is a clause of a ﬁrst-order σ-\nformula φ in conjunctive normal form, let C be the σ-structure whose vertices are\nthe variables of ψ, and where (x1, . . . , xn) ∈RC if and only if ψ contains a negative\nliteral of the form ¬R(x1, . . . , xn). We say that ψ is connected if C is connected. We\nsay that an SNP sentence Φ is connected if all clauses of the ﬁrst-order part φ of Φ\nare connected.\nTheorem 1.4.10. Let Φ be an SNP sentence. Then the class of structures that\nsatisfy Φ is closed under disjoint unions if and only if Φ is equivalent to a connected\nSNP sentence.\nProof. Let Φ be of the form ∃R1, . . . , Rk ∀x1, . . . , xl. φ where φ is a quantiﬁer-\nfree ﬁrst-order formula over the signature σ = (τ ∪{R1, . . . , Rk}).\nSuppose ﬁrst that Φ is connected, and that A1 and A2 both satisfy Φ. In other\nwords, there is a σ-expansion A∗\n1 of A1 and a σ-expansion A∗\n2 of A2 such that those\nexpansions satisfy ∀¯x.φ.\nWe claim that the disjoint union A∗of A∗\n1 and A∗\n2 also\nsatisﬁes ∀¯x.φ; otherwise, there would be a clause ψ in φ and elements a1, . . . , aq of\nA1 ∪A2 such that ψ(a1, . . . , aq) is false in A∗. Since A∗\n1 and A∗\n2 satisfy ∀¯x.ψ, there\nmust be i, j such that ai ∈A1 and aj ∈A2. But then the canonical database for ψ is\ndisconnected, a contradiction.\nFor the opposite direction of the statement, assume that the class of struc-\ntures that satisfy Φ is closed under disjoint unions.\nConsider the SNP sentence\nΨ = ∃R1, . . . , Rk, E. ∀x1, . . . , xl. ψ where ψ is the conjunction of the following clauses\n(we assume without loss of generality that l ≥3).\n\n20\n1. INTRODUCTION\n• For each relation symbol R ∈τ, say of arity p, and each i < j ≤p, add the\nconjunct ¬R(x1, . . . , xp) ∨E(xi, xj) to ψ.\n• Add the conjunct ¬E(x1, x2) ∨¬E(x2, x3) ∨E(x1, x3) to ψ.\n• Add the conjunct ¬E(x1, x2) ∨E(x2, x1) to ψ.\n• For each clause φ′ of φ with variables y1, . . . , yq ⊆{x1, . . . , xl}, add to ψ the\nconjunct\nφ′ ∨\n_\ni<j≤q\n¬E(yi, yj) .\nWe claim that the connected monotone SNP sentence Ψ is equivalent to Φ. Suppose\nﬁrst that A is a ﬁnite structure that satisﬁes Φ. Then there is a σ-expansion A′ of A\nthat satisﬁes ∀¯x.φ. The expansion of A′ by the relation E = A2 shows that A also\nsatisﬁes ∀¯x.ψ.\nNow suppose that A is a ﬁnite structure with domain A that satisﬁes Ψ. Then\nthere is a (σ ∪{E})-expansion A′ of A that satisﬁes ∀¯x.ψ. Write A′ = A′\n1 ⊎· · ·⊎A′\nl for\nconnected σ-structures A′\n1, . . . , A′\nl. Note that the clauses of ψ force that the relation\nE denotes A2\ni in the structure A′\ni, for each i ≤l. Let Ai be the σ-reduct of A′\ni. Then\nAi satisﬁes ∀¯x.φ, because if there was a clause φ′ from φ violated in Ai then the\ncorresponding clause in ψ would be violated in A′\ni. Hence, Ai |= Φ for all i ≤l, and\nsince Φ is closed under disjoint unions, we also have that A |= Φ.\n□\nTheorem 1.4.8 combined with the previous result shows the following.\nCorollary 1.4.11. An SNP sentence Φ describes a problem of the form CSP(B)\nfor an inﬁnite structure B if and only if Φ is equivalent to a monotone and connected\nSNP sentence Ψ.\nProof. Suppose ﬁrst that Φ is a monotone SNP sentence with connected clauses.\nTo show that Φ describes a problem of the form CSP(B) we can use Lemma 1.1.7.\nIt thus suﬃces to show that the class of structures that satisfy Φ is closed under\ndisjoint unions and inverse homomorphisms. But this has already been observed in\nTheorem 1.4.8 and Theorem 1.4.10.\nFor the implication in the opposite direction, suppose that Φ describes a prob-\nlem of the form CSP(B) for some inﬁnite structure B. In particular, the class of\nstructures that satisfy Φ is closed under inverse homomorphisms. By Theorem 1.4.8,\nΦ is equivalent to a monotone SNP sentence. Moreover, the class of structures that\nsatisfy Φ is closed under disjoint unions, and hence Φ is also equivalent to a connected\nSNP sentence. By inspection of the proof of Theorem 1.4.10, we see that when Φ is\nalready monotone, then the connected SNP sentence in the proof of Theorem 1.4.10\nwill also be monotone. It follows that Φ is also equivalent to a connected monotone\nSNP sentence.\n□\n1.4.4. Monadic SNP. When we further restrict monotone SNP by only al-\nlowing unary existentially quantiﬁed relations, the corresponding class of problems,\ncalled montone monadic SNP (or, short, MMSNP), gets very close to ﬁnite domain\nconstraint satisfaction problems. Indeed, Feder and Vardi showed that the class MM-\nSNP exhibits a complexity dichotomy if and only if the class of all ﬁnite domain CSPs\nexhibits a complexity dichotomy (that is, if the dichotomy conjecture mentioned in\nthe introduction is true). In one direction, this is obvious since MMSNP obviously\ncontains CSP(B) for all ﬁnite structures B (we may use a unary relation symbol for\neach element of B). In the other direction, Feder and Vardi showed that every prob-\nlem in MMSNP is equivalent under randomized Turing-reductions to a ﬁnite domain\nconstraint satisfaction problem. The reduction has subsequently been derandomized\nby Kun [141].\n\n1.4. THE EXISTENTIAL SECOND-ORDER PERSPECTIVE\n21\nTheorem 1.4.12 (of [95] and [141]; see [155] for a formalization). Every problem\nin monotone monadic SNP is polynomial-time Turing equivalent to CSP(B) for a\nﬁnite structure B.\nSimilarly as in the previous section, we might ask for a syntactic characterization\nof those monadic SNP sentences that describe a CSP. Note that this does not directly\nfollow from Corollary 1.4.11, since the reductions used there introduce additional\nexistentially quantiﬁed relations that are not monadic. However, we have the following\nmonadic version of Theorem 1.4.8.\nTheorem 1.4.13 (Theorem 3 in [96]). Let Φ be a monadic SNP sentence. Then\nthe class of structures that satisfy Φ is closed under inverse homomorphisms if and\nonly if Φ is equivalent to a monotone monadic SNP sentence.\nMoreover, one can show the following monadic version of Proposition 1.4.10.\nProposition 1.4.14. Let Φ be a monadic SNP sentence. Then the class of struc-\ntures that satisfy Φ is closed under disjoint unions if and only if Φ is equivalent to a\nconnected monadic SNP sentence.\nProof. Let V be the set of variables of the ﬁrst-order part φ of Φ, let P1, . . . , Pk\nbe the existential monadic predicates in Φ, and let τ be the input signature so that\nφ has signature {P1, . . . , Pk} ∪τ. If Φ is connected, then it describes a problem that\nis closed under disjoint unions; this follows from Theorem 1.4.10.\nFor the opposite direction, suppose that Φ describes a problem that is closed\nunder disjoint unions. We can assume without loss of generality that Φ is minimal in\nthe sense that if we remove literals from some of the clauses the resulting SNP sentence\nis inequivalent. We shall show that then Φ must be connected. Let us suppose that\nthis is not the case, and that there is a clause ψ in φ that is not connected. The\nclause ψ can be written as ψ1 ∨ψ2 where the set of variables X ⊂V of ψ1 and the\nset of variables Y ⊂V of ψ2 are non-empty and disjoint.\nConsider the formulas\nΦX and ΦY obtained from Φ by replacing ψ by ψ1 and ψ by ψ2, respectively. By\nminimality of Φ there is a τ-structure A1 that satisﬁes Φ but not ΦX, and similarly\nthere exists a τ-structure A2 that satisﬁes Φ but not ΦY . By assumption, the disjoint\nunion A of A1 and A2 satisﬁes Φ. So there exists a τ ∪{P1, . . . , Pk}-expansion A′\nof A = A1 ⊎A2 that satisﬁes the ﬁrst-order part of Φ. Consider the substructures\nA′\n1 and A′\n2 of A′ induced by A1 and A2, respectively. We have that A′\n1 does not\nsatisfy ψ1 (otherwise A1 would satisfy ΦX). Consequently, there is an assignment\ns1 : V →A1 of the universal variables that falsiﬁes ψ1.\nBy similar reasoning we\ncan infer that there is an assignment s2 : V →A2 that falsiﬁes ψ2. Finally, ﬁx any\nassignment s: V →A1 ∪A2 that coincides with s1 over X and with s2 over Y (such\nan assignment exists because X and Y are disjoint). Clearly, s falsiﬁes ψ and A does\nnot satisfy Φ, a contradiction.\n□\nSimilarly as in Corollary 1.4.11 for SNP, we can combine the conditions of closure\nunder inverse homomorphisms and closure under disjoint unions, and arrive at the\nfollowing.\nCorollary 1.4.15. A monadic SNP sentence Φ describes a problem of the form\nCSP(B) for an inﬁnite structure B if and only if Φ is equivalent to a connected\nmonotone monadic SNP sentence.\nWe want to remark that the problems that can be described by connected mono-\ntone monadic SNP sentences are exactly the problems called forbidden patterns prob-\nlems in the sense of Madelaine [154]. Clearly, for every ﬁnite B the problem CSP(B)\nis a forbidden patterns problem. In [157] is has been shown that the problems in\n\n22\n1. INTRODUCTION\nMMSNP are exactly ﬁnite unions of forbidden patterns problems (going back to ideas\nfrom [95]).\nWe summarize the landscape of classes of computational problems from this sec-\ntion in Figure 1.6.\nSNP\nmonotone \nSNP\nconnected \nSNP\nSNP ∩ CSP(B) =\nconnected monotone SNP\nconnected \nmonotone \nmonadic SNP\nCSP(B) for ﬁnite B\nmonotone \nmonadic SNP\nNP\nFigure 1.6. Fragments of SNP.\n1.5. Examples\nWe present computational problems that have been studied in various areas of\ntheoretical computer science, and that can be formulated as constraint satisfaction\nproblems in the sense of Section 1.1, 1.2, 1.3, or 1.4.\nWe describe each problem\nfrom the perspective in which the computational problem has appeared ﬁrst in the\nliterature.\nOur list is by far not exhaustive; computational problems that can be exactly\nformulated as CSP(B) for an inﬁnite structure B are abundant in almost every area\nof theoretical computer science.\n1.5.1. Allen’s interval algebra. Allen’s interval algebra [5] is a formalism that\nis famous in artiﬁcial intelligence, and which has been introduced to reason about\nintervals and about the relationships between intervals.\nFormally, Allen’s interval algebra is a proper relation algebra (see Section 1.3.2);\nwe can also view it as a structure with a binary relational signature. The domain is\nthe set I of all closed intervals [a, b] of rational numbers, where a, b ∈Q, a < b. When\nx = [a, b] is an interval, then −x denotes the interval [−b, −a]. For R ⊆Q2, R−\ndenotes the relation {(−x, −y) | (x, y) ∈R}. Recall that in proper relation algebras,\nR⌣denotes the relation {(y, x) | (x, y) ∈R}.\nThe basic relations of Allen’s interval algebra are the 13 relations P, M, O, S, D, E\n(deﬁned in Figure 1.7), P −, M −, O−, S−, and the inverse of S, D, and S−, denoted by\nS⌣, D⌣, and (S−)⌣, respectively. Note that those 13 relations are pairwise disjoint,\nand that their union equals I2. Recall our convention that when R is a subset of the\n\n1.5. EXAMPLES\n23\nRelation Symbol\nDeﬁnition\nExplanation\nP\n{([a, b], [c, d]) | b < c}\n[a, b] preceeds [c, d]\nM\n{([a, b], [c, d]) | b = c}\n[a, b] meets [c, d]\nO\n{([a, b], [c, d]) | a < c < b < d}\n[a, b] overlaps with [c, d]\nS\n{([a, b], [c, d]) | a = c and b < d}\n[a, b] starts [c, d]\nD\n{([a, b], [c, d]) | c < a < b < d}\n[a, b] is during [c, d]\nE\n{([a, b], [c, d]) | a = c, b = d}\n[a, b] equals [c, d]\nFigure 1.7. The deﬁnitions for the basic relations of Allen’s interval algebra.\nbasic relations, we write xRy if (x, y) ∈S\nR∈R R. For example, x{P, P −}y signiﬁes\nthat the intervals x and y are disjoint. The 213 relations that arise in this way will\nbe called the relations of Allen’s interval algebra.\nAn important computational problem for Allen’s interval algebra is the network\nsatisfaction problem for Allen’s interval algebra.\nThis problem can be viewed as\nCSP(A) where A is a structure with domain I and a signature containing 213 binary\nrelation symbols (see Section 1.3.2). More on this structure can be found in Chapter 3,\nExample 3.1.11. We are sometimes sloppy and write Allen’s interval algebra when we\nmean A (rather than A).\nThe problem CSP(A) is NP-complete [5]. The complexity of the CSP for (binary)\nreducts of Allen’s interval algebra has been completely classiﬁed in [140].\n1.5.2. Phylogenetic reconstruction problems. In modern biology it is be-\nlieved that the species in the evolution of life on earth developed in a mostly tree-like\nfashion: at certain time periods, species separated into sub-species.\nThe goal of\nphylogenetic reconstruction is to determine the evolutionary tree from given partial\ninformation about the tree. This motivates the computational problem of rooted triple\nsatisﬁability (also called rooted triple consistency), deﬁned below. In 1981, Aho, Sa-\ngiv, Szymanski, and Ullman [4] presented a quadratic time algorithm to this problem,\nmotivated independently from computational biology by questions in database theory.\nLet T be a tree with vertex set T and with a distinguished vertex r, the root of\nT. For u, v ∈T, we say that u lies below v if the path from u to r passes through v.\nWe say that u lies strictly below v if u lies below v and u ̸= v. The youngest common\nancestor (yca) of two vertices u, v ∈T is the node w such that both u and v lies below\nw and w has maximal distance from r.\nRooted-Triple Satisﬁability\nINSTANCE: A ﬁnite set of variables V , and a set of triples xy|z for x, y, z ∈V .\nQUESTION: Is there a rooted tree T with leaves L and a mapping s: V →L such\nthat for every triple xy|z the yca of s(x) and s(y) lies strictly below the yca of s(x)\nand s(z) in T?\nAnother famous problem that has been studied in this context is the quartet\nsatisﬁability problem, which is NP-complete [189].\nQuartet Satisﬁability\nINSTANCE: A ﬁnite set of variables V , and a set of quartets xy:uv with x, y, u, v ∈V .\nQUESTION: Is there a tree T with leaves L and a mapping s: V →L such that for\nevery quartet xy:uv ∈Ryca the shortest path from x to y is disjoint to the shortest\npath from u to v?\n\n24\n1. INTRODUCTION\n◦\n=\n<\n>\n|\n=\n=\n<\n>\n|\n<\n<\n<\n{<, =, >}\n{<, |}\n>\n>\n1\n>\n|\n|\n|\n|\n{>, |}\n1\nFigure 1.8. The composition table for the basic relations in the\nleft-linear point algebra.\nIt is straightforward to check that the class of positive instances (viewed as rela-\ntional structures) of each of those two computational problems is closed under disjoint\nunions and inverse homomorphisms. By Lemma 1.1.7, both the rooted triple satis-\nfaction problem and the quartet satisfaction problem can be formulated as CSP(B)\nfor an inﬁnite structure B. We come back to those CSPs in Chapter 4.\n1.5.3. Branching-time constraints. An important model in temporal reason-\ning is branching time, where for every time point the past is linearly ordered, but the\nfuture is only partially ordered.\nThis motivates the so-called left-linear point algebra [88,117], which is a relation\nalgebra with four basic relations, denoted by =, <, >, and |.\nHere we imagine\nthat ‘x < y’ signiﬁes that x is earlier in time than y, and to the left of y when we\ndraw points in the plane, and this motivates the name left linear point algebra. The\ncomposition operator on those four basic relations is given in Figure 1.8. The inverse\nof < is >, Id denotes =, and | is its own inverse, and the relation algebra is uniquely\ngiven by this data.\nAs explained in Section 1.3.2, the network consistency problem for the left-linear\npoint algebra can be viewed as CSP(B) for an appropriate inﬁnite structure with\n16 = 24 binary relations (one for each subset of {=, <, >, |}). In this structure, for\nevery x the set {y | y < x} is linearly ordered by by <. An explicit example of such a\nstructure is given in Section 4.2. The network consistency problem of the left-linear\npoint algebra is polynomial-time equivalent to the following problem, which we call\nbranching-time satisﬁability problem.\nBranching-Time Satisﬁability\nINSTANCE: A ﬁnite relational structure A = (A; ≤, ∥, ̸=) where ≤, ∥, and ̸= are\nbinary relations.\nQUESTION: Is there a rooted tree T and a mapping s: A →T such that in T the fol-\nlowing is satisﬁed: a) If (x, y) ∈≤A, then s(x) lies above s(y); b) If (x, y) ∈||A, then\nneither s(x) lies strictly above s(y), nor s(y) strictly above s(x); c) If (x, y) ∉=A,\nthen s(x) ̸= s(y).\nThe idea why this problem is polynomial-time equivalent to the network satisfac-\ntion problem of the left-linear point algebra is the observation that in any represen-\ntation B of the left-linear point algebra, the relation x{<, >, =}y has the primitive\npositive deﬁnition\n∃z (x{<, =}z ∧y{<, =}z) ,\nand the relation x{<, |, =}y has the primitive positive deﬁnition\n∃z (x{<, =}z ∧z{|, =}y) ;\nwe can then use Theorem 1.2.6 (for details, see [44]).\nThe branching-time satisﬁability problem can be formulated as CSP(C) for the\nstructure with domain C := {0, 1}∗and relations ≤, ∥, and ̸=, where ≤denotes the\n\n1.5. EXAMPLES\n25\n◦\n=\n<\n>\n≺\n≻\n=\n=\n<\n>\n≺\n≻\n<\n<\n<\n{<, >}\n{<, ≺}\n{<, ≻}\n>\n>\n1\n>\n≺\n≻\n≺\n≺\n≺\n{>, ≺}\n≺\n1\n≻\n≻\n≻\n{>, ≻}\n1\n≻\nFigure 1.9. The composition table for the basic relations of Cor-\nnell’s tree algebra C.\nrelation\n{(u, v) ∈C2 | u is a preﬁx of v} .\nThe relation ̸= is the disequality relation, and u ∥v holds if u and v are equal or\nincomparable with respect to ≤. Let < denote the intersection of ≤and ̸=. Note\nthat the structure C can not be used to obtain a representation of the left-linear point\nalgebra, since (<) ◦(<) does not equal <.\nThe ﬁrst polynomial-time algorithm for the branching-time consistency problem\n(and therefore also for the network satisfaction problem of the left-linear point alge-\nbra) is due to Hirsch [117], and has a worst-case running time in O(n5). This has\nbeen improved by Broxvall and Jonsson [59], who presented an algorithm running in\nO(n3.376) (this algorithm uses an O(n2.376) algorithm for fast integer matrix multipli-\ncation). A simpler algorithm which does not use fast matrix multiplication and runs\nin O(nm) has been found in [43].\n1.5.4. Cornell’s tree description constraints. Motivated by problems in\ncomputational linguistics, Cornell [78] introduced the following computational prob-\nlem5. It is a strictly more expressive problem than the branching time satisfaction\nproblem from the previous section, but has been introduced independently from [117]\nand [59]. There are many equivalent formulations of this problem. One is as the gen-\neral network satisfaction problem for the relation algebra C with atoms =, <, >, ≺,\nand ≻which is given by the composition table in Figure 1.9. The idea is that < de-\nnotes a dense semilinear order (see Section 1.5.3), and ≺∪< denotes a linear order.\nThe idea how to use this in natural language grammar formalisms like dependency\ngrammars is that < represents the syntactic structure of a natural language sentence\nwhereas ≺∪< stands for the word order.\nSimilarly as in Section 1.5.3, all 25 relations of C can be obtained by repeated\ncompositions and intersections of the four relations {<, =}, {≺, =}, {≺, ≻, =}, and\n{<, >, ≺, ≻}; for details, see [44]. The algorithm presented for the general network\nsatisfaction problem for C in [78] is not complete. A polynomial-time algorithm has\nbeen found in [44].\n1.5.5. Set constraints. Many fundamental problems in artiﬁcial intelligence,\nknowledge representation, and veriﬁcation involve reasoning about sets and relations\nbetween sets and can be modeled as constraint satisfaction problems. One of the most\nfundamental problems of this type is the following. We denote the set of all subsets\nof N by P(N).\nBasic Set Constraint Satisﬁability\nINSTANCE: A ﬁnite set of variables V , and a set φ of constraints of the form x ⊆y,\nx || y, or x ̸= y, for x, y ∈V .\n5I feel personally committed to Cornell’s problem since it was the ﬁrst CSP with an ω-categorical\ntemplate I met.\n\n26\n1. INTRODUCTION\nQUESTION: Is there a mapping s: V →P(N) such that\na) If x ⊆y is in φ, then s(x) is contained in s(y);\nb) If x || y is in φ, then s(x) and s(y) are disjoint sets;\nc) If x ̸= y is in φ, then s(x) and s(y) are distinct sets.\nThis problem has the shorter description CSP((P(N); ⊆, ||, ̸=)) where ⊆, ||, ̸= are\nbinary relations over P(N), standing for the binary relations containment, disjointness,\nand inequality between sets.\nDrakengren and Jonsson [85] showed that basic set\nconstraint satisﬁability can be decided in polynomial time. They also showed that the\ngeneralization of the problem can be solved in polynomial time where each constraint\nhas the form\nx1 ̸= y1 ∨· · · ∨xk ̸= yk ∨x0Ry0\nwhere R is either ⊆, ||, or ̸=, and where x0, . . . , xk, y0, . . . , yk are not necessarily\ndistinct variables.\n1.5.6. Spatial reasoning. Qualitative spatial reasoning (QSR) is concerned\nwith representation formalisms that are considered close to conceptual schemata used\nby humans for reasoning about their physical environment—in particular, about pro-\ncesses or events and about the spatial environment in which they are situated. The\napproach in qualitative reasoning is to develop relational schemas that abstract from\nconcrete metrical data of entities (for example time points, coordinate positions, or\ndistances) by subsuming similar metric or topological conﬁgurations of entities into\none qualitative representation.\nThere are many formalisms for qualitative spatial reasoning. In particular, sev-\neral relation algebras (see Section 1.3.2) have been studied in this context. A basic\nexample is the RCC5 relation algebra (with 5 atoms; the RCC5 relation algebra is\nalso known under the name containment algebra [21,88]), and the RCC8 relation al-\ngebra (with 8 atoms). In both formalisms, the variables denote ‘non-empty regions’.\nIn RCC5, the ﬁve atoms are denoted by DR, PO, PP, PPI, EQ, and they stand\nfor disjointness, proper overlap, proper containment (proper-part-or), its inverse, and\nequality, respectively. In RCC8, we further distinguish how the ‘boundaries’ of two\nregions relate to each other. We do not further discuss RCC8, for details, see [55,88].\nThere are many equivalent ways to formally deﬁne RCC5. Often, this is done\nby specifying the composition table for atomic relations, but we ﬁnd this tedious.\nHere, we rather deﬁne RCC5 as the proper relation algebra whose domain are all\nopen (or all closed) disks in R2, and where the basic relations are disjointness (empty\nintersection), proper overlap, containment, the inverse of containment, and equality\nof disks. Then RCC5 is the abstract relation algebra of the proper relation algebra\nof closed disks (see Section 2.1.5 in [88]).\nThe network satisfaction problem for RCC5 is NP-complete; the computational\ncomplexity of the CSP for the (binary) reducts of B has been classiﬁed in [127,179].\nA polynomial-time tractable case of particular interest is the network satisfaction\nproblem for the basic relations of RCC5 [179], i.e., the network satisfaction problem\nfor RCC5 when the input is restricted to networks N = (V ; f) where f maps to 1 or\nthe atoms in RCC5 only.\nIn any representation of RCC5, the atomic relations satisfy the following set of\naxioms T. We use P(x, y) as a shortcut for PP(x, y) ∨EQ(x, y).\n\n1.5. EXAMPLES\n27\nT :=\n\b\n∀x, y, z (DC(x, y) ∧P(z, y) →DC(x, z))\n∀x, y, z (PO(x, y) ∧P(y, z) →(PO(x, z) ∨PP(x, z)))\n∀x, y, z (PP(x, y) ∧PP(y, z) →PP(x, z))\n∀x, y, z (P −1(x, y) ∧P(y, z) →¬DC(x, y))\n\t\nIt is easy to see that the network satisfaction problem for the basic relations of\nRCC5 is essentially the same problem as CSP(T), where T is the ﬁrst-order theory\ndeﬁned as above. It can be checked easily that T satisﬁes item (2) in the statement\nof Proposition 1.3.6, and hence there exists an inﬁnite structure B such that CSP(B)\nequals the satisﬁability problem for RCC5. We will give more explicit descriptions of\nsuch an inﬁnite structure B in Chapter 4 (and it turns out that there are close links\nwith the problem from Section 1.5.5).\n1.5.7. Horn-SAT. The following problem is an important P-complete prob-\nlem [67]. It can be solved in linear time in the size of the input [84].\nHorn-SAT\nINSTANCE: A propositional formula in conjunctive normal form (CNF) with at most\none positive literal per clause.\nQUESTION: Is there a Boolean assignment for the variables such that in each clause\nat least one literal is true?\nWe cannot model this problem as CSP(B) for a ﬁnite signature structure; how-\never, note that a clause ¬x1 ∨· · · ∨¬xk ∨x0 is equivalent to\n∃y1, . . . , yk−1\n\u0000(¬x1 ∨¬x2 ∨y1) ∧(¬y1 ∨¬x3 ∨y2) ∧· · · ∧(¬yk−1 ∨¬xk ∨x0)\n\u0001\n.\nHence, by introducing new variables, there is a straightforward reduction of Horn-\nSAT to the restriction of Horn-SAT where every clause has at most three literals. This\nrestricted problem, which we call Horn-3SAT, can be formulated as CSP(B) for\nB =\n\u0000{0, 1};{(x, y, z) | (x ∧y) ⇒z}, {(x, y, z) | ¬x ∨¬y ∨¬z},\n{((x, y) | x ⇒y}, {((x, y) | ¬x ∨¬y}, {0}, {1}\n\u0001\n.\n1.5.8. Precedence constraints in scheduling. The following problem has\nbeen studied in [164] in scheduling: given is a ﬁnite set of variables V , and a ﬁnite\nset of and/or precedence constraints, i.e., constraints of the form\nx0 > x1 ∨· · · ∨x0 > xk\n(6)\nfor x0, x1, . . . , xk ∈V . The question is whether there exists an assignment V →Q\n(equivalently, we can replace Q by Z, or any other inﬁnite linearly ordered set).\nAs in the case of Horn-SAT, we cannot directly model this problem as CSP(B)\nfor a ﬁnite signature structure B. However, note that Formula (6) is equivalent to\n∃y1, . . . , yk−1\n\u0000(x0 > x1 ∨x0 > y1)∧\n(y1 > x2 ∨y1 > y2) ∧· · · ∧(yk−1 > xk−1 ∨yk−1 > xk)\n\u0001\n.\nThis shows that and/or precedence constraints can be translated into conjunctions\nof constraints of the form x0 > x1 ∨x0 > x2 by introducing new existentially quan-\ntiﬁed variables. Hence, the problem whether a given set of and/or precedence con-\nstraints is satisﬁable reduces naturally to CSP((Q; Rmin)) where Rmin is the ternary\nrelation {(a, b, c) | a > b ∨a > c}. Note that Rmin holds on exactly those triples\n(a, b, c) where a is larger than the minimum of b and c. The problem CSP((Q; Rmin))\ncan be solved in polynomial time; this is essentially due to [164]. For more expressive\n\n28\n1. INTRODUCTION\nconstraint languages over Q that contain the relation Rmin and whose CSP can still\nbe solved in polynomial time, see Section 10.5.2 or Section 10.4.1.\n1.5.9. Ord-Horn constraints. In this section we work with ﬁrst-order formulas\nover the signature {<}. We write x ≤y as a shortcut for (x < y) ∨(x = y) (recall\nour convention that equality is part of ﬁrst-order logic). A formula over the signature\n{<} and with variables V is called Ord-Horn if it is a conjunction of disjunctions of\nthe form\n(x1 = y1) ∨· · · ∨(xk = yk) ∨(x0Ry0)\nwhere x0, x1, . . . , xk, y0, y1, . . . , yk ∈V , and R is either ≤, <, ̸=, or =.\nOrd-Horn Satisﬁability\nINSTANCE: A ﬁnite set of variables V , and a ﬁnite set of Ord-Horn formulas with\nvariables from V .\nQUESTION: Is there an assignment V →Q that satisﬁes all the given formulas over\n(Q; <)?\nNebel and B¨urckert [165] showed that Ord-Horn Satisﬁability can be solved in\npolynomial time. A relation R ⊆Qk is called Ord-Horn if it is deﬁnable by an Ord-\nHorn formula over (Q; <). As in the case of Horn-SAT and of and/or precedence\nconstraints, there are structures B with ﬁnitely many Ord-Horn relations such that\nall Ord-Horn relations have a primitive positive deﬁnition in B. It can be shown that\nthe following structure has this property (see Chapter 6).\n\u0000Q; ≤, ̸=, {(x, y, u, v) | (x = y) ⇒(u = v)}\n\u0001\nIn Section 10.4.1 we see that constraint languages that contain and/or precedence\nconstraints and Ord-Horn constraints can still be solved in polynomial time.\n1.5.10. Ord-Horn interval constraints. For some (binary) reducts B of Allen’s\ninterval algebra the problem CSP(B) can be solved in polynomial time. The most im-\nportant of these reducts is the class of Ord-Horn interval constraints, which has been\nintroduced by Nebel and B¨urkert [165]. It consists of all the relations R of Allen’s\ninterval algebra such that the relation\n\b\n(x, y, u, v) | ([x, y], [u, v]) ∈R\n\t\nis Ord-Horn\n(see Section 1.5.9). Now it is not hard to see that satisﬁability for Ord-Horn interval\nconstraints has a polynomial-time reduction to Ord-Horn satisﬁability. This type of\nreduction will be studied in Section 5.5.\n1.5.11. Linear program feasibility. Linear Programming is a computational\nproblem of outstanding theoretical and practical importance (see e.g. [185]). It is\nknown to be computationally equivalent to the problem to decide whether a given set\nof linear (non-strict) inequalities is feasible, i.e., deﬁnes a non-empty set.\nLinear Program Feasibility\nINSTANCE: A ﬁnite set of variables V ; a ﬁnite set of linear inequalities of the form\na1x1 + · · · + akxk ≤a0 where x1, . . . , xk ∈V and a0, . . . , ak are rational numbers\nwhere numerator and denominator are represented in binary.\nQUESTION: Does there exist an x ∈R|V | that satisﬁes all inequalities?\nKachyian showed in [134] that Linear Program Feasibility can be solved in poly-\nnomial time. It is clearly not possible to formulate this problem as CSP(B) for a\nstructure B with a ﬁnite relational signature. However, we show below that it is\npolynomial-time equivalent to CSP\n\u0000(R; {(x, y, z) | x + y = z}, {1}, ≤)\n\u0001\n. For this, we\nneed the following lemma.\n\n1.5. EXAMPLES\n29\nLemma 1.5.1 (from [38]). Let n0, . . . , nl ∈Q be arbitrary rational numbers. Then\nthe relation {(x1, . . . , xl) | n1x1 + . . . + nlxl = n0} is primitive positive deﬁnable in\n(R; {(x, y, z) | x + y = z}, {1}).\nFurthermore, the primitive positive formula that\ndeﬁnes the relation can be computed in polynomial time.\nThe idea to prove this is to use iterated doubling to deﬁne large numbers with\nsmall primitive positive formulas. By extending the previous result to inequalities,\none can prove the following.\nProposition 1.5.2 (from [38]). The linear program feasibility problem for linear\nprograms is polynomial-time equivalent to CSP((R; {(x, y, z) | x + y = z}, {1}, ≤)).\n1.5.12. The max-atoms problem. In our list of problems from the literature\nthat can be formulated as CSP(B), we also want to include one problem in NP where\nit is not known whether CSP(B) is in P or NP-hard. Our problem is closely related to\nthe following problem, which has been introduced in [23] and, independently, in [164].\nThe Max-Atoms Problem\nINSTANCE: A ﬁnite set of variables V ; a ﬁnite set of constraints of the form x0 ≤\nmax(a1x1, . . . , akxk) where x1, . . . , xk ∈V and a0, . . . , ak (the coeﬃcients) are inte-\ngers represented in binary.\nQUESTION: Does there exist an x ∈Q|V | that satisﬁes all inequalities?\nIt is known that the Max-atoms problem is computationally equivalent to mean-\npayoﬀgames [164], and therefore it is contained in NP ∩coNP. It also follows that\ndeciding the winner in Parity games and satisﬁability of the propositional µ-calculus\ncan be reduced to the max-atoms problem.\nBezem, Nieuwenhuis and Rodr´ıguez-\nCarbonell [23] give an alternative proof that the problem is in NP ∩coNP. In the\nsame paper, they also shown that a certain hypergraph reachability problem, and\nan intensively studied problem in max/+ algebra are equivalent to the max-atoms\nproblem. Moreover, they show that the problem is in P when the coeﬃcients in the\ninput are represented in unary.\nSimilarly as for linear program feasibility, the Max-atoms problem cannot be\nformulated as CSP(B) for a structure B with a ﬁnite relational signature.\nThe\nproblem we introduce instead is\nCSP((Q; {(x, y) | y = x + 1}, {(x, y) | y = 2x}, Rmin\n≤\n))\nwhere Rmin\n≤\n= {(x, y, z) | x ≥y ∨x ≥z} is a variant of the relation Rmin from\nSection 1.5.8. The max-atoms problem can be reduced to this problem: we replace\nexpressions of the form xi + ai by a new variable yi, and add a primitive positive\nformula φ(x, y) that deﬁnes yi = xi + ai and can be computed in polynomial time in\nthe input size of the max-atoms problem. We do not know how to prove hardness for\nthe CSP above, and rather think that the problem might well be in P.\n1.5.13. Uniﬁcation. Uniﬁcation (and uniﬁcation modulo equational theories)\nis an proper ﬁeld in computational logic, and the complexity of the uniﬁcation problem\nhas been studied in numerous variants [10]. Many uniﬁcation problems can be viewed\nas CSP(B), for an appropriate inﬁnite structure B, as we will see in the following.\nWe start with the most fundamental uniﬁcation problem.\nLet σ := {f1, . . . , fk} be a ﬁnite set function symbols, and let x be a variable\nsymbol. Then F(x) denotes the set of all terms that can be constructed from τ and\nthe variable x. The unnested uniﬁcation problem over τ is the following problem6.\n6This problem is known to be equivalent to the standard uniﬁcation problem where the input\nis a single equation t1 ≈t2 for ‘nested’ terms t1, t2 ∈F(x).\n\n30\n1. INTRODUCTION\nUnnested Uniﬁcation Problem over τ\nINSTANCE: a ﬁnite set of variables V , and a ﬁnite set of ‘un-nested’ term equations,\ni.e., expressions of the form y0 ≈f(y1, . . . , yk) for y0, y1, . . . , yk ∈V and f ∈τ.\nQUESTION: is there an assignment s: V →F(x) such that for every expression\ny0 = f(y1, . . . , yk) in the input we have s(y0) = f(s(y1), . . . , s(yk))?\nFor ﬁxed τ as above, let T = (F(x); F1, . . . , Fk) be the structure where Fi is the\nrelation {(t0, t1, . . . , tr) ∈(F(x))r+1 | t0 = fi(t1, . . . , tr)} (here, r is the arity of fi).\nIt is clear that the unnested uniﬁcation problem over τ can be described as CSP(T).\nIn a similar way, equational uniﬁcation problems (see [10]) can be viewed as CSPs.\n1.6. Overview\nThis text develops the universal-algebraic approach for complexity analysis of\nconstraint satisfaction problems with countably inﬁnite ω-categorical templates. Parts\nof the corresponding theory follow or generalize the universal-algebraic approach for\nCSPs with ﬁnite templates, whereas other parts are speciﬁc to inﬁnite domains, such\nas the way in which we apply Ramsey theory.\nWe then present two complexity\nclassiﬁcation results that have been obtained using this approach: the classiﬁcation\nof temporal CSPs in Chapter 10, and Schaefer’s theorem for graphs in Chapter 9.\nWe close with Chapter 11 on classes of computational problems that probably do not\nexhibit a complexity dichotomy.\nPublication Note. My PhD-thesis [24] also treated constraint satisfaction with\nω-categorical templates, and already hinted at the relevance of polymorphisms and\nuniversal algebra. But it is only here that we fully present the universal-algebraic ap-\nproach and its applications for classiﬁcation projects of large classes of inﬁnite-domain\nconstraint satisfaction problems. The self-contained presentation in this thesis is col-\nlecting and re-combining results that have been fragmented over various publications,\nand often come with new proofs.\nParts of the content of this thesis have been published by co-authors and myself\nin conferences or journals. The example sections in Chapter 1 and Chapter 4 present\nCSPs studied in [25, 31, 34, 37, 44, 45, 55]. Chapter 3 contains a new proof, to be\npublished in the journal version of [35], of the main result in [25]. Chapter 5 covers\noriginal results from [47], [27], and the survey [26]. Many results in Chapter 8 are\nfrom [54] and the survey [50].\nThe classiﬁcation for equality constraint satisfaction problems has ﬁrst been ob-\ntained in [40], but the proof presented here is new and borrows results and ideas\nfrom [29] and [51]. The classiﬁcation for temporal constraint satisfaction problems\nin Chapter 10 is based on [41] and [42], with some additions from the survey [50].\nSchaefer’s theorem for graphs is based on [52] and [51], again with additions from [50]\nFinally, Chapter 11 also contains some results from [33].\n1.7. Uncovered Topics\nWhen choosing the material to be included in this thesis, certain restrictive choices\nhad to be made. We comment on related lines of research or facets of the area that\nwe had to skip.\n1.7.1. Inﬁnite Signatures. Several natural computational problems could be\nformulated in the form CSP(B) when we would allow that the structure B has a count-\nably inﬁnite signature. For example, we might want to view the feasibility problem\nfor linear programs (Section 1.5.11) as CSP(B) where B contains all relations of the\nform {(x1, . . . , xk) | a1x1 + · · · + akxk ≤a0}, for all rational numbers a0, a1, . . . , ak.\n\n1.7. UNCOVERED TOPICS\n31\nIndeed, several general results for constraint satisfaction that we present in this thesis\nwould carry over to inﬁnite signatures with no problems.\nIf we wanted to extend the present deﬁnition of CSP(B) to structures B with an\ninﬁnite signature, we are faced with the diﬃculty to specify how the constraints in\ninput instances of CSP(B) are represented. When B has a ﬁnite signature, this causes\nno problems, since we can ﬁx any representation for the ﬁnite number of relation\nsymbols; since B is considered to be ﬁxed, the precise choice of the representation\nis irrelevant.\nWhen B has an inﬁnite signature, a good choice how to code the\nconstraints in the input very much depends on the structure B. In the example of\nlinear programming feasibility, for instance, we might want to represent the constraint\na1x1 + · · · + akxk ≤a0 by specifying the coeﬃcients a0, a1, . . . , ak in binary.\nNote that the issue of ﬁnite versus inﬁnite constraint languages is not speciﬁc\nto inﬁnite domains, but becomes relevant already for ﬁnite domains. Typically, for\ninﬁnite constraint languages over a ﬁnite domain each constraint in the input is rep-\nresented by listing all tuples of the corresponding relation in the constraint language.\nBut this is not the only, and sometimes not even the most natural way to represent the\nconstraints. For instance for the Horn-SAT problem (see Section 1.5.7), the most nat-\nural way to present the constraint is by writing them as conjunctions of Horn-clauses.\nIn the general setting, several representations have been proposed, some of which are\nmore concise than listing all tuples [74], and some of which are less concise [161].\nIt turns out that typically when a constraint satisfaction problem with an inﬁnite\nconstraint language is computationally hard, then there is a ﬁnite set of relations in\nthis language such that the CSP for this sub-language is already NP-hard. For inﬁnite\nconstraint languages over a ﬁnite domain, and when the constraints are represented\nby explicitly listing all satisfying assignments to the variables of the constraint, it\nhas even been conjectured [65] that this might be true in general; that is, when\nCSP(B) is NP-hard under this representation, then B has a ﬁnite signature reduct\nwith a hard CSP. This conjecture is still open. We also want to mention a conditional\nnon-dichotomy result for inﬁnite constraint languages from [33].\nWe have decided to keep in this thesis the focus on CSPs for ﬁnite constraint\nlanguages, for the following reasons.\nThis allows to work with one and the same\ndeﬁnition of the computational problem CSP(B) for all inﬁnite structures B with a\nﬁnite signature. Moreover, for all of the algorithms presented in this thesis it will be\nimmediately clear under which input assumption they might be generalized to deal\nwith an inﬁnite constraint language. This does not prevent us from stating relevant\nmathematical facts in full generality when they also hold for structures with an inﬁnite\nsignature; only when it comes to statements about CSP(B) we insist that B has ﬁnite\nrelational signature.\n1.7.2. Complexity classes below P. Besides the mentioned progress on the\ndichotomy conjecture for ﬁnite domain CSPs, there has been considerable research\nactivity to localize the exact complexity of CSPs inside the complexity class P, or\nwith respect to deﬁnability in certain logics. By deﬁnability of CSP(B) we mean that\nthere exists a sentence Φ is some logic (typically extensions of ﬁrst-order logic and\nrestrictions of least ﬁxed point logics) such that A |= Φ if and only if A homomorphi-\ncally maps to B (that is, in this case it is most natural to consider the deﬁnitions of\nthe CSP presented in Section 1.1 and in Section 1.4).\nOne motivation for studying computational complexity within P is the question\nwhether it is possible to solve problems faster in parallel models of computation.\nAnother motivation, in particular for deﬁnability of CSPs in certain logics, is the goal\nto better understand the scope of existing algorithmic techniques to solve CSPs (such\nas Datalog, or restrictions of Datalog).\n\n32\n1. INTRODUCTION\nIn this line of research, the computational complexity of CSP(B) has been com-\npletely classiﬁed when B is a two-element structure [6]. Each problem in this class\nis complete for one of the complexity classes NP, P, ⊕L, NL, L, and AC0 under\nAC0 isomorphisms. For general ﬁnite domains, several universal-algebraic conditions\nare known that imply hardness for various complexity classes [9, 145]. Concerning\ndeﬁnability of CSPs, there are precise characterizations of those CSPs that are de-\nﬁnable by a ﬁrst-order sentence [8,144,180]. Moreover, if CSP(B) is not ﬁrst-order\ndeﬁnable, then it is L-complete under AC0-reductions [145] (also see [82, 92]). For\ninﬁnite domain constraint satisfaction, it appears that there are no general results\nabout localizing the complexity of CSPs within the complexity class P yet. However,\nwe would like to remark that already in some concrete and model-theoretically well-\nbehaved structures B the precise complexity of CSP(B) within P is open. We give\none example.\nExample 1.7.1. Consider the problem\nCSP((Q; ̸=, {(x, y, z) | (x = y ⇒y ≤z) ∧x ≤y)) .\nThis problem is NL-hard since there is an easy reduction from directed reachability\nto this problem, and directed reachability is an NL-complete problem. By careful\ninspection of Tarjan’s linear-time algorithm for strongly connected components [191]\nwe see that the problem can be solved in linear time. However, the precise complexity\nof this problem is not known; it might be that the problem is contained in NL, but it\nmight also be P-hard.\n1.7.3. Quantiﬁed CSPs. Let B be a structure with a ﬁnite relational signature.\nThen the quantiﬁed constraint satisfaction problem for B, denoted QCSP(B), is the\ncomputational problem to decide for a given ﬁrst-order sentence φ in prenex normal\nform and without disjunction and negation symbols whether φ is true in B. The\ndiﬀerence of QCSP(B) from CSP(B) as we have presented it in Section 1.1 is that\nuniversal quantiﬁcation is permitted in the input sentences φ.\nThe additional expressiveness often comes at the prize of higher computational\ncomplexity; whereas for ﬁnite structures B, the CSP for B is always in NP, there\nare ﬁnite structures B where QCSP(B) is PSPACE-complete.\nBut quite surpris-\ningly, several constraint languages with a polynomial-time tractable CSP also have a\npolynomial-time QCSP. This is for instance the case for 2SAT [7] (see Example 1.2.2),\nor for Horn-3SAT [130] (see Section 1.5.7). Similarly, it can be shown that the tem-\nporal constraint languages presented in Section 10.5.2 and Section 10.5.5 are not only\ntractable for the CSP, but also for the QCSP. These are attractive results, since they\nassert that we can solve an even more expressive computational problem than the\nCSP for the same constraint language without loosing polynomial-time tractability.\nFrom a methodological point of view, we remark that the universal-algebraic approach\ncan also be applied to study the complexity of the QCSP [57]; as in the case of the\nCSP, the computational complexity of QCSP(B) is captured by the polymorphisms\nof B (see Chapter 5). Classiﬁcations of the QCSP typically rely on the corresponding\nclassiﬁcation for the CSP. In particular, any hardness result for the CSP immediately\ntranslates into a hardness result for the QCSP. Moreover, in the cases where the\nCSP(B) is tractable, the algorithmic insight is often the starting point for further\ninvestigations of QCSP(B).\nHowever, complexity classiﬁcations for QCSPs are typically harder to obtain than\nthe corresponding complexity classiﬁcations for CSPs.\nOne of the reasons is that\nseveral relevant universal-algebraic facts require the assumption that the algebra be\nidempotent (see Section 5.6.1). The complexity of the QCSP, however, is not pre-\nserved by homomorphic equivalence, and when we study QCSP(B) we can thus not\n\n1.7. UNCOVERED TOPICS\n33\npass to the core of B. Hence, we can in general not make the assumption that the\npolymorphism clone of B is idempotent.\nFor CSP(B), a powerful way of proving NP-hardness is to give a primitive positive\ninterpretation (see Section 5.5) of a Boolean template with a hard CSP. This is no\nlonger possible for the QCSP. There are for example 3-element templates B that\nare preserved by a semi-lattice operation (and hence no hard Boolean CSP can be\ninterpreted in B) where QCSP(B) is PSPACE-complete [57]. Finally, we would like\nto mention that PSPACE-hardness proofs for the QCSP are often much harder than\nNP-hardness proofs for the CSP [28,57].\nFrom the above is not surprising that a full classiﬁcation of the QCSP complex-\nity for three-element structures is still open. Similarly, there is no classiﬁcation of\nthe QCSP for the class of temporal constraint languages presented in Chapter 10.\nThere are concrete temporal constraint languages where the QCSP is of unknown\ncomputational complexity, for instance the QCSP for\n\u0000Q; {(x, y, z) | x = y ⇒y ≥z}\n\u0001\n.\nFor this problem, we do not know hardness for any complexity class above P, and do\nnot know containment in any complexity class below PSPACE.\n1.7.4. Non ω-categorical templates. Most methods presented in this thesis\ncrucially rely on the assumption that the constraint languages are ω-categorical. How-\never, systematic complexity classiﬁcation is also possible for large classes of constraint\nlanguages that are not ω-categorical.\n1.7.4.1. Distance CSPs. The structure (Z; succ) of the integers with the sucessor\nrelation succ = {(x, y) | x = y + 1} constitutes one of the simplest inﬁnite structures\nwith a ﬁnite signature that is not ω-categorical. Structures with a ﬁrst-order deﬁnition\nin (Z; succ) are particularly well-behaved from a model-theoretic perspective: they\nare strongly minimal [120, 158], and therefore uncountably categorical (but usually\nnot ω-categorical). In [32], the complexity of CSP(B) has been studied when B is\nﬁrst-order deﬁnable in (Z; succ). As an example, consider the directed graph with\nvertex set Z which has an edge between x and y if the diﬀerence between x and\ny is either 1 or 3.\nThis graph can be viewed as the structure (Z; R{1,3}) where\nR{1,3} = {(x, y) | x−y ∈{1, 3}}, which has a ﬁrst-order deﬁnition over (Z; succ) since\nR{1,3}(x, y) iﬀ\nsucc(x, y) ∨∃u, v (succ(x, u) ∧succ(u, v) ∧succ(v, y)) .\nAnother example is the undirected graph with vertex set Z where two integers x, y\nare linked if the distance between x and y is one or two.\nThe corresponding class of CSPs contains many natural combinatorial problems.\nFor instance, the CSP for the structure (Z; R{1,3}) is the computational problem to\nlabel the vertices of a given directed graph G such that if (x, y) is an arc in G, then\nthe diﬀerence between the label for x and the label for y is one or three. It follows\nfrom the results in [32] that this problem is in P. The CSP for the undirected graph\n\u0000Z;\n\b\n(x, y)\n\f\f |x −y| ∈{1, 2}\n\t\u0001\nmentioned above is exactly the 3-coloring problem,\nand therefore NP-complete. In general, those problems have the ﬂavor of assignment\nproblems where the task is to map the variables to integers such that various given\nconstraints on diﬀerences and distances (and Boolean combinations thereof) are sat-\nisﬁed. Therefore, CSPs whose template is deﬁnable over (Z; succ) are called distance\nCSPs.\nThe complexity classiﬁcation for distance CSPs presented in [32] is incomplete in\ntwo respects. First, it might be the case that a structure B with a ﬁrst-order deﬁnition\nin (Z; succ) has a ﬁnite core A. Those cores have the property that they have a single\n\n34\n1. INTRODUCTION\norbit (see Section 1.2.3); this follows easily from the fact that the structure (Z; succ)\nalso has only one orbit. But the dichotomy conjecture for ﬁnite domain CSPs has\nnot yet been established for the particular case of ﬁnite templates that have only\none orbit. The second point in which the complexity classiﬁcation for distance CSPs\ngiven in [32] is incomplete is that it only studies templates B that are locally ﬁnite,\nan additional ﬁniteness condition, deﬁned as follows. A graph is called locally ﬁnite\nif every vertex is contained in a ﬁnite number of edges; a relational structure is called\nlocally ﬁnite if its Gaifman graph (deﬁnition given in Section 2) is locally ﬁnite. The\nmethod that is applied in [32] is relational, and not universal-algebraic.\n1.7.4.2. Tractable Expansions of Linear Program Feasibility. Linear Program-\nming is a computational problem of outstanding theoretical and practical importance.\nAs we have seen, it is computationally equivalent to the CSP we have presented in Sec-\ntion 1.5.11. It seems to be interesting to investigate how far the constraint language of\nall linear inequalities can be expanded such that the corresponding constraint satisfac-\ntion problem remains polynomial-time solvable. It has been shown in [38] that every\nﬁrst-order expansion of linear programming is contained in a class called Horn-DLR\nfrom [126] and polynomial-time tractable, or otherwise NP-hard.\nAn important class of relations over the real numbers that generalizes the class\nof relations deﬁned by linear inequalities is the class of all semi-algebraic relations,\ni.e., relations with a ﬁrst-order deﬁnition in (R; +, ∗). By the fundamental theorem of\nTarski and Seidenberg it is known that a relation S ⊆Rn is semi-algebraic if and only\nif it has a quantiﬁer-free ﬁrst-order deﬁnition in (R; +, ∗, 0, 1, ≤). Geometrically, we\ncan view semi-algebraic sets as unions of intersections of the solution sets of strict and\nnon-strict polynomial inequalities. The classiﬁcation of the computational complexity\nof CSPs for real-valued semi-algebraic constraint languages is an ambitious research\nproject, and has important links to semideﬁnite programming: every semideﬁnite rep-\nresentable set is semi-algebraic and convex. Surprisingly, there are many fundamental\nquestions in this area that are wide open, for instance the complexity of semi-linear\nprogramming feasibility (see e.g. Section 6.4.4 in [197], or [177]), or the conjecture\nthat all convex semi-algebraic set are semideﬁnite representable [115], i.e., primitive\npositive deﬁnable over the structure that has as its relations all the solution spaces of\nsemi-deﬁnite programs. These important questions from real algebraic geometry are\nout of the scope of this thesis.\n\nCHAPTER 2\nPreliminaries in Logic\nThis chapter collects some basic terminology and facts from logic. The notation\nmostly follows Hodges’ text book [120], so many readers may safely skip this chapter;\nthey can consult it later, if needed, for particular concepts that we introduce here.\n2.1. Structures\nIn Section 1.1 we have already deﬁned relational structures; we now give the gen-\neral deﬁnition of structures that might also contain functions, since we need those\nlater. One occasion where we need functions rather than relations is in Chapter 5\nwhen we consider algebras (by which we mean structures with a purely functional\nsignature) that arise from the set of polymorphisms of a structure. Moreover, several\ntemplates are most naturally deﬁned over a structure having a functional signature,\n35\n\n36\n2. PRELIMINARIES IN LOGIC\nsee e.g. Section 4.3. Most deﬁnitions go parallel for functional and relational signa-\ntures, so we give them together in this section.\nA signature τ is a set of relation and function symbols, each equipped with an\narity. A τ-structure A is a set A (the domain of A) together with a relation RA ⊆Ak\nfor each k-ary relation symbol in τ and a function f A : Ak →A for each k-ary function\nsymbol in τ; here we allow the case k = 0 to model constant symbols. Unless stated\notherwise, A, B, C, . . . denote the domains of the structures A, B, C, . . . , respectively.\nWe sometimes write (A; RA\n1 , RA\n2 , . . . , f A\n1 , f A\n2 , . . . ) for the relational structure A with\nrelations RA\n1 , RA\n2 , . . . and functions f A\n1 , f A\n2 , . . . When there is no danger of confusion,\nwe use the same symbol for a function and its function symbol, and for a relation and\nits relation symbol. We say that a structure is inﬁnite if its domain is inﬁnite. The\nmost important special cases of structures that appear in this thesis are relational\nstructures, that is, structures with a purely relational signature, and algebras, that is,\nstructures with a purely functional signature. Algebras with domain A, B, C, . . . are\ntypically denoted by A, B, C, . . .\nExample 2.1.1. A group is an algebra G with a binary function symbol · for\ncomposition, a unary function symbol −1 for the inverse, and a constant e for the\nidentity element of G, satisfying the sentences ∀x, y, z. x·(y·z) = (x·y)·z, ∀x. x·x−1 =\ne, ∀x. e · x = x, and ∀x. x · e = x. In this signature, the subgroups of G are precisely\nthe subalgebras of G as deﬁned below. We typically omit the function symbol · and\nwrite fg for the product of elements f, g of G. Such groups will also be called abstract\ngroups to distinguish them from permutation groups; a permutation group (over a set\nX) is a set of permutations of X closed under composition and inverse, and containing\nthe identity.\nWhen working with function symbols, it is sometimes convenient to work with\nmulti-sorted structures, where we have distinguished unary predicates, called sorts,\nthat deﬁne a partition of the domain, and where function symbols might only be\ndeﬁned on some of the sorts (that is, the function symbols might not be deﬁned on\nsome of the elements). We are sloppy with the formal details since they can always\nbe worked out easily. In all our applications, the multi-sorted structures will in fact\nbe two-sorted, in which case we denote them by (A, B) — here one sort induces the\nstructure A, and the other sort induces the structure B.\n2.1.1. Expansions and reducts. Let σ, τ be signatures with σ ⊆τ. When\nA is a σ-structure and B is a τ-structure, both with the same domain, such that\nRA = RB for all relations R ∈σ and f A = f B for all functions and constants f ∈σ,\nthen A is called a reduct of B, and B is called an expansion of A. An expansion B\nof A is called ﬁrst-order if all new relations in B are ﬁrst-order deﬁnable over A. A\nstructure A is called a ﬁnite reduct of B if A is a reduct of B with a ﬁnite signature.\nWe also write (A, R) (and, similarly, (A, f)) for the expansion of A by a new relation\nR (a new function or constant f, respectively).\nIf A is a τ-structure and (ai)i∈I a sequence of elements of A indexed by I, then\n(A; (ai)i∈I) is the natural (τ ∪{ci|i ∈I})-expansion of A with |I| new constants,\nwhere ci is interpreted by ai for all i ∈I.\n2.1.2. Extensions and substructures. A τ-structure A is a substructure of a\nτ-structure B iﬀ\n• A ⊆B,\n• for each R ∈τ and for all tuples ¯a from A, ¯a ∈RA iﬀ¯a ∈RB, and\n• for each f ∈τ we have that f A(¯a) = f B(¯a).\n\n2.2. MAPPINGS\n37\nIn this case, we also say that B is an extension of A. Substructures A of B and\nextensions B of A are called proper if the domains of A and B are distinct. Note\nthat for every subset S of the domain of B there is a unique smallest substructure\nof B whose domain contains S, which is called the substructure of B generated by S,\nand which is denoted by B[S]. We say that B is ﬁnitely generated if B = B[S] for\na ﬁnite set S of elements. A subalgebra of an algebra B (induced by S) is simply a\nsubstructure of B (generated by S) – recall that we have deﬁned algebras as functions\nwith a purely functional signature.\nThe following is a concept that we only deﬁne for relational structures.\nDefinition 2.1.2. The Gaifman-graph of a relational structure B with domain\nB is the following undirected graph: the vertex set is B, and there is an edge between\ndistinct elements x, y ∈B when there is a tuple in one of the relations of B that has\nboth x and y as entries.\nA relational structure B is readily seen to be connected (in the sense of Sec-\ntion 1.1) if and only if its Gaifman graph is connected (in the usual graph-theoretic\nsense).\n2.1.3. Products. Let A and B be two structures with domain A and B, and\nthe same signature τ. Then the (direct, or categorical) product C = A × B is the\nτ-structure with domain A × B, which has for each k-ary R ∈τ the relation that\ncontains a tuple ((a1, b1), . . . , (ak, bk)) if and only if R(a1, . . . , ak) holds in A and\nR(b1, . . . , bk) holds in B. For each k-ary f ∈τ the structure C has the operation\nthat maps ((a1, b1), . . . , (ak, bk)) to (f(a1, . . . , ak), f(b1, . . . , bk)). The direct product\nA × A is also denoted by A2, and the k-fold product A × · · · × A, deﬁned analogously,\nby Ak.\nWe generalize the deﬁnition of products in the obvious way to inﬁnite products.\nFor a sequence of τ-structures (Ai)i∈I, the direct product B = Q\ni∈I Ai is the τ-\nstructure on the domain Q\ni∈I Ai such that for R ∈τ of arity k\n((a1\ni )i∈I, . . . , (ak\ni )i∈I) ∈RB iﬀ(a1\ni , . . . , ak\ni ) ∈RAi for each i ∈I ,\nand for f ∈τ of arity k, we have\nf B((a1\ni )i∈I, . . . , (ak\ni )i∈I) = (f Ai(a1\ni , . . . , ak\ni ))i∈I .\n2.2. Mappings\nThroughout the text, we use the following conventions. When f : A →B is a\nfunction, and S is a subset of A, then f(S) denotes the set {f(s) | s ∈S} ⊆B.\nWhen t = (t1, . . . , tk) is a k-tuple of elements of B, then f(t) denotes the tuple\n(f(t1), . . . , f(tk)).\nMoreover, we use the same convention for higher-ary functions\nf : Bm →B: when t1, . . . , tm are k-tuples of elements of B, then f(t1, . . . , tm) de-\nnotes the k-tuple (f(t1\n1, . . . , tm\n1 ), . . . , f(t1\nk, . . . , tm\nk )) (that is, the k-tuple is computed\ncomponentwise).\nIn the following, let A be a τ-structure with domain A and B a τ-structure with\ndomain B. A homomorphism h from A to B is a mapping from A to B that preserves\neach function and each relation for the symbols in τ; that is,\n• if (a1, . . . , ak) is in RA, then (h(a1), . . . , h(ak)) must be in RB;\n• f B(h(a1), . . . , h(ak)) = h(f A(a1, . . . , ak)).\nWhen A, B are algebras with the same signature and domain A, B, respectively, and\nf is a homomorphism from A to B, then f(A) induces a subalgebra of B, and this\nsubalgebra is called a homomorphic image of A.\n\n38\n2. PRELIMINARIES IN LOGIC\nWhen a mapping h preserves a relation R, we also say that R is invariant under\nh. If h does not preserve R, we also say that h violates R. A homomorphism from\nA to B is called a strong homomorphism if it also preserves the complements of the\nrelations from A. Injective strong homomorphisms are called embeddings. Surjective\nembeddings are called isomorphisms. A homomorphism from a substructure of A to\nB is called a partial homomorphism from A to B. An embedding from a substructure\nof A into B is called a partial isomorphism between A and B.\nHomomorphisms and isomorphisms from B to itself are called endomorphisms\nand automorphisms, respectively. Structures where the identity is the only automor-\nphism are called rigid. When f : A →B and g: B →C, then g ◦f denotes the com-\nposed function x 7→g(f(x)). Clearly, the composition of two homomorphisms (em-\nbeddings, automorphisms) is again a homomorphism (embedding, automorphism).\nLet Aut(A) and End(A) be the sets of automorphisms and endomorphisms, respec-\ntively, of A. The set Aut(A) can be viewed as a group, and End(A) as a monoid with\nrespect to composition; more on that can be found in Section 3.3 and Section 3.4.2.\n2.3. Formulas and Theories\nWe assume familiarity with basic concepts of classical ﬁrst-order logic; see for\nexample [91].\nIn particular, we will use the concepts of conjunctive normal form\n(CNF), free and bound variables, terms and subterms, clauses, (positive and negative)\nliterals, and atomic formulas.\nWe always allow the ﬁrst-order formula x = y (for equality) and ⊥(for ‘false’),\nindependently of the signature, unless stated otherwise. A formula without free vari-\nables will be called a sentence. A (ﬁrst-order) theory is a set of (ﬁrst-order) sentences.\nA structure B is a model of a sentence φ (or a theory T) if φ (all sentences in T,\nrespectively) holds true in B; in this case we write B |= φ (B |= T). The set of\nall ﬁrst-order sentences that are true in a given structure B is called the ﬁrst-order\ntheory of B, and denoted Th(B). If a sentence or a theory has a model, we call it\nsatisﬁable. We state two basic facts that will be used later.\nTheorem 2.3.1 (Compactness; see Theorem 5.1.1 in [120]). Let T be a ﬁrst-order\ntheory. If every ﬁnite subset of T is satisﬁable then T is satisﬁable.\nWhen T is a theory and φ a sentence, we say that T entails φ, in symbols T |= φ,\nif every model of T satisﬁes φ. Two theories T1, T2 are said to be equivalent if T1 |= T2\nand T2 |= T1.\nLemma 2.3.2 (see Lemma 2.3.2 in [120]). Let T be a ﬁrst-order τ-theory, and φ a\nﬁrst-order τ-formula with free variables x1, . . . , xn. Let c1, . . . , cn be distinct constants\nthat are not in τ. Then T |= φ(c1, . . . , ck) if and only if T |= ∀x1, . . . , xn.φ.\nLet B be a τ-structure. When φ is a ﬁrst-order τ-formula, and when x1, . . . , xn is\nan ordered list that enumerates all the free variables, then φ(x1, . . . , xn) deﬁnes over\nB the relation {(b1, . . . , bn) | B |= φ(b1, . . . , bn)}. When φ is a τ-formula with free\nvariables x1, . . . , xn, and h is a k-ary function then h preserves φ if h preserves the\nn-ary relation that is deﬁned by φ(x1, . . . , xn). We say that a structure A is (ﬁrst-\norder) deﬁnable in B if A and B have the same domain, and every relation from A\nhas a ﬁrst-order deﬁnition in B. Two structures A, B are (ﬁrst-order) interdeﬁnable\nif A is deﬁnable in B and vice versa.\nA ﬁrst-order τ-formula φ is said to be\n• quantiﬁer-free if it does not contain any quantiﬁers; that is, it is built from\nthe logical connectives ∧, ∨, ¬, the binary relation =, the (free) variables,\nand the symbols from τ only (also see Section 3.6.1);\n\n2.4. DIAGRAMS\n39\n• in prenex normal form if it is of the form Q1x1 . . . Qnxn.ψ where Qi ∈{∀, ∃}\nand ψ is quantiﬁer-free;\n• Horn if it is written in conjunctive normal form and every clause has at\nmost one positive literal (those formulas appear e.g. in Section 6.3);\n• positive quantiﬁer-free if φ is quantiﬁer-free, and if in addition φ does not\ncontain negation symbols ¬.\n• existential if it is of the form ∃x1, . . . , xn. ψ where ψ is quantiﬁer-free (those\nformulas appear e.g. in Section 3.6.2);\n• universal if is of the form ∀x1, . . . , xn. ψ where ψ is quantiﬁer-free;\n• ∃+ (existential positive) if it existential and if the quantiﬁer-free part of\nφ does not contain any negation symbols (those formulas appear e.g. in\nSection 3.6.4);\n• ∀−(universal negative) if it is of the form ∀x1, . . . , xn. ¬ψ where ψ is positive\nquantiﬁer-free;\n• universal conjunctive if it is universal and if the quantiﬁer-free part of φ\ndoes not contain any negation or disjunction symbols (those formulas appear\ne.g. in Section 5.6);\n• ∀∃(forall-exists) if it is of the form ∀y1, . . . , ym. ψ where ψ is existential\n(those formulas appear e.g. in Section 3.6.2);\n• ∀∃+ (positively restricted forall-exists) if it is of the form ∀¯y.φ(¯y), where φ(¯y)\nis a positive boolean combination of quantiﬁer-free formulas and existential\npositive formulas (those formulas appear throughout Section 3.6)\n• primitive positive if it is of the form ∃x1, . . . , xn. ψ1 ∧· · · ∧ψm, where\nψ1, . . . , ψm are atomic (they are of central importance in this thesis).\nWe could have equivalently deﬁned positively restricted forall-exists formulas as\nconjunctions of universally quantiﬁed disjunctions of primitive positive formulas and\nnegated atomic formulas. It is easy to see that every ∀∃+-formula can be re-written\ninto such a formula.\nNote that homomorphisms preserve all existential positive formulas. An impor-\ntant property of primitive positive sentences φ is that A × B |= φ iﬀA |= φ and\nB |= φ. Also note that partial isomorphisms preserve quantiﬁer-free formulas, embed-\ndings preserve existential formulas, and isomorphisms preserve ﬁrst-order formulas.\nEmbeddings that preserve all ﬁrst-order formulas are called elementary. When B is\nan extension of A such that the identity map from B to A is an elementary embed-\nding, we say that B is an elementary extension of A, and that A is an elementary\nsubstructure of B.\nTheorem 2.3.3 (L¨owenheim-Skolem; see Corollary 3.1.4 in [120]). Let A be a\nτ-structure, X a set of elements of A, and λ a cardinal such that |τ| + |X| ≤λ ≤|A|.\nThen A has an elementary substructure B of cardinality λ with X ⊆B.\nA ﬁrst-order theory T is said to be existential if all sentences in T are existential,\nand the set of all existential τ-sentences that is true in a τ-structure B is called the\nexistential theory of B. Analogously, we deﬁne ∀∃+, ∀∃, universal, existential positive,\nand universal negative theories.\n2.4. Diagrams\nWe need the concept of a diagram of a structure, in various variants. The idea is\nto transform a structure into a formula, similarly as in the deﬁnition of the canonical\nquery given in Section 1.2.\n\n40\n2. PRELIMINARIES IN LOGIC\nDefinition 2.4.1. Let A be a τ-structure so that in A every element is named by\na constant. Then\n• the set of all positive quantiﬁer-free sentences that hold on A is denoted by\ndiag+(A),\n• the set of all quantiﬁer-free sentences that hold on A is denoted by diag(A),\n• the set of all universal negative sentences that hold on A, is denoted by\ndiag∀−(A),\n• the elementary diagram of A is the set of all ﬁrst-order sentences true in A,\nand is denoted by diagfo(A).\nThe following is straightforward from the deﬁnitions.\nLemma 2.4.2 (Diagram lemma; Lemma 1.4.2. in [120]). Let A and B be relational\nτ-structures, and let A′ be (τ ∪ρ)-expansion of A by constant symbols ρ such that every\nelement of A′ is named by a constant. Then the following are equivalent.\n(1) There is a (τ ∪σ)-expansion B′ of B such that B′ |= diag+(A′);\n(2) There is a homomorphism from A to B.\nDiagrams are useful in the proof of the following elementary, but important\nlemma, which has been called the existential amalgamation theorem in [120]. The\nproof is analogous to the proof of Lemma 2.4.4 given in full detail below, and we\ntherefore omit it.\nProposition 2.4.3 (Theorem 5.4.1 in [120]). Let A and B be τ-structures with\ndomain A and B, respectively. Suppose that ¯a lists a subset S of A, and let h: S →B\nbe a partial homomorphism from A to B such that every existential sentence true in\n(B, h(¯a)) is also true in (A, ¯a). Then there exists an elementary extension C of A and\nan embedding g: B →C such that g(h(¯a)) = ¯a.\nWe will need several times a positive variant of Proposition 2.4.3, which is explic-\nitly given in [120], but without proof.\nLemma 2.4.4 (Theorem 5.4.7 in [120]). Let A and B be τ-structures with domain\nA and B, respectively. Suppose that ¯a lists a subset S of A, and let h: S →B be a\npartial homomorphism from A to B such that every existential positive sentence true\nin (B, h(¯a)) is also true in (A, ¯a). Then there exists an elementary extension C of A\nand a homomorphism g: B →C such that g(h(¯a)) = ¯a.\nProof. Similar to the proof of 5.4.1 in [120]. Let σ be a set of constant symbols\nand A′ be a (τ ∪σ)-expansion of A such that every element of A′ is denoted by some\nconstant symbol from σ. Let B′ be an expansion of B by constant symbols such that\n• every element of B′ is denoted by some constant, and\n• if c ∈σ is such that cA′ ∈S in A′, then cB′ = h(cA′).\nIt suﬃces to show that the theory T := diagfo(A′) ∪diag+(B′) has a model C′, since\nLemma 2.4.2 then asserts the existence of a homomorphism from B to the τ-reduct C\nof C′, which will be an elementary extension of A. Moreover, such a homomorphism\nmust map h(¯a) to ¯a.\nIf T has no model, then by the compactness theorem there is a τ-formula φ such\nthat φ(¯c) ∈diag+(B′) and A |= ¬∃¯y.φ(¯y). Since ∃¯y.φ(¯y) is existential positive, the\nassumptions imply that B |= ¬∃¯y.φ(¯a, ¯y). This contradicts that B |= φ(¯c).\n□\nWe can now prove a generalization of the condition given in Proposition 1.3.4\nfrom Section 1.3 that characterizes when two theories have the same CSP.\nProposition 2.4.5. Let T and T ′ be τ-theories. The following are equivalent.\n\n2.4. DIAGRAMS\n41\n(1) Every model of T has a homomorphism to a model of T ′, and every model\nof T ′ has a homomorphism to a model of T.\n(2) T and T ′ imply the same universal negative sentences.\nProof. To prove the implication from (1) to (2), assume (1), and let φ be a\nuniversal negative sentence implied by T ′, and let C be a model of T. By (1), there\nis a homomorphism from C to a model B of T ′. Since ¬φ is equivalent to an ex-\nistential positive sentence, it is preserved by homomorphisms, and hence we have a\ncontradiction to the assumption that T ′ |= φ.\nFor the implication from (2) to (1), assume (2), and let B be a model of T. Let\nS be the existential positive theory of B. We claim that S ∪T ′ is satisﬁable. If not,\nthen by compactness (Theorem 2.3.1) there is some ﬁnite subset {φ1, . . . , φk} of S\nsuch that T ′ ⊢(¬φ1 ∨· · · ∨¬φk). The formula ¬φ1 ∨· · · ∨¬φk is equivalent to a\nuniversal negative sentence ψ, and T ′ ⊢ψ, so by (2) we have that T ⊢ψ, and hence\nB |= ψ. We have reached a contradiction, since B |= φi for all i ≤k. So there indeed\nexists a model A of S ∪T ′. Lemma 2.4.4 applied to A and B for the empty sequence\n¯a gives a model C of T ′ ∪S and a homomorphism from B to C.\n□\nThis indeed proves Proposition 1.3.4, since theories that imply the same universal\nnegative sentences have obviously the same CSP. It is now also easy to prove Propo-\nsition 1.3.6 from Section 1.3, characterizing those theories T for which there exists a\nstructure B such that CSP(T) = CSP(B). We ﬁrst show the following.\nProposition 2.4.6. For any satisﬁable theory T, the following are equivalent.\n(1) there exists a structure B that satisﬁes an existential positive sentence φ if\nand only if T ∪{φ} is satisﬁable.\n(2) T has a model B that satisﬁes every existential positive sentence φ where\nT ∪{φ} is satisﬁable.\n(3) For all existential positive sentences φ1 and φ2, if T ∪{φ1} is satisﬁable and\nT ∪{φ2} is satisﬁable, then T ∪{φ1, φ2} is satisﬁable as well.\n(4) T has the Joint Homomorphism Property (JHP – confer Proposition 1.3.6).\nProof. We prove (1) ⇔(2), (2) ⇔(3), (3) ⇔(4). For the implication from\n(1) to (2), let T ′ be the universal negative theory of B. By assumption, T ′ and T\nimply the same universal negative sentences, and hence by Proposition 2.4.5 there is\na homomorphism from B to a model C of T. This model C has the desired property:\nif φ is existential positive such that T ∪{φ} is satisﬁable, then B satisﬁes φ and since\nhomomorphisms preserve existential positive formulas, C satisﬁes φ as well.\nThe implication from (2) to (1) and the implication from (2) to (3) are obvious.\nTo show that (3) implies (2), assume (3). Let P be the set of all existential positive\nsentences φ such that T ∪φ is satisﬁable. By the assumption that T is satisﬁable,\nand by (3), all ﬁnite subsets of T ∪P are satisﬁable, so by compactness of ﬁrst-order\nlogic (Theorem 2.3.1) we have that T ∪P has a model B.\nNow we show that (3) implies (4). Assume (3), and let τ be the signature of T.\nLet A1 and A2 be models of T. We have to show that there exists a model B of T\nthat admits homomorphisms from A1 and A2. Let A′\n1 and A′\n2 be expansions of A1\nand A2, respectively, where every element is denoted by a distinct constant symbol.\nConsider the theory T ′ := T ∪diag+(A′\n1) ∪diag+(A′\n2); we claim that T ′ is satisﬁable.\nBy compactness (Theorem 2.3.1), it suﬃces to show that every ﬁnite subset S of T ′\nis satisﬁable. Let S1 := S ∩diag+(A) and S2 := S ∩diag+(A2). By forming a ﬁnite\nconjunction, we see that S1 and S2 are logically equivalent to single sentences φ1 and\nφ2, respectively. Certainly T ∪{φ1} and T ∪{φ2} are satisﬁable since A′\n1 and A′\n2\nare expansions of models of T and therefore satisfy all sentences from T. By (3), the\n\n42\n2. PRELIMINARIES IN LOGIC\ntheory T ∪{φ1, φ2} is satisﬁable as well. Therefore the claim is true, and there exists\na model B′ of T ′. Let B be the τ-reduct of B′. Finally, Lemma 2.4.2 asserts the\nexistence of a homomorphism from A1 to B and from A2 to B, which proves (4).\nFor the implication from (4) to (3), suppose that T has the JHP, and that φ1 and\nφ2 are existential positive sentences such that T ∪{φ1} has a model A1 and T ∪{φ2} has\na model A2. By (4), there exists a model B of T such that A1 and A2 homomorphically\nmap to B.\nThen B clearly satisﬁes T ∪{φ1, φ2} since homomorphisms preserve\nexistential positive sentences.\n□\nNote that in the statement and the proof above, the phrase existential positive\ncan be used interchangeably with the phrase primitive positive. With the additional\nassumption that T has a ﬁnite relational signature, item (1) in Proposition 2.4.6\nbecomes the statement that there exists a structure B such that CSP(B) and CSP(T)\nare the same problem, so we indeed proved in particular Proposition 1.3.6.\n2.5. Chains and Direct Limits\nChains and direct limits of sequences of τ-structures are an important method to\nconstruct models of ﬁrst-order theories, and will be used for instance in Section 3.4\nand Section 3.5.\nLet (Ai)i<κ be a sequence of τ-structures for a relational signature τ.\nThen\n(Ai)i<κ is called a chain if Ai ⊆Aj for all i < j < κ. A chain is called an elementary\nchain when for all i, j < κ, the extension Aj of Ai is elementary.\nDefinition 2.5.1. The union of the chain (Ai)i<γ is a τ-structure B deﬁned as\nfollows. The domain of B is S\ni≤γ Ai, and for each relation symbol R ∈τ we put\n¯a ∈RB if ¯a ∈RAi for some (or all) Ai containing ¯a.\nTheorem 2.5.2 (Tarski-Vaught; Theorem 2.5.2 in [120]). Let (Ai)i<κ be an ele-\nmentary chain. Then S\ni<κ Ai is an elementary extension of Ai for each i < κ.\nWe say that a formula φ is preserved in chains (of models of T) if for all chains\n(Ai)0≤i<κ of τ-structures (where all the Ai and A := S\ni<κ Ai are models of T), and\nevery ¯a ∈An we have A |= φ(¯a) whenever Ai |= φ(¯a) for every i < κ.\nProposition 2.5.3 (Theorem 2.4.4 in [120]). Every ∀∃-formula is preserved in\nunions of chains.\nDirect limits can be seen as a positive variant of the notion of a union of chains;\nwe essentially replace embeddings in chains by homomorphisms. Let τ be a relational\nsignature, and let A0, A1, . . . be a sequence of τ-structures such that there are homo-\nmorphisms fij : Ai →Aj. Those homomorphisms are called coherent if fjk ◦fij = fik\nfor every i ≤j ≤k.\nDefinition 2.5.4. Let A0, A1, . . . be a sequence of τ-structures with coherent\nhomomorphisms fij : Ai →Aj. Then the direct limit limi<ω Ai is the τ-structure\nA deﬁned as follows. The domain A of A comprises the equivalence classes of the\nequivalence relation ∼deﬁned on S\ni<ω Ai by setting xi ∼xj for xi ∈Ai, xj ∈Aj iﬀ\nthere is a k such that fik(xi) = fjk(xj). Let gi : Ai →A be the function that maps\na ∈Ai to the equivalence class of a in A. For R ∈τ and a tuple ¯a over A, deﬁne\nA |= R(¯a) iﬀthere is a k and a tuple ¯b over Ak such that Ak |= R(¯b) and ¯a = gk(¯b).\nNote that the deﬁnition of limi<ω Ai also depends on the coherent family fij, but\nthis is left implicit and will be clear from the context. Also note that gi deﬁnes a\nhomomorphism from Ai to A; this function is called the limit homomorphism from\nAi to the direct limit A. Note that gi = gj ◦fij for all i < j < ω.\n\n2.6. TYPES\n43\nWe have seen that unions of chains preserve ∀∃-formulas; the analogous statement\nfor direct limits is as follows.\nWe say that a ﬁrst-order formula φ(x1, . . . , xn) is\npreserved in direct limits (of models of T) if for all sequences (Ai)0≤i<κ (where all the\nAi and A := limi<κ Ai are models of T), and every ¯a ∈An we have A |= φ(¯a) whenever\nthere is for every i < κ an n-tuples ¯ai where the j-th entry is a representative of the\nj-th entry of ¯a, and Ai |= φ(¯ai). The following is Theorem 2.4.6 in [119]; since it is\ngiven there without proof, we present it here for completeness.\nProposition 2.5.5 (Theorem 2.4.6 in [119]). Every ∀∃+-formula is preserved in\ndirect limits of models of T.\nProof. Let (Ai)i<κ be a sequence of models of T with coherent homomorphisms\nhij : Ai →Aj, for i, j < κ, such that A := limi<κ Ai is a model of T. Let gi be the\nlimit homomorphism from Ai to A. We have to show that if ¯a ∈An is such that\nfor all i < κ there is ¯ai with gi(¯ai) = ¯a and Ai |= φ(¯ai), then A |= φ(¯a). Since φ is\n∀∃+, we can assume that φ(¯x) is of the form ∀¯y. φ′(¯x, ¯y) where φ′ is a disjunction of\nnegated atomic formulas and existential positive formulas. Suppose that φ′(¯a,¯b) is\nfalse in A for some tuple ¯b of elements of A. Every disjunct ψ of φ′(¯a,¯b) is false in\nA. Then there exists an i < κ such that all entries of ¯b have representatives in Ai,\nand the negated atomic disjuncts of φ′ are already false in Ai, by deﬁnition of direct\nlimits. Let ¯bi be a tuple of elements of Ai where the j-th entry is a representative\nof the j-th entry in ¯b. Since Ai |= φ(¯ai), there must exist a disjunct ψ of φ′ such\nthat ψ(¯ai,¯bi) holds in Ai. The limit homomorphism gi maps (¯ai,¯bi) to (¯a,¯b) and is\na homomorphism from Ai to A, and therefore preserves existential positive formulas,\ncontradicting the assumption that φ′(¯a,¯b) is false in A.\n□\n2.6. Types\nA set Φ of formulas with free variables x1, . . . , xn is called satisﬁable over a\nstructure B if there are elements b1, . . . , bn of B such that for all sentences φ ∈Φ\nwe have B |= φ(b1, . . . , bn). We say that Φ is satisﬁable if there exists a structure B\nsuch that Φ is satisﬁable over B. For n ≥0, an n-type of a theory T is a set p of\nformulas with free variables x1, . . . , xn such that p ∪T is satisﬁable. An n-type p of\nT is maximal if T ∪p ∪{φ(x1, . . . , xn)} is unsatisﬁable for any formula φ /∈p. The\nset of all complete n-types of Th(A) is denoted by SA\nn . An n-type of a structure B is\nan n-type of the ﬁrst-order theory of B.\nIn a similar manner, an existential positive n-type (ep-n-type) of a theory T is a\nset of existential positive formulas p with free variables x1, . . . , xn such that p ∪T is\nsatisﬁable. A ep-n-type p of T is maximal if T ∪p ∪{φ(x1, . . . , xn)} is unsatisﬁable\nfor any existential positive formula φ /∈p. A (ep-) n-type of a structure A is a (ep-)\nn-type of the theory Th(A). When S is the universal negative theory of A, then note\nthat p∪Th(A) is satisﬁable if and only if p∪S is satisﬁable; thus we could equivalently\nhave deﬁned ep-n-type with respect to the latter theory.\nWhen p is an n-type, and I ⊆{1, . . . , n} with |I| = k, then the subtype of p\ninduced by I is the k-type obtained from p by existentially quantifying in all formulas\nin p the variables xi for i ∈{1, . . . , n} \\ I, and then renaming the variables in the\nresulting set of formulas to x1, . . . , xk in a way that preserves the order on the indices\nof the variables.\nAn n-type p of A is realized in A if there exist a1, . . . , an ∈A such that A |=\nφ(a1, . . . , an) for each φ ∈p. The set of all ﬁrst-order formulas with free variables\nx1, . . . , xn satisﬁed by an n-tuple ¯a = (a1, . . . , an) in A is a maximal type of A, and\ncalled the type of ¯a, and denoted by tpA(¯a).\n\n44\n2. PRELIMINARIES IN LOGIC\nFor an inﬁnite cardinal κ, a structure A is κ-saturated if, for all β < κ and\nexpansions A′ of A by at most β constants, every 1-type of A′ is realized in A′. We\nsay that an inﬁnite A is saturated when it is |A|-saturated. Realization of pp-types\nand pp-(κ)-saturation are deﬁned analogously.\nTheorem 2.6.1 (Corollary 8.2.2 in [120]). Let τ be a signature and λ ≥|τ|. Then\nevery τ-structure B has an λ+-saturated elementary extension of cardinality ≤|B|λ.\n\nCHAPTER 3\nModel Theory\nHodges [120] writes that “model theory is about the classiﬁcation of mathematical\nstructures, maps and sets by means of logical formulas”.\nThis text is about the\ncomputational complexity of constraint satisfaction problems for inﬁnite structures B\n— and since the constraint satisfaction problem of B (and in particular its complexity)\nis fully determined by the ﬁrst-order theory of B, it is not surprising that model theory\nhas a great deal to say about constraint satisfaction problems.\nMany important inﬁnite-domain constraint satisfaction problems can be formu-\nlated with templates that are ω-categorical. The concept of ω-categoricity is of central\nimportance in model theory, and for reasons that will become clear in Section 3.1 of\nthis chapter, also in permutation group theory. From a model-theoretic perspective,\nω-categoricity is a very strong assumption – but still many problems that have been\nstudied in the literature, in particular constraint satisfaction problems for qualita-\ntive reasoning formalisms in artiﬁcial intelligence1, can be formulated as CSPs with\nω-categorical templates. We will also see that every connected monotone monadic\nSNP sentence (the corresponding problems have been called forbidden patterns prob-\nlems and studied in [154–156]) describes a constraint satisfaction problem of an\nω-categorical structure (Section 4.5).\nIn this section we present general results about ω-categorical structures: for ex-\nample how to construct them (Sections 3.1 and 3.2, and 3.5), and how to algebraically\n1The question which reasoning formalisms in Artiﬁcial Intelligence should be called qualitative\nhas been the topic of scientiﬁc discussion [150]. My own response to this question is: it is qualitative\nif and only if it can be formulated with an ω-categorical template.\n45\n\n46\n3. MODEL THEORY\ncharacterize syntactically restricted deﬁnability of relations over ω-categorical struc-\ntures (Sections 3.3, 3.4, and 3.6). Section 3.5.2 gives an exact characterization of those\nconstraint satisfaction problems that can be formulated with ω-categorical templates.\nThere is already an excellent literature on ω-categoricty: most notably, the book\nby Cameron [70], the recent survey by Macpherson [153], and the collection [131].\nMoreover, classical text-books on model theory, such as [120,133,158], always treat\nω-categority, and use ω-categorical structures as a rich source of examples.\nThe\npresent chapter is diﬀerent from those in that it focusses on techniques and facts\nthat will be relevant for complexity classiﬁcation for the corresponding constraint\nsatisfaction problems. It contains many results that are not contained in any of the\nsources mentioned above (and which have been published in [35, 39–41, 47, 51, 52,\n114]). Some parts can be derived from proofs in Hodges’ book [120] and its original\nlonger version [119]; our citation policy is to give the reference to the shorter version,\nwhenever this is possible, since it is more widely accessible. When this is not possible,\nwe quote [119]; for what is relevant in this text, the long version subsumes the short\nversion.\n3.1. ω-categorical Structures\n“Every statement about all ω-categorical structures is either trivial, or false.”\n(Martin Ziegler, 2005)\nA satisﬁable ﬁrst-order theory T is called ω-categorical if all countable models\nof T are isomorphic. A structure is called ω-categorical if its ﬁrst-order theory is ω-\ncategorical. Since almost all ω-categorical structures that appear in this text will be\ncountably inﬁnite, we make the convention that ω-categorical structures are count-\nably inﬁnite.\nOne of the ﬁrst structures that were found to be ω-categorical (by\nCantor [71]) is the linear order of the rational numbers (Q; <), which we will use as\na running example in this section. We will see many more examples of ω-categorical\nstructures in this section, in Section 3.2, and in Chapter 4.\nOne of the standard\napproaches to verify that a structure is ω-categorical is via a so-called back-and-forth\nargument. To illustrate, we give the back-and-forth argument that shows that (Q; <)\nis ω-categorical; much more about this important concept in model theory can be\nfound in [120,175].\nProposition 3.1.1. The structure (Q; <) is ω-categorical.\nProof. Let A be a countable model of the ﬁrst-order theory T of (Q; <). It is\neasy to verify that T contains (and, as this argument will show, is uniquely given by)\n• ∃x. x = x (no empty model)\n• ∀x, y, z ((x < y ∧y < z) ⇒x < z) (transitivity)\n• ∀x, y. ¬(x < x) (irreﬂexivity)\n• ∀x, y (x < y ∨y < x ∨x = y) (totality)\n• ∀x ∃y. x < y (no largest element)\n• ∀x ∃y. y < x (no smallest element)\n• ∀x, z ∃y (x < y ∧y < z) (density).\nAn isomorphism between A and (Q; <) can be deﬁned inductively as follows.\nSuppose that we have already deﬁned f on a ﬁnite subset S of Q and that f is an\nembedding of the structure induced by S in (Q; <) into A. Since <A is dense and\nunbounded, we can extend f to any other element of Q such that the extension is\nstill an embedding from a substructure of Q into A (going forth). Symmetrically, for\nevery element v of A we can ﬁnd an element u ∈Q such that the extension of f that\n\n3.1. ω-CATEGORICAL STRUCTURES\n47\nmaps u to v is also an embedding (going back). We now alternate between going forth\nand going back; when going forth, we extend the domain of f by the next element of\nQ, according to some ﬁxed enumeration of the elements in Q. When going back, we\nextend f such that the image of A contains the next element of A, according to some\nﬁxed enumeration of the elements of A. If we continue in this way, we have deﬁned\nthe value of f on all elements of Q. Moreover, f will be surjective, and an embedding,\nand hence an isomorphism between A and (Q; <).\n□\nA second important running example of this section is the random graph (V; E),\nwhich is a (simple and undirected) graph with a countably inﬁnite set of vertices V\nthat is deﬁned uniquely up to isomorphism by the following extension property: for\nall ﬁnite disjoint subsets U, U ′ of V there exists a vertex v ∈V \\ (U ∪U ′) such that v\nis adjacent to all vertices in U and to no vertex in U ′. We will see in Section 3.2 that\nsuch a graph indeed exists (Theorem 3.2.2).\nProposition 3.1.2. The random graph (V; E) is ω-categorical.\nProof. Note that the deﬁning property of (V; E) given above is a ﬁrst-order\nproperty; a simple back-and-forth argument shows that every countably inﬁnite graph\nwith this property is isomorphic to (V; E).\n□\nThe theorem of Ryll-Nardzewski. There are many equivalent characteriza-\ntions of ω-categoricity; the most important one is in terms of the automorphism group\nof B. In the following, let G be a set of permutations of a set X. We say that G is\na permutation group if G contains the identity idX, and for g, f ∈G the functions\nx 7→g(f(x)) and x 7→g−1(x) are also in G . For n ≥1 the orbit of (t1, . . . , tn) ∈Xn\nunder G is the set {(α(t1), . . . , α(tn)) | α ∈G }.\nDefinition 3.1.3. A permutation group G over a countably inﬁnite set X is\noligomorphic if G has only ﬁnitely many orbits of n-tuples for each n ≥1.\nAn accessible proof of the following theorem can be found in Hodges’ book (The-\norem 6.3.1 in [120]).\nTheorem 3.1.4 (Engeler, Ryll-Nardzewski, Svenonius). For a countably inﬁnite\nstructure B with countable signature, the following are equivalent:\n(1) B is ω-categorical;\n(2) the automorphism group Aut(B) of B is oligomorphic;\n(3) for each n ≥1, there are ﬁnitely many inequivalent formulas with free vari-\nables x1, . . . , xn over B;\n(4) for all n ≥1, every set of n-tuples that is preserved by all automorphisms of\nB is ﬁrst-order deﬁnable in B.\nThe fourth of those conditions is missing in Theorem 6.3.1 of [120]; but the\nimplication from (3) to (4) follows from the proof given there. Conversely, suppose\nthat Aut(B) are inﬁnitely many orbits of n-tuples, for some n. Then the union of\nany subset of the set of all orbits of n-tuples is preserved by all automorphisms of B;\nbut there are only countably many ﬁrst-order formulas over a countable language, so\nnot all the invariant sets of n-tuples can be ﬁrst-order deﬁnable in B.\nThe second condition in Theorem 3.1.4 provides another possibility to verify that\na structure is ω-categorical. We again illustrate this with the structure (Q; <). It\nis not diﬃcult but a good exercise to verify that the orbit of an n-tuple (t1, . . . , tn)\nfrom Qn with respect to the automorphism group of (Q; <) is determined by the weak\nlinear order induced by (t1, . . . , tn) in (Q; <). We write weak linear order, and not\nlinear order, because some of the elements t1, . . . , tn might be equal. That is, a weak\n\n48\n3. MODEL THEORY\nlinear order is a total quasiorder. There are less than nn such orders, and hence the\nautomorphism group of (Q; <) has a ﬁnite number of orbits of n-tuples, for all n ≥1.\nLemma 3.1.5 below states a useful property that ω-categorical structures have in\ncommon with ﬁnite structures, and is an easy consequence of K¨onigs tree lemma.\nLemma 3.1.5. Let B be a ﬁnite or an inﬁnite ω-categorical structure with rela-\ntional signature τ, and let A be a countable τ-structure. If there is no homomorphism\n(embedding) from A to B, then there is a ﬁnite substructure of A that does not ho-\nmomorphically map (embed) to B.\nProof. We present the proof for homomorphisms; the proof for embeddings is\nanalogous. Suppose every ﬁnite substructure of A homomorphically maps to B. We\nshow the contraposition of the lemma, and prove the existence of a homomorphism\nfrom A to B. Let a1, a2, . . . be an enumeration of A. We construct a rooted tree\nwith ﬁnite out-degree, where each node lies on some level n ≥0.\nThe nodes on\nlevel n are equivalence classes of homomorphisms from the substructure of A induced\nby a1, . . . , an to B. Hence, there is only one vertex on level 0, which will be the\nroot of the tree. Two such homomorphisms f and g are equivalent if there is an\nautomorphism α of B such that αf = g. Two equivalence classes of homomorphisms\non level n and n + 1 are adjacent, if there are representatives of the classes such\nthat one is a restriction of the other. Theorem 3.1.4 asserts that A has only ﬁnitely\nmany orbits of k-tuples, for all k ≥0 (clearly, this also holds if B is ﬁnite). Hence,\nthe constructed tree has ﬁnite out-degree. By assumption, there is a homomorphism\nfrom the structure induced by a1, a2, . . . , an to B for all n ≥0, and hence the tree\nhas vertices on all levels. K¨onig’s lemma asserts the existence of an inﬁnite path in\nthe tree, which can be used to inductively to deﬁne a homomorphism h from A to B\nas follows.\nThe restriction of h to {a1, . . . , an} will be an element from the n-th node of the\ninﬁnite path. Initially, this is trivially true if h is restricted to the empty set. Suppose\nh is already deﬁned on a1, . . . , an, for n ≥0. By construction of the inﬁnite path,\nwe ﬁnd representatives hn and hn+1 of the n-th and the (n + 1)-st element on the\npath such that hn is a restriction of hn+1. The inductive assumption gives us an\nautomorphism α of A such that α(hn(x)) = h(x) for all x ∈{a1, . . . , an}. We set\nh(an+1) to be α(hn+1(an+1)). The restriction of h to a1, . . . , an+1 will therefore be\na member of the (n + 1)-st element of the inﬁnite path. The operation h deﬁned in\nthis way is indeed a homomorphism from A to B.\n□\nThe assumption that A is countable is necessary in Lemma 3.1.5; consider for\nexample A := (R; <), which does not admit a homomorphism to B := (Q; <) for\ncardinality reasons, even though any ﬁnite substructure of A does.\nCorollary 3.1.6. For any structure C, there is a ﬁnite structure B with the\nsame CSP as C if and only if C has a ﬁnite core.\nProof. If there exists a ﬁnite structure B with the same CSP as C, then ev-\nery ﬁnite substructure of C homomorphically maps to the core B′ of B, and by\nLemma 3.1.5 there exists a homomorphism from C to the ﬁnite core structure B′\n(which is unique up to isomorphism); since B′ also maps to C, it is a core of C. The\nconverse is trivial.\n□\nCorollary 3.1.7. Two countable ω-categorical relational τ-structures A and B\nhave the same CSP if and only if there is a homomorphism from A to B and a\nhomomorphism from B to A.\n\n3.1. ω-CATEGORICAL STRUCTURES\n49\nCorollary 3.1.7 is false for general countable relational structures. Consider for\nexample the structure (Z; {(x, y) | y = x + 1}) — the ‘inﬁnite line’, and the structure\n(N; {(x, y) | y = x + 1}) — the ‘inﬁnite ray’. Clearly, these two structures give rise to\nthe same CSP, but there is no homomorphism from the line to the ray.\nSeveral times we need variants of Lemma 3.1.5 that can be proved in the same\nway. For instance, we can replace homomorphism in the statement and the proof by\nstrong homomorphism, or injective homomorphism, or mappings satisfying universal\nidentities such as ∀x, y. f(x, y) = f(y, x). What is common for all those statements\nis that the respective property of the function can be expressed by universal ﬁrst-\norder sentences. We make this more precise and derive the following generalization\nof Lemma 3.1.5 based on the compactness theorem.\nLemma 3.1.8. Let B be a countable ω-categorical or ﬁnite structure with countable\nrelational signature τ, let A be a countably inﬁnite τ-structure, and let σ be a countable\nset of function symbols. Then for any universal (τ ∪σ)-theory T the following are\nequivalent.\n(1) The two-sorted structure (A, B) has a (τ ∪σ)-expansion that satisﬁes T such\nthat every f ∈σ denotes a function from A to B.\n(2) For every ﬁnite induced substructure C of A the two-sorted structure (C, B)\nhas a (τ ∪σ)-expansion that satisﬁes T such that every f ∈σ denotes a\nfunction from C to B.\nProof. Any substructure of a model of a universal theory is again a model of\nthe theory, so (1) implies (2). Conversely, we prove the existence of a homomorphism\nfrom A to B by a compactness argument as follows. Let P be a unary relation symbol\nnot contained in τ. Let A′ be an expansion of A by countably many constants such\nthat every element of A is named in A′ by a constant symbol; let τ ′ be the (countable)\nsignature of A′. Let D be the diagram of A′, and let S be a set of universal ﬁrst-order\nsentences that\n• forces that all function symbols from σ denote functions from the elements\nin P to the elements that are not in P, and\n• expresses that the τ-reduct of the structure induced by the elements not in\nP has the same ﬁrst-order theory as B.\nWe ﬁrst prove that D ∪S ∪T is satisﬁable. By compactness, it suﬃces to prove\nsatisﬁability of D′ ∪S ∪T for all ﬁnite subsets D′ of D. Let c1, . . . , cn be the constant\nsymbols mentioned in D′.\nLet C′ be the structure induced by {c1, . . . , cn} in A′.\nClearly, C′ |= D′.\nLet C be the τ-reduct of C′.\nBy assumption, the two-sorted\nstructure (C, B) can be expanded to a two-sorted (τ ∪σ)-structure D that satisﬁes T;\nthis structure also satisﬁes S. When we additionally denote the constants c1, . . . , cn as\nin A′, then the expansion satisﬁes also D′, and so we have found a model of D′∪S∪T.\nBy compactness, there exists an (inﬁnite) model of D∪S∪T, and by Theorem 2.3.3\nand since τ ′ ∪σ is countable there is also a countably inﬁnite model M of D ∪S ∪T.\nConsider the substructure of M generated by the constants from τ ′, and all the\nelements in PB.\nIt can be checked that the resulting structure M′ still satisﬁes\nD and S, and since universal sentences are preserved by taking substructures, M′\nalso satisﬁes T.\nNote that in M′, the elements from P induce a copy of A, and\nthe complement induces a structure that is isomorphic to B, since B is ﬁnite or ω-\ncategorical. So the functions of M′ denoted by the function symbols from σ provide\nthe required (τ ∪σ)-expansion of (A, B).\n□\n\n50\n3. MODEL THEORY\nLemma 3.1.8 is indeed a generalization of Lemma 3.1.5: to make sure that f is a\nhomomorphism, T contains for every relation symbol R ∈τ the sentence ∀¯x.(R(¯x) ⇒\nR(f(¯x)).\nFirst-Order Interpretations. Many ω-categorical structures can be derived\nfrom other ω-categorical structures via ﬁrst-order interpretations (our deﬁnition fol-\nlows [120]).\nIf δ(x1, . . . , xk) is a ﬁrst-order τ-formula with k free variables x1, . . . , xk, and A\nis a τ-structure, we write δ(Ak) for the k-ary relation that is deﬁned by δ on A.\nDefinition 3.1.9. A relational σ-structure B has a (ﬁrst-order) interpretation I\nin a τ-structure A if there exists a natural number d, called the dimension of I, and\n• a τ-formula δI(x1, . . . , xd) – called domain formula,\n• for each atomic σ-formula φ(y1, . . . , yk) a τ-formula φI(x1, . . . , xk) where the\nxi denote disjoint d-tuples of distinct variables – called the deﬁning formulas,\n• a surjective map h: δI(Ad) →B – called coordinate map,\nsuch that for all atomic σ-formulas φ and all tuples ai ∈δI(Ad)\nB |= φ(h(a1), . . . , h(ak)) ⇔A |= φI(a1, . . . , ak) .\nIf the formulas δI and φI are all primitive positive, we say that the interpretation\nI is primitive positive.\nNote that the dimension d, the set S := δ(Ak), and the\ncoordinate map h determine the deﬁning formulas up to logical equivalence; hence,\nwe sometimes denote an interpretation by I = (d, S, h). Note that the kernel of h\ncoincides with the relation deﬁned by (x = y)I, for which we also write =I, the\ndeﬁning formula for equality.\nWe say that B is interpretable in A with ﬁnitely many parameters if there are\nc1, . . . , cn ∈A such that B is interpretable in the expansion of A by the singleton\nrelations {ci} for all 1 ≤i ≤n. A ﬁrst-order deﬁnition of one structure in another\nis in model theory often the special case of an interpretation I where =I is simply\nthe equality relation; in this text, however, we say that a structure B is (ﬁrst-order)\ndeﬁnable in A if B has a 1-dimensional interpretation I in B where =I is the equality\nrelation and the domain formula δI is logically equivalent to true.\nLemma 3.1.10 (see Theorem 7.3.8 in [119]). Let A be an ω-categorical struc-\nture. Then every structure B that is ﬁrst-order interpretable in A with ﬁnitely many\nparameters is ω-categorical or ﬁnite.\nNote that in particular all reducts of an ω-categorical structure and all expansions\nof an ω-categorical structure by ﬁnitely many constants are again ω-categorical.\nExample 3.1.11. In Section 1.5 we have described Allen’s Interval Algebra for\ntemporal reasoning in Artiﬁcial Intelligence [5], and the corresponding CSP. Formally,\nit is easiest to describe the template A for this CSP by a ﬁrst-order interpretation\nI in (Q; <). The dimension of the interpretation is two, and the domain formula\nδI(x, y) is x < y. Hence, the elements of A can indeed be viewed as non-empty closed\nintervals [x, y] over Q. The template A contains for each inequivalent {<}-formula\nφ with four variables a binary relation R such that (a1, a2, a3, a4) satisﬁes φ if and\nonly if ((a1, a2), (a3, a4)) ∈R. In particular, A has relations for equality of intervals,\ncontainment of intervals, and so forth. By Lemma 3.1.10, A is ω-categorical.\n□\n3.2. Fra¨ıss´e Amalgamation\nA versatile tool to construct ω-categorical structures is Fra¨ıss´e-amalgamation. We\npresent it here for the special case of relational structures; this is all that is needed in\n\n3.2. FRA¨ISS´E AMALGAMATION\n51\nthe examples we are going to present. For a stronger version of Fra¨ıss´e-amalgamation\nfor classes of structures that might involve function symbols, see [120].\nIn the following, let τ be a countable relational signature. The age of a τ-structure\nA is the class of all ﬁnite τ-structures that embed into A. Let B1, B2 be τ-structures\nsuch that A is an induced substructure of both B1 and B2 and all common elements\nof B1 and B2 are elements of A; note that in this case A = B1 ∩B2. Then we call\nB1 ∪B2 the free amalgam of B1, B2 over A. More generally, a τ-structure C is an\namalgam of B1 and B2 over A if for i = 1, 2 there are embeddings fi of Bi to C such\nthat f1(a) = f2(a) for all a ∈A. A strong amalgam of B1, B2 over A is an amalgam\nof B1, B2 over A where f1(B1) ∩f2(B2) = f1(A)(= f2(A)).\nDefinition 3.2.1. An isomorphism-closed class C of τ-structures has the amal-\ngamation property if for all A, B1, B2 ∈C with A = B1 ∩B2 there is a C ∈C that\nis an amalgam of B1 and B2 over A. A class of ﬁnite τ-structures that contains at\nmost countably many non-isomorphic structures, has the amalgamation property, and\nis closed under taking induced substructures and isomorphisms is called an amalga-\nmation class.\nAnalogously, an isomorphism-closed class C of τ-structures has the free amalga-\nmation property if for all A, B1, B2 ∈C with A = B1∩B2 the free amalgam of B1, B2\nover A is in C. The strong amalgamation property is deﬁned analogously. Note that\nsince we only look at relational structures here (and since we allow structures to have\nan empty domain), the amalgamation property of C implies the joint embedding prop-\nerty (JEP) for C, which says that for any two structures B1, B2 ∈C there exists a\nstructure C ∈C that embeds both B1 and B2.\nA structure A is homogeneous (sometimes also called ultra-homogeneous [120]) if\nevery isomorphism between ﬁnitely generated substructures of A can be extended to\nan automorphism of A.\nTheorem 3.2.2 (Fra¨ıss´e [97,98]; see [120]). Let τ be a countable relational signa-\nture and let C be an amalgamation class of τ-structures. Then there is a homogeneous\nand at most countable τ-structure C whose age equals C. The structure C is unique\nup to isomorphism, and called the Fra¨ıss´e-limit of C.\nWhen C is a strong amalgamation class, then the Fra¨ıss´e-limit of C has a re-\nmarkable property. Let Γ be a structure, and A a ﬁnite set of elements of Γ. Then\naclΓ(A) denotes the model-theoretic algebraic closure of A in Γ, i.e., the elements of\nΓ that lie in ﬁnite sets that are ﬁrst-order deﬁnable over Γ with parameters from A.\nIn ω-categorical structures, this is precisely the set of elements of Γ that lie in ﬁnite\norbits in Aut(Γ)(A). We say that a structure Γ has no algebraicity if aclΓ(A) = A for\nall ﬁnite sets of parameters A.\nTheorem 3.2.3 (See (2.15) in [70]). A homogeneous ω-categorical structure Γ\nhas no algebraicity if and only if the age of Γ has strong amalgamation.\nExample 3.2.4. Let C be the class of all linear orders. Then C is clearly closed\nunder isomorphisms and induced substructures, and has countably many isomorphism\ntypes. To show that it also has the amalgamation property, let B1, B2 ∈C, and let\nA be an induced substructure of both B1 and B2. Let C be the free amalgam of B1\nand B2 over A. Then C is an acyclic ﬁnite graph; therefore, any depth-ﬁrst traversal\nof C leads to a linear ordering of the elements that is an amalgam (but not a free\namalgam) in C of B1 and B2 over A. It follows that C is an amalgamation class. By\nhomogeneity, the Fra¨ıss´e-limit of C is unbounded and dense, and hence isomorphic to\n(Q; <) by Proposition 3.1.1.\n□\n\n52\n3. MODEL THEORY\nExample 3.2.5. Let C be the class of all ﬁnite partially ordered sets. Amalgama-\ntion can be shown by computing the transitive closure: when C is the free amalgam\nof B1 and B2 over A, then the transitive closure of C gives an amalgam in C. The\nFra¨ıss´e-limit of C is called the homogeneous universal partial order.\n□\nExample 3.2.6. Let C be the class of all ﬁnite graphs. It is even easier than in\nthe previous examples to verify that C is an amalgamation class, since here the free\namalgam itself shows the amalgamation property. We can use homogeneity to verify\nthat the Fra¨ıss´e-limit of C satisﬁes the deﬁning property of the random graph (V; E)\n(the existence of the random graph was left open in Section 3.1).\n□\nExample 3.2.7. Henson [116] used Fra¨ıss´e limits to construct 2ω many ω-categorical\ndirected graphs. A tournament is a directed graph without self-loops such that for\nall pairs x, y of distinct vertices exactly one of the pairs (x, y), (y, x) is an arc in the\ngraph. Note that for all classes N of ﬁnite tournaments, Forb(N) is an amalgamation\nclass, because if A1 and A2 are directed graphs in Forb(N) such that A = A1 ∩A2 is\nan induced substructure of both A1 and A2, then the free amalgam A1 ∪A2 is also in\nForb(N).\nHenson in his proof speciﬁed an inﬁnite set T of tournaments T1, T2, . . . with\nthe property that Ti does not embed into Tj if i ̸= j; the set T will be described in\nSection 11.3. Note that this property implies that for two distinct subsets N1 and\nN2 of T the two sets Forb(N1) and Forb(N2) are distinct as well. Since there are 2ω\nmany subsets of the inﬁnite set T , there are also that many distinct homogeneous\n(and therefore ω-categorical) directed graphs; they are often referred to as Henson\ndigraphs.\n□\nThe structures from Example 3.2.7 can be used to prove various negative results\nabout homogeneous structures with ﬁnite signature, for instance in Section 8.4 and in\nSection 11.3. A better behaved class of structures are homogeneous structures whose\nage is ﬁnitely bounded (this is the same terminology as in [153]).\nDefinition 3.2.8. We say that a class C of ﬁnite relational τ-structures (or a\nstructure with age C) is ﬁnitely bounded if τ is ﬁnite and there exists a ﬁnite set of\nﬁnite τ-structures N such that C = Forb(N).\nProposition 3.2.9. When B is ﬁnitely bounded, then CSP(B) is in NP.\nProof. The problem CSP(B) is in monotone SNP (Section 1.4).\n□\nFra¨ıss´e’s theorem can be used to construct ω-categorical structures, because ho-\nmogeneous structures with ﬁnite relational signature are ω-categorical. More gener-\nally, we have the following.\nLemma 3.2.10. Let C be a countably inﬁnite homogeneous structure such that\nfor each k only a ﬁnite number of distinct k-ary relations can be deﬁned by atomic\nformulas. Then C is ω-categorical.\nProof. By homogeneity of C, the atomic formulas that hold on the elements\nof a tuple t in C determine the orbit of t in Aut(C). Since there are only ﬁnitely\nmany inequivalent such atomic formulas, there are ﬁnitely many orbits of k-tuples in\nAut(C). The claim follows by Theorem 3.1.4.\n□\nIt is sometimes convenient to deﬁne an ω-categorical τ-structure B by specify-\ning an amalgamation class C with a signature that is larger than τ such that B is\na reduct of the Fra¨ıss´e-limit of C.\nIf the Fra¨ıss´e-limit of C satisﬁes the condition\nof Lemma 3.2.10, it will be ω-categorical, and therefore also all its reducts are ω-\ncategorical (Lemma 3.1.10). This method is for instance used in Section 4.1.\n\n3.3. OLIGOMORPHIC PERMUTATION GROUPS\n53\nThis technique has also been used in [122] to give another proof of a theorem\ndue to Cherlin, Shelah, and Shi (Theorem 3.2.11). The result appears in [75] for\nthe special case where τ has a single binary relation denoting the edge relationship of\nundirected graphs. The statement for general relational signatures τ also follows from\na result of [79]. The theorem of Cherlin, Shelah, and Shi will be useful in Section 4.5.\nLet N be a ﬁnite set of ﬁnite structures with a ﬁnite relational signature τ. Recall\nthat a τ-structure B is called N-free if there is no homomorphism from any structure\nin N to B. A structure A in a class of structures C is called universal for C if it\ncontains all structures in C as an induced substructure. Recall that a structure is\nconnected if it cannot be given as the disjoint union of non-empty structures.\nTheorem 3.2.11 (of [75]; also see [122]). Let N be a ﬁnite set of ﬁnite connected\nτ-structures. Then there is an ω-categorical N-free τ-structure B that is universal\nfor the class of all countable N-free structures. The structure B can be expanded by\nﬁnitely many primitive positive deﬁnable relations whose complement is existential\npositive deﬁnable so that the expanded structure is homogeneous.\nWe want to remark that the structure B from Theorem 3.2.11 is uniquely (up to\nisomorphism) given by the fact that it is N-free, universal for the class of all ﬁnite N-\nfree graphs, and model-complete (Theorem 3.6.8); model-completeness will be treated\nin Section 3.6.2.\n3.3. Oligomorphic Permutation Groups\nWe have seen in Section 3.1 that a structure is ω-categorical if and only if its\nautomorphism group is oligomorphic, i.e., has for each n ≥1 only ﬁnitely many orbits\nof n-tuples. This section describes this connection between logic and permutation\ngroups in more detail.\n3.3.1. Closure. Automorphism groups of relational structures B have the prop-\nerty that they are closed, in the following sense. We write S(B) for the set of all\npermutations of the set B.\nDefinition 3.3.1. A set of permutations P of a set B is called closed (in S(B))\nif P contains all α ∈S(B) with the property that for every ﬁnite subset A of B there\nexists β ∈P such that αx = βx for all x ∈A.\nProposition 3.3.2. Let P be a set of permutations of some base set B. Then\nthe following are equivalent.\n(1) P is the automorphism group of a relational structure;\n(2) P is a closed permutation group;\n(3) P is the automorphism group of a homogeneous relational structure.\nIn the proof of this proposition, the following concept is useful.\nWhen F is\na subset of B →B, then Inv(F) denotes the set of all relations over B that are\npreserved by all functions from F. A relational structure over the base set B whose\nrelations are exactly the relations from Inv(F) is called a canonical structure2 for F.\nProof of Proposition 3.3.2. For the implication from (1) to (2), let P be\nthe automorphism group of a relational structure B with domain B, and let α ∈P.\nThen α must preserve all relations from B, because if α violates a relation from B,\n2Here, we slightly deviate from the deﬁnition given in [70], which only includes a k-ary relation\nfor each orbit of k-tuples, for all k. The diﬀerence does not matter here, but becomes important in\nlater sections.\n\n54\n3. MODEL THEORY\nthen this can be seen from the restriction of α to a ﬁnite subset of the domain. Hence,\nα ∈P.\nFor the implication from (2) to (3), ﬁrst note that canonical structures B for\nP are homogeneous: when i is an isomorphism between ﬁnite substructures of B,\nsay i has domain {a1, . . . , an}, consider the relation {(αa1, . . . , αan) | α ∈P}. This\nrelation is preserved by all operations in P and hence belongs to the relations of\nB. Thus, i preserves this relation, and (i(a1), . . . , i(an)) = (αa1, . . . , αan) for some\nα ∈P. This shows that there is an automorphism of B that extends i. In fact, since\nP is closed, this also shows that every automorphism of B is from P.\nThe implication from (3) to (1) is trivial.\n□\n3.3.2. The Inv-Aut Galois Connection. When B is a relational structure,\nwe denote by ⟨B⟩fo the set of all relations that are ﬁrst-order deﬁnable in B. We will\nsee in this section that the set\n{⟨B⟩fo | B ﬁrst-order deﬁnable in C} ,\npartially ordered by inclusion, is closely connected to the set of all closed permutation\ngroups that contain the automorphisms of C, again partially ordered by inclusion; the\nconnection is one-to-one when C is ω-categorical.\nRecall that the automorphism group of a relational structure B, i.e., the set of all\nautomorphisms of B, is denoted by Aut(B). In the following it will be convenient to\ndeﬁne the operator Aut also on sets R of relations over the same domain B, in which\ncase Aut(R) denotes the set of all permutations α of B such that α and its inverse\nα−1 preserve all relations form R.\nDefinition 3.3.3. An (anti-tone) Galois connection is a pair of functions F : U →\nV and G: V →U between two posets U and V , such that v ≤F(u) if and only if\nu ≤G(v) for all u ∈U, v ∈V .\nIt follows immediately from F(u) ≤F(u) and Deﬁnition 3.3.3 that u ≤G(F(u))\nfor all u ∈U, and similarly that F(G(v)) ≥v for all v ∈V . Moreover, F(u) =\nF(G(F(u))) and G(v) = G(F(G(v))) for all u ∈U, v ∈V .\nProposition 3.3.4. The operators Inv and Aut form a Galois connection between\nsets of relations over the base set B and permutation groups of the set B, both partially\nordered by inclusion.\nProof. Let R be a set of relations over the set B, and let G be a permutation\ngroup on the set B. First suppose that G ⊆Aut(R), and let R ∈R and g ∈G . Then\ng ∈Aut(R) and hence g preserves R. Thus, R ⊆Inv(G ).\nConversely, suppose that R ⊆Inv(G ), and again let g ∈G and R ∈R. Then\nR ∈Inv(G ), and hence g preserves R. Since g−1 ∈G , and g−1 also preserves R, we\nhave that g ∈Aut(R). Thus, G ⊆Aut(R).\n□\nWe now present descriptions of the closure operators G 7→Aut(Inv(G )) and\nR 7→Inv(Aut(R)).\nDefinition 3.3.5. Let G is a permutation group over a set B.\nThen G , the\nclosure of G in S(B), is the smallest subset of S(B) that is closed in S(B) and\ncontains G .\nThe following is a special case of Corollary 1.9 in [190] (which will be presented\nin full generality in Proposition 5.2.1 of Chapter 5).\nProposition 3.3.6. Let G be a permutation group. Then Aut(Inv(G )) = G .\n\n3.3. OLIGOMORPHIC PERMUTATION GROUPS\n55\nProof. To show that Aut(Inv(G )) ⊇¯\nG , let α ∈G be arbitrary, and let R be\nfrom Inv(G ). We have to show that α and α−1 preserve R. Let t ∈R; since α ∈G ,\nwe have that αt = βt for some β ∈G . Since β preserves R, we have that αt ∈R.\nThe argument for α−1 is analogous.\nTo show that Aut(Inv(G )) ⊆¯\nG , let α be from Aut(Inv(G )). It suﬃces to show\nthat for every ﬁnite subset {a1, . . . , an} of B there is a β ∈G such that αai = βai\nfor all i ∈{1, . . . , n}. Consider the relation R := {(βa1, . . . , βan) | β ∈G }. Note\nthat R is preserved by all permutations in G . Therefore, α preserves R. Since G\ncontains the identity, R contains (a1, . . . , an), and hence (α(a1), . . . , α(an)) ∈R.\nThus, (α(a1), . . . , α(an)) = (β(a1), . . . , β(an)) for some β ∈G as required.\n□\nWe now turn to characterisations of the hull operator B 7→Inv(Aut(B)). First\nobserve the following, which is straightforward to prove.\nProposition 3.3.7. Let B be any structure. Then Inv(Aut(B)) contains ⟨B⟩fo,\nthe set of all relations that are ﬁrst-order deﬁnable in B.\nAn exact characterisation of B 7→Inv(Aut(B)) can be given when B is ω-\ncategorical. The analogous statement of Proposition 3.3.8 below has been observed\nfor ﬁnite structures B by Krasner [139]. The fact that it extends to ω-categorical\nstructures is a direct consequence of the Theorem of Ryll-Nardzewski (Theorem 3.1.4).\nProposition 3.3.8. Let B be a countable ω-categorical structure with base set\nB, and let R ⊆Bk be a relation. Then R is ﬁrst-order deﬁnable in B if and only if\nR is preserved by the automorphisms of B, in symbols,\nInv(Aut(B)) = ⟨B⟩fo .\nAs we have seen in the proof of Proposition 3.3.2, it follows in particular that\nthe expansion of every ω-categorical structure by all ﬁrst-order deﬁnable relations is\nhomogeneous. Recall that Theorem 3.1.4 even states that for countable structures\nthe conclusion in Proposition 3.3.8 holds if and only if A is ω-categorical.\nWe have the following consequence of Proposition 3.3.6 and Proposition 3.3.8.\nAn anti-isomorphism between two posets U and V is a bijection f from the elements\nof U to the elements of V such that u ≤v in U if and only if f(u) ≥f(v) in V .\nCorollary 3.3.9. Let C be a countable ω-categorical structure.\n• The set of sets of the form ⟨B⟩fo, where B is ﬁrst-order deﬁnable in C,\nordered by inclusion, forms a lattice.\n• The set of closed permutation groups that contain Aut(C), ordered by inclu-\nsion, forms a lattice.\n• The operator Inv is an anti-isomorphism between those two lattices, and Aut\nis its inverse.\nWe explicitly state another consequence. Recall that two structures B, C on the\nsame domain are said to be ﬁrst-order interdeﬁnable iﬀall relations of B have a\nﬁrst-order deﬁnition in C and vice-versa. Then it follows from the above that two ω-\ncategorical structures are ﬁrst-order interdeﬁnable if and only if they have the same\nautomorphisms.\n3.3.3. Transitivity and Primitivity. We deﬁne concepts from permutation\ngroup theory that will be needed later. A permutation group G on a set B is\n• k-transitive if for any two k-tuples s, t of distinct elements from B there is an\nα ∈G such that αs = t, where the action of α on tuples is componentwise,\ni.e., α(s1, . . . , sk) = (αs1, . . . , αsk). We say that G is transitive if it is 1-\ntransitive.\n\n56\n3. MODEL THEORY\n• k-set transitive if for any two sets S, T ⊆B of cardinality k there is an α ∈G\nsuch that αS = {αs | s ∈S} = T.\nIt is easy to see that a 2-set transitive permutation group G on an inﬁnite set is\nalso transitive. We prove the contraposition: assume that G has more than one orbit.\nThere must be an orbit O with two distinct elements c1, c2. Let c3 be an element not\nfrom O. Then there is no automorphism that maps {c1, c2} to {c1, c3}, and hence G\nis not 2-set transitive. More generally, it holds that the number of orbits of n-subsets\nis a non-decreasing sequence [70].\nA congruence of G is an equivalence relation on B that is preserved by all per-\nmutations in G . The equivalence classes of a congruence are also called blocks. A\ncongruence is trivial if each block contains only one element (and non-trivial other-\nwise), and it is called proper if it is distinct from the equivalence relation that has\nonly one block. When B is an ω-categorical structure and G its oligomorphic au-\ntomorphism group, then the congruences of G are exactly the ﬁrst-order deﬁnable\nequivalence relations in B (and so we apply the terminology that we have for congru-\nences also to those equivalence relations). A permutation group G is called primitive if\nG is transitive and every proper congruence of G is trivial, and imprimitive otherwise.\nClearly, 2-transitive structures are always primitive.\nAn orbital is an orbit of pairs, that is, a set of the form {(αa, αb) | α ∈G } for\na, b ∈B. The trivial orbital is the orbital {(a, a) | a ∈B}. When O is an orbital, the\norbital graph is the directed graph with vertex set B and edges O. The rank r(G ) of\nG is the number of distinct orbitals of G .\nFor a sequence ¯a of elements of B, the pointwise stabilizer G¯a of G is the set of\nall elements of G that ﬁx ¯a. For a subset A of B, the setwise stabilizer GA of G is the\nset of all elements α of G that ﬁx A set-wise, that is, satisfy αA = A.\n3.3.4. Products. In this section we review the classical theory how to describe\na permutation group in terms of transitive ones.\nThe same idea can be used to\nconstruct new oligomorphic permutation groups from known ones.\n3.3.4.1. Group actions. It will be convenient to take a more general perspective\non permutation groups (and this will again be used in Chapter 7). We now consider\nabstract groups, that is, algebraic structures G over a set G of group elements, with\na function symbol for multiplication of group elements, a function for the inverse of a\ngroup element, and the constant for the identity. The link to permutation groups is\ngiven by the concept of an action of such a group on a set, which is described below.\nLet Sym(X) be the abstract group whose domain is the set of all permutations\nof X, and where composition is deﬁned as composition of permutations, the inverse\nof an element g of Sym(X) is the inverse of g as a permutation of X, and the identity\nis the identity permutation.\nDefinition 3.3.10. A (left) group action of an (abstract) group G on a set X\nis a binary function ·: G × X →X which satisﬁes that (gh) · x = g · (h · x) for all\ng, h ∈G and x ∈S, and e · x = x for every x ∈X. The action is faithful if for any\ntwo distinct g, h ∈G there exists an x ∈X such that g · x ̸= h · x.\nEquivalently, a group action of G on a set X can be viewed as a homomorphism\nfrom G into Sym(X), and a faithful group action as an isomorphism between G\nand a subgroup of Sym(X). Clearly, to every action of G on X we can associate a\npermutation group as considered before, namely the image of the action in Sym(X).\nAn action is called oligomorphic if the associated permutation group is oligomorphic.\nConversely, to every permutation group G on a set X we can associate an abstract\ngroup G whose domain is G, where composition and inverse are deﬁned in the obvious\n\n3.3. OLIGOMORPHIC PERMUTATION GROUPS\n57\nway, and which acts on X faithfully by g · x = g(x). When B is a structure, we call\nG the abstract automorphism group of B if there is an action of G on B such that\nthe image of G under this action is the automorphism group of B.\nWhen x ∈X, the orbit of x with respect to an action of G on X is the set\n{g · x | g ∈G}. Hence, an orbit of k-tuples in the corresponding permutation group\non X is an orbit of the action of G on Xk that is deﬁned componentwise, that is, g\nmaps (x1, . . . , xk) to (gx1, . . . , gxk). In this way we can also use other terminology\nintroduced for permutation groups (such a transitivity, congruences, primitivity, etc.)\nfor group actions.\nThe product of a sequence of groups (Gi)i∈I is the product of this sequence as\ndeﬁned in general in Chapter 2; note that the product is again a group. Products\nappear in several ways when studying permutation groups; the ﬁrst is when we want\nto describe the relation between a permutation group and its ‘transitive constituents’,\ndescribed in the following.\n3.3.4.2. The intransitive action of a group product. When G acts on a set X and\nS ⊂X is an orbit with respect to this action, then G naturally acts transitively on\nS by restriction; we call the corresponding group H the group induced by S, or a\ntransitive constituent.\nProposition 3.3.11 (see [70]). Let G be a group acting on a set X, and let\n(Gi)i∈I be the groups induced by the orbits of G on X. Then G is isomorphic to\na subgroup of Q\ni∈I Gi, and there are surjective homomorphisms from G to Gi, for\neach i.\nWe can use the same idea to construct new oligomorphic permutation groups\nfrom known ones.\nDefinition 3.3.12. Let G1 and G2 be groups acting on disjoint countable sets X\nand Y , respectively. Then the action of G1 ×G2 on X ∪Y deﬁned by (g1, g2)·z = g1z\nif z ∈X and g2z if y ∈Y is called the natural intransitive action of G1 × G2 on\nX ∪Y .\nNote that when G1 and G2 act oligomorphically on X and Y , respectively, then\nthe natural intransitive action of G1 × G2 is also oligomorphic: when F1(n) is the\nnumber of orbits of the componentwise action of G1 on Xn, and F2(n) is the number\nof orbits of the componentwise action of G2 on Y , then the number of orbits of the\ncomponentwise of G1 × G2 on X ∪Y is P\n0≤i≤n F1(i)F2(n −i), and hence ﬁnite for\nall n.\nWhen G1 and G2 are the automorphism groups of ω-categorical relational struc-\ntures A and B with disjoint domains A and B, respectively, then the image of the\nnatural intransitive action on A∪B (as a homomorphism from G1×G2 to Sym(A∪B))\ncan also be described as the automorphism group of a relational structure C: we can\ntake for C the disjoint union of A and B (deﬁned in Section 1.1), expanded by a unary\npredicate that contains exactly the elements of A. Since reducts of ω-categorical struc-\ntures are again ω-categorical, this shows in particular that the disjoint union of two\nω-categorical structures is again ω-categorical.\n3.3.4.3. The product action. When G1 is a group acting on a set X, and G2 a\ngroup acting on a set Y , there is another important natural action of G := G1 ×\nG2 besides the intransitive natural action of G, which is called the product action\nof G.\nIn this action, G acts on X × Y by (g1, g2) · (x, y) = (g1x, g1y).\nIf the\nactions of G1 and G2 are transitive, then the product action is clearly transitive, too.\nWe claim that when the actions of G1 and G2 are oligomorphic, then the product\naction is also oligomorphic. Let F1(n) and F2(n) then the number of orbits of the\n\n58\n3. MODEL THEORY\ncomponentwise action of G1 on Xn and Y n, respectively. Then the number of orbits\nof the componentwise action of G on X × Y is F1(n)F2(n), and in particular ﬁnite,\nwhich proves the claim.\nWhen G1 and G2 are the automorphism groups of ω-categorical relational struc-\ntures A and B, then the image of the product action of G in Sym(A×B) is the auto-\nmorphism group of the following structure, which we call the full product structure of\nA and B, and denote by A⊠B. Let σ be the signature of A, and τ be the signature of\nB; we assume that σ and τ are disjoint, otherwise we rename the relations so that the\nassumption is satisﬁed. For each k-ary R ∈σ, the structure A⊠B contains the relation\n{((a1, b1), . . . , (ak, bk)) | (a1, . . . , ak) ∈RA, b1, . . . , bk ∈B}, and for each k-ary R ∈τ,\nit contains the relation {((a1, b1), . . . , (ak, bk)) | (b1, . . . , bk) ∈RB, a1, . . . , ak ∈A}.\nFinally, we also add the relations P1 = {((a1, b1), (a2, b2)) | a1 = a2} and P2 =\n{((a1, b1), (a2, b2)) | b1 = b2} to A ⊠B.\nProposition 3.3.13. The automorphism group of C := A⊠B is Aut(A)×Aut(B)\nin its product action on A × B.\nProof. Let h be the product action of G := Aut(A)×Aut(B) on A×B, viewed\nas a homomorphism from G to Sym(A × B). Let (g1, g2) be an element of G. Then\nh((g1, g2)) is the permutation (x, y) 7→(g1x, g2y) of A × B, and this map preserves\nC: when ((a1, b1), . . . , (ak, bk)) ∈RC, for R ∈σ, then (a1, . . . , ak) ∈RA, and so\n(g1a1, . . . , g1ak) ∈RA. Therefore, ((g1a1, g2b1), . . . , (g1ak, g2bk)) ∈RC. The proof for\nthe relation symbols R ∈τ is analogous.\nWe now show that conversely, every automorphism g of C is in the image of h.\nNote that P1 and P2 are congruences of the automorphism group of C. Fix elements\na0 ∈A, b0 ∈B. Let g1 be the permutation of A that maps a ∈A to a′ such that\ng((a, b0)) = (a′, b′). Similarly, let g2 be the permutation of B that maps b ∈B to\nb′ such that g((a0, b)) = (a′, b′). Since g preserves P1, P2, the deﬁnition of g1 and g2\ndoes not depend on the choice of a0 and b0. Moreover, g1 ∈Aut(A), since g preserves\nthe relations for the symbols from σ. Similarly, g2 ∈Aut(B). Then g′ := h((g1, g2))\nequals g, since g′((a, b)) = (g1a, g2b) = g(a, b). Hence, g is a permutation of A × B\nthat lies in the image of h.\n□\nNote that Proposition 3.3.13 becomes false in general when we omit the relations\nP1 and P2 in A ⊠B. Consider for example the structure without structure B (that\nis, B has empty signature). Then the automorphism group of B ⊠B is imprimitive,\nbut without the relations P1 and P2, the structure is isomorphic to B and hence\nprimitive. Also note that when A and B are ordered structures (and this will be a\ntypical assumption in Chapter 8), we could omit P1 and P2 in the deﬁnition of the\nfull product without sacriﬁcing Proposition 3.3.13, since P1(x, y) is deﬁnable from the\norder < of A by the formula ¬(x < y) ∧¬(y < x), and similarly P2 is deﬁnable from\nthe order of B.\nFinally we remark that (A⊠B)⊠C and A⊠(B⊠C) have the same automorphism\ngroup (on the domain A × B × C). We explicitly deﬁne the d-fold full product as\nfollows.\nDefinition 3.3.14 (Full product of d structures). Let B1, . . . , Bd be structures\nwith disjoint relational signatures τ1, . . . , τd. We denote by B1⊠· · ·⊠Bd the structure\nwith domain B := B1 × · · · × Bd that contains for every i ≤d, and every m-ary\nR ∈(τi ∪{=}) an m-ary relation deﬁned by\n{((x1\n1, . . . , xd\n1), . . . , (x1\nm, . . . , xd\nm)) ∈Bm | (xi\n1, . . . , xi\nm) ∈RBi} .\nIf B := B1 = · · · = Bk, then we ﬁrst rename R ∈τi into Ri so that the factors have\npairwise disjoint signatures, and then write B[d] for B1 ⊠· · · ⊠Bd.\n\n3.4. PRESERVATION THEOREMS\n59\nWhen A and B have the same signature τ, then the automorphism group of\nthe τ-structure A × B (see Deﬁnition 3.3.4) contains the automorphism group of\nA × B, and hence A × B is ω-categorical, by Theorem 3.1.4. As a consequence, the\nclass of all ω-categorical structures forms a lattice with respect to the homomorphism\norder (where disjoint union is the join, and product the meet of two ω-categorical\nstructures).\n3.4. Preservation Theorems\nModel-theoretic preservation theorems typically link deﬁnability in (a syntacti-\ncally restricted fragment of) a given logic with certain ‘semantic’ closure properties.\nFor the syntactic restrictions on ﬁrst-order formulas that we have introduced in Chap-\nter 2 we have already made remarks about various types of mappings that automat-\nically preserve the respective formulas. Surprisingly, very often these maps can be\nused to obtain an exact characterisation of deﬁnability in the corresponding fragment\nof ﬁrst-order logic.\nIn this text, preservation theorems become relevant in two contexts. The ﬁrst\nis that they can be used to give exact characterizations of existential, existential\npositive, and quantiﬁer-free deﬁnability of relations over an ω-categorical structure,\nin a similar way as we characterized ﬁrst-order deﬁnability in Section 3.3.\nThese\ncharacterizations require that we pass from automorphism groups to endomorphism\nmonoids, and they turn out to be useful for the complexity analysis of CSPs. The\nvarious relevant connections are displayed in Figure 3.1.\nﬁrst-order deﬁnitions\nautomorphisms\nexistential deﬁnitions\nself-embeddings\npositive deﬁnitions\nsurjective endomorphisms\nexistential positive deﬁnitions\nendomorphisms\nquantiﬁer-free deﬁnitions\npartial automorphisms\nFigure 3.1. Syntactically restricted deﬁnabilities and the corre-\nsponding preservation properties.\nThe second context where we encounter model-theoretic preservation theorems is\nwhen giving syntactic descriptions of ω-categorical theories themselves (rather than\nrelations in ω-categorical structures).\nFor instance, we will see that for every ω-\ncategorical structure A there exists a homomorphically equivalent ω-categorical struc-\nture B whose ﬁrst-order theory is ∀∃+.\n3.4.1. Model-theoretic preservation theorems. When T is a ﬁrst-order the-\nory, we say that φ and ψ are equivalent modulo T if T |= (φ ⇔ψ) (see Section 1.3).\nThe following theorems are well-known and can be found in most model theory books.\nTheorem 3.4.1 ( Los-Tarski; see e.g. Corollary in 5.4.5 of [120]). Let T be a ﬁrst-\norder theory. A ﬁrst-order formula φ is equivalent to an existential formula modulo\nT if and only if φ is preserved by all embeddings between models of T.\nTheorem 3.4.2 (Lyndon; see e.g. Corollary in 8.3.5 of [120]). Let T be a ﬁrst-\norder theory. A ﬁrst-order formula φ is equivalent to a positive formula modulo T if\nand only if φ is preserved by all surjective homomorphisms between models of T.\nNote that here the assumption that ⊥is always part of ﬁrst-order logic becomes\nrelevant: the ﬁrst-order formula ∃x. x ̸= x is preserved by all homomorphisms between\nmodels of T, but without ⊥it might not be equivalent to a positive formula modulo\nT (for instance when T is the empty theory).\n\n60\n3. MODEL THEORY\nTheorem 3.4.3 (Homomorphism Preservation Theorem; see e.g. Exercise 2 in\nSection 5.5 of [120]). Let T be a ﬁrst-order theory. A ﬁrst-order formula φ is equiv-\nalent to an existential positive formula modulo T if and only if φ is preserved by all\nhomomorphisms between models of T.\nTheorem 3.4.4 (Chang- Lo´s-Suszko Theorem; Theorem 5.4.9 in [120] and re-\nmarks after the proof). Let T be a ﬁrst-order τ-theory.\n• A set of ﬁrst-order τ-formulas Φ is equivalent to a set of ∀∃-formulas Ψ\nmodulo T if and only if Φ is preserved in unions of chains of models of T.\n• A ﬁrst-order τ-formula φ is equivalent to a ∀∃-formula ψ modulo T if and\nonly if φ is preserved in unions of chains of models of T.\nOur next preservation theorem, Theorem 3.4.6, is a positive variant of the Chang-\n Lo´s-Suszko preservation theorem, which we could not ﬁnd in explicit form in the\nliterature. Its proof can be derived from the proof of the Chang- Lo´s-Suszko theorem\ngiven in [120] by modiﬁcation of a sequence of lemmata given there; since some of\nthem require some care, we will present those modiﬁcations in full detail here. Besides\nthe existential positive amalgamation theorem (Lemma 2.4.4), we need the following\nlemma.\nLemma 3.4.5. Let T be a ﬁrst-order theory, and let A be a model of the ∀∃+-\nconsequences of T.\nThen A can be extended to a model B of T such that every\nexistential positive formula that holds on a tuple ¯a in B also holds on ¯a in A.\nProof. Let A′ be an expansion of A by constants such that all elements of A′ are\ndenoted by a constant symbol. It suﬃces to prove that T ∪diag(A′) ∪diag∀−(A′) has\na model B. Suppose for contradiction that it were inconsistent; then by compactness,\nthere exists a ﬁnite subset U of diag∀−(A′) ∪diag(A′) such that T ∪U is inconsistent.\nLet φ be the conjunction over U where all new constant symbols are existentially\nquantiﬁed.\nThen T ∪{φ} is inconsistent as well.\nBut ¬φ is equivalent to a ∀∃+\nformula, and a consequence of T. Hence, A |= ¬φ, a contradiction.\n□\nThe following is a positive version of the Chang- Lo´s-Suszko theorem (Theo-\nrem 3.4.4).\nTheorem 3.4.6. Let T be a ﬁrst-order τ-theory, and Φ a set of τ-formulas. Then\nthe following are equivalent.\n(1) Φ is modulo T equivalent to a set of ∀∃+-formulas Ψ.\n(2) Φ is preserved in direct limits of sequences of models of T;\n(3) Φ is preserved in direct limits of countable sequences of models of T.\nProof. The implication from (1) to (2) is Proposition 2.5.5. The implication\nfrom (2) to (3) is trivial.\nFor the implication from (3) to (1), assume that φ is\npreserved by direct limits of sequences (Ai) as in the statement of the proposition.\nWe can assume that Φ is a set of sentences (by adding constants, Lemma 2.3.2). Let\nΨ be the set of all ∀∃+-sentences that are consequences of T ∪Φ. We ﬁrst show that\nT ∪Ψ implies φ. It suﬃces to show that every model of T ∪Ψ is elementary equivalent\nto a direct limit of a sequence (Bi)i<ω of models of T ∪Φ where there are coherent\nhomomorphisms fij : Bi →Bj with fjk ◦fij = fik for all i ≤j ≤k.\nTo construct this sequence, we deﬁne an elementary chain of models (Ai)i<ω of\nT ∪Ψ such that there are\n• homomorphisms fi : Ai →Bi, with Bi |= T ∪Φ, such that for every tuple\n¯ai of elements from Ai and every existential positive formula θ, if Bi |=\nθ(fi(¯ai)), then Ai |= θ(¯ai), and\n\n3.4. PRESERVATION THEOREMS\n61\n• homomorphisms gi : Bi →Ai+1, such that gi ◦fi is the identity on Ai.\nLet A0 be a countable model of T ∪Ψ. To construct the rest of the sequence,\nsuppose that Ai has been chosen. Since A0 is an elementary substructure of Ai, in\nparticular all the ∀∃+-consequences of T ∪Φ hold in Ai. By Lemma 3.4.5, the structure\nAi can be extended to a model Bi of T ∪Φ such that every ep-sentence that holds\nin (Bi, ¯ai) also holds in (Ai, ¯ai). By Lemma 2.4.4 there are an elementary extension\nAi+1 of Ai and a homomorphism gi : Bi →Ai+1 such that gi ◦fi is the identity on\nAi. Then C := S\ni<ω Ai equals limi<ω Bi, and by the Tarski-Vaught elementary chain\ntheorem (Theorem 2.5.2) A0 is an elementary substructure of C. So C is a model of\nT, and the direct limit of models Bi of T ∪Φ, and hence C |= φ. This shows that\nT ∪Ψ implies Φ.\n□\nBy compactness one can show that when Φ is ﬁnite, then the formula Ψ from\nitem (1) in Theorem 3.4.6 above can be chosen to be ﬁnite as well.\n3.4.2. Endomorphisms and self-embeddings. We apply the model-theoretic\npreservation theorems from the previous section to characterize existential, positive,\nand existential positive deﬁnability of relations in ω-categorical structures.\nFor ﬁnite structures and existential positive deﬁnability the corresponding preser-\nvation theorem has already been noted by Krasner [139] (for ﬁnite structures, self-\nembeddings are necessarily automorphisms, and existential deﬁnability is the same as\nﬁrst-order deﬁnability).\nTheorem 3.4.7 (from [24] and [39,51]). Let B be an ω-categorical structure with\nbase set B, and R ⊆Bk be a relation.\n(1) R has an existential positive deﬁnition in B if and only if R is preserved by\nall endomorphisms of B.\n(2) R has an existential deﬁnition in B if and only if R is preserved by all\nself-embeddings of B.\n(3) R has a positive deﬁnition in B if and only if R is preserved by all surjective\nendomorphisms of B.\nProof. We have already remarked in Chapter 2 that existential positive for-\nmulas are preserved by endomorphisms, and existential formulas are preserved by\nself-embeddings of B.\nFor the other direction, note that the endomorphisms and self-embeddings of\nB contain the automorphisms of B, and hence Theorem 3.1.4 shows that R has a\nﬁrst-order deﬁnition φ in B. Suppose for contradiction that R were preserved by\nall endomorphisms of B but has no existential positive deﬁnition in B. We use the\nhomomorphism preservation theorem (Theorem 3.4.3). Since by assumption φ is not\nequivalent to an existential positive formula in B, there are models B1 and B2 of\nthe ﬁrst-order theory of B and a homomorphism h from B1 to B2 that violates φ.\nBy the theorem of L¨owenheim-Skolem (Theorem 2.3.3) the ﬁrst-order theory of the\ntwo-sorted structure (B1, B2; h) has a countable model (B′\n1, B′\n2; h′). Since both B′\n1\nand B′\n2 must be countably inﬁnite, and because B is ω-categorical, we have that\nB′\n1 and B′\n2 are isomorphic to B, and h′ can be seen as an endomorphism of B that\nviolates φ; a contradiction.\nThe argument for existential deﬁnitions and positive deﬁnitions is similar, but\ninstead of the homomorphism preservation theorem we use the theorem of  Los-Tarski\n(Theorem 3.4.1) and Lyndon’s theorem (Theorem 3.4.2).\n□\nWe now present a Galois connection for existential positive deﬁnability and trans-\nformation monoids, similar to the Galois connection for ﬁrst-order deﬁnability and\n\n62\n3. MODEL THEORY\npermutation groups. For a structure B, we denote the set of relations with an existen-\ntial positive deﬁnition in B by ⟨B⟩ep. Similarly as in Section 3.3, we say that a set of\noperations F ⊆(B →B) is (locally) closed if it contains every operation f : B →B\nsuch that for every ﬁnite subset A of B there exists a g ∈F such that f(a) = g(a)\nfor all a ∈A. The closure of F is the smallest locally closed set of operations that\ncontains F.\nWhen F is a transformation monoid, then ⟨F⟩denotes the smallest locally closed\ntransformation monoid that contains F. The set of endomorphisms of a relational\nstructure B (or the set of operations from B →B that preserve a set of relations\nR over the domain B) is denoted by End(B) (or by End(R), respectively).\nThe\nfollowing can be shown in a similarly straightforward way as Proposition 3.3.2.\nProposition 3.4.8. For every F ⊆(B →B), the following are equivalent.\n(1) F is the transformation monoid of a relational structure;\n(2) F is a locally closed monoid.\nThe proof of the following statement is similar to the proof of Proposition 3.3.6.\nProposition 3.4.9. Let F ⊆(B →B) be a transformation monoid.\nThen\ng: B →B is in the closure of F if and only if g preserves all relations in Inv(F).\nIn symbols,\nEnd(Inv(F)) = ⟨F⟩.\nTheorem 3.4.7 now implies the following analog to Corollary 3.3.9.\nCorollary 3.4.10. Let C be an ω-categorical structure. Then the lattice of locally\nclosed transformation monoids that contain Aut(C) is anti-isomorphic to the lattice\nof sets of the form ⟨B⟩ep where B is ﬁrst-order deﬁnable in C.\nTo illustrate the use of this Galois connection, we present a simple and typical\napplication.\nLemma 3.4.11. Let B be such that Aut(B) is 2-set transitive. If B has a non-\ninjective endomorphism f, then B also has a constant endomorphism.\nProof. Let f be an endomorphism of B such that f(b) = f(b′) for two distinct\nvalues b, b′ ∈B. Let b1, b2, . . . be an enumeration of B. We construct an inﬁnite\nsequence of endomorphisms e1, e2, . . ., where ei is an endomorphism that maps all\nof the values b1, . . . , bi to b1. This suﬃces, since then by local closure the mapping\ndeﬁned by e(x) := b1 for all x is an endomorphism of B.\nFor e1, we take the identity map, which clearly is an endomorphism with the\ndesired properties.\nTo deﬁne ei for i ≥2, let α be an automorphism of B that\nmaps {b1, ei−1(bi)} to {b, b′}; such an automorphism exists because Aut(B) is 2-set\ntransitive. Then the endomorphism f(αei−1(x)) is constant on b1, . . . , bi; recall that\nb1 = ei−1(b1) = · · · = ei−1(bi−1). Since B is 2-transitive, it is in particular transitive,\nand there is an automorphism β that maps f(b) to b1. Then ei : x 7→βf(αei−1(x)) is\nan endomorphism of B with the desired properties.\n□\n3.4.3. Locally invertible self-embeddings. Let A and B be τ-structures, let\ne be an embedding of A into B, and let f be an embedding of B into A. We say that\ne and f locally invert each other if\n• for every tuple ¯a of elements of A there are β ∈Aut(B) and α ∈Aut(A)\nsuch that αf(βe(¯a)) = ¯a, and\n• for every tuple ¯b of elements of B there are α ∈Aut(A) and β ∈Aut(B)\nsuch that βe(αf(¯b)) = ¯b.\n\n3.4. PRESERVATION THEOREMS\n63\nWe say that e is locally invertible if there exists a self-embedding f such that e and\nf locally invert each other.\nWe will show that locally invertible self-embeddings preserve ﬁrst-order formulas.\nTo do so, we need the following concept. Let A and B be τ-structures. A back-and-\nforth system from A to B (our deﬁnition is taken from [120]) is a non-empty set I of\npairs (¯a,¯b) of tuples, with ¯a from A and ¯b from B, such that the following hold.\n(1) If (¯a,¯b) ∈I then ¯a and ¯b have the same length and (A, ¯a) satisﬁes the same\natomic formulas as (B,¯b).\n(2) (Going Forth.) For every pair (¯a,¯b) ∈I and every element c of A there is\nan element d of B such that the pair (¯ac,¯bd) ∈I.\n(3) (Going Back.) For every pair (¯a,¯b) ∈I and every element d of B there is\nan element c of A such that the pair (¯ac,¯bd) ∈I.\nThere is a back-and-forth system from A to B if and only if A and B are isomorphic\n(combination of Lemma 3.2.2 and Theorem 3.2.3 (b) in [120]).\nTheorem 3.4.12. A relation R has a ﬁrst-order deﬁnition in an ω-categorical\nstructure B if and only if R is preserved by all locally invertible self-embeddings of B.\nProof. We are in the remarkable situation (in comparison to the other preser-\nvation theorems discussed here) that the “if” direction of the statement is easy (it\nfollows directly from the theorem of Ryll-Nardzewski, since automorphisms are locally\ninverted by their inverse), and that we only have to show the ‘only if’ direction.\nLet e and f be self-embeddings of B that locally invert each other, and suppose\nthat ¯a is a tuple from B that satisﬁes a ﬁrst-order formula φ. We claim that e(¯a)\nsatisﬁes φ as well. It clearly suﬃces to show that the structures (B, ¯a) and (B, e(¯a))\nare isomorphic. We claim that the set\nI := {(¯u, ¯v) | there are γ, δ ∈Aut(B)\nso that δeγ(¯u) = ¯v}\nis a back-and-forth system from (B, ¯a) to (B, e(¯a)).\nThe set I is non-empty, since (¯a, e(¯a)) ∈I (we have γ = δ = id in the deﬁnition\nof I). It is obvious that I satisﬁes item (1) in the deﬁnition of back-and-forth systems\nsince all involved operations are embeddings. Now, let (¯u, ¯v) be from I. By deﬁnition\nof I, there are γ ∈Aut(B) and δ ∈Aut(B) so that δe(γ¯u) = ¯v. For going forth, let\nc be an arbitrary element of B. Let d be δe(γc). The clearly (¯uc, ¯vd) ∈I.\nFor going back, let d be an arbitrary element of B. Since e is locally inverted by\nf, there exist α, β ∈Aut(B) such that αf(βe(γ¯u)) = γ¯u. Since e(γ¯u) = δ−1¯v, this is\nthe same as saying that αf(βδ−1¯v) = γ¯u, and by multiplication with α−1 we note\nf(βδ−1¯v) = α−1γ¯u .\n(7)\nWe now set c to γ−1αf(βδ−1d), claiming that (¯uc, ¯vd) ∈I, which completes the proof.\nTo show the claim, we have to ﬁnd γ′, δ′ ∈Aut(B) such that δ′e(γ′(¯uc)) = ¯vd.\nLet ¯p be the tuple βδ−1(¯vd). By the second item in the deﬁnition of local inversion,\nthere are α′, β′ ∈Aut(B) such that β′e(α′f(¯p)) = ¯p.\n\n64\n3. MODEL THEORY\nChoose γ′ = α′α−1γ and δ′ = δβ−1β′. Then\nδ′e(γ′(¯uc)) = δβ−1β′e(α′α−1γ(¯uc))\n= δβ−1β′e(α′(α−1γ¯u, α−1γ¯c))\n= δβ−1β′e(α′(f(βδ−1¯v), f(βδ−1d)))\n(see (7))\n= δβ−1β′e(α′f(βδ−1(¯vd)))\n= δβ−1βδ−1(¯vd)\n= ¯vd ,\nand so (¯uc, ¯vd) ∈I.\n□\nTheorem 3.4.12 will be used in Section 3.6, and later also in Chapter 10, as a tool\nfor proving that all automorphisms of certain structures B are locally generated by\nthe self-embeddings of B. We note the following consequence of Theorem 3.4.12.\nCorollary 3.4.13. An endomorphism e of an ω-categorical structure is locally\ninvertible if and only if e is locally generated by the automorphisms of Γ.\nProof. If e is locally generated by the automorphisms, then e is clearly locally\ninvertible. The converse follows from Theorem 3.4.12 in combination with Proposi-\ntion 3.4.9.\n□\n3.4.4. Partial Automorphisms. Recall that a formula is called quantiﬁer-free\nif it can be constructed from atomic formulas by usage of Boolean connectives only.\nAlso quantiﬁer-free deﬁnability can be characterized by a model-theoretic preservation\ntheorem; in this case, this is very easy to prove.\nProposition 3.4.14. Let T be a ﬁrst-order theory over a relational signature. A\nﬁrst-order formula φ is equivalent to a quantiﬁer-free formula modulo T if and only\nif φ is preserved by partial isomorphisms between models of T.\nProof. It is clear that quantiﬁer-free formulas are preserved by partial isomor-\nphisms between models of T.\nFor the converse, let φ be preserved by all partial\nisomorphisms between models of T. Let Ψ be the set of all quantiﬁer-free formulas\nψ such that T |= ∀¯x(φ(¯x) ⇒ψ(¯x)). It suﬃces to prove that Ψ implies φ. Let A be a\nmodel of T and ¯a a tuple from A such that ¯a satisﬁes Ψ in A. Let B be a model of T\nand ¯b a tuple from B such that ¯b satisﬁes φ in B (if no such B exists, the statement\nof the proposition is trivial). Since ¯a and ¯b satisfy the same atomic formulas, the\nmapping that sends ¯b to ¯a is a partial isomorphism. Since φ is by assumption pre-\nserved by partial isomorphisms, ¯a satisﬁes φ in A. The set Ψ modulo T equivalent to\na single quantiﬁer-free formula by compactness of ﬁrst-order logic and this concludes\nthe proof.\n□\nThe following can be derived from the previous proposition.\nProposition 3.4.15. Let B be an ω-categorical structure. Then a relation R\nhas a quantiﬁer-free deﬁnition in B if and only if R is preserved by all partial au-\ntomorphisms of B, i.e., preserved by isomorphisms between induced substructures of\nB.\nProof. If a relation R is preserved by all partial endomorphisms of B, then it\nis in particular preserved by all endomorphisms of B. By Theorem 3.4.7, R has an\nexistential positive deﬁnition in B. We can therefore use Proposition 3.4.14 in the\nsame way as we used model-theoretic preservation theorems to prove Theorem 3.4.7\nto conclude the argument.\n□\n\n3.5. EXISTENTIAL POSITIVE COMPLETION\n65\n3.5. Existential Positive Completion\nIt might be that the same CSP can be formulated with diﬀerent templates. Con-\nsider for example the random graph (V; E), which has exactly the same CSP as the\ntemplate (N; {(x, y) | x ̸= y}). Recall that two structures B, C have the same CSP if\nand only if they have the same existential positive theory T, or equivalently, if they\nhave the same universal negative theory S. Moreover, any model of T ∪S has the\nsame CSP as B and C. The topic of this section is how to produce a model B of\nT ∪S such that B has many good properties for studying CSP(B). Good candidates\nfor such models B are existential-positively closed models, which will be introduced\nhere. Much of the material presented here is analogous to the classical facts about\nexistential completion, which we brieﬂy review in Section 3.5.1.\nExistential posi-\ntive completion is discussed in Section 3.5.2. The results in this section have been\npublished in [35].\n3.5.1. Existential Completion. Let T be a ﬁrst-order theory. A model A of\nT is existentially closed for T (we also say that A is an existentially closed model of\nT) if A |= φ(¯a) for any embedding e from A into another model B of T, any tuple ¯a\nfrom A, and any primitive formula φ with B |= φ(e(¯a)).\nTo construct existentially closed models of T, we use unions of elementary chains\n(see Section 2.1.3). A ﬁrst-order theory T is inductive if the union of every chain of\nmodels of T is also a model of T. Note that by Proposition 2.5.3, when T is a ∀∃-\ntheory, then T is inductive. The following lemma implies that if T is inductive, then it\nhas an existentially closed model. For a proof, see [120], or the proof of Lemma 3.5.3\nbelow, which is very similar.\nLemma 3.5.1 (Corollary 7.2.2 in [120]). Let T be an inductive theory and let κ\nbe an inﬁnite cardinal. Then any model A of T of cardinality at most κ embeds into\nan existentially closed model B of T of cardinality at most κ.\n3.5.2. Existential positive completion. Again, let T be a ﬁrst-order theory.\nDefinition 3.5.2. A model A of T is existential-positively closed for T (or short\nan epc model of T) if A |= φ(¯a) for any homomorphism h from A into another model\nB of T, any tuple ¯a from A, and any existential positive formula φ with B |= φ(h(¯a)).\nNote that we can equivalently replace ‘existential positive’ by ‘primitive positive’\nin the previous deﬁnition.\nTo show the existence of epc models we apply the direct limit construction from\nSection 2.1.3.\nLemma 3.5.3 (from [35]; also see [20]). Let T be a ∀∃+ τ-theory and let κ =\nmax(ω, |τ|). Then any model A of T of cardinality at most κ admits a homomorphism\nto an epc model B of T of cardinality at most κ.\nProof. Set B0 := A. Having constructed Bi of cardinality at most κ, for i < ω,\nlet {(φα, ¯aα) | α < κ} be an enumeration of all pairs (φ, ¯a) where φ is existential\npositive with free variables x1, . . . , xn, and ¯a is an n-tuple from Bi. We construct a\nsequence (Bα\ni )0≤α<κ of models of T of cardinality at most κ and a coherent sequence\n(f µ,α\ni\n)0≤µ<α<κ where f µ,α\ni\nis a homomorphism from Bµ\ni to Bα\ni , as follows.\nSet B0\ni = Bi−1. Now let α = β+1 < κ be a successor ordinal. Let ¯bβ be the image\nof ¯aβ in Bβ\ni under f 0,β\ni\n. If there is a model C of T and a homomorphism h: Bβ\ni →C\nsuch that C |= φβ(h(¯bβ)), then by the theorem of L¨owenheim-Skolem there is also a\nmodel C′ of cardinality at most κ of T and a homomorphism h′ : Bβ\ni →C′ such that\nC′ |= φβ(h′(¯bβ)). Set Bα\ni := C′ and f µ,α\ni\n:= h′ ◦f µ,β\ni\nfor all µ < α. Otherwise, if\n\n66\n3. MODEL THEORY\nthere is no such model C, we set Bα\ni := Bβ\ni and f β,α\ni\n:= id (the identity mapping)\nand f µ,α\ni\n:= f µ,β\ni\n. Finally, for limit ordinals α < κ, set Bα\ni := limµ<α Bµ\ni and let f µ,α\ni\nbe the corresponding limit homomorphism from Bµ\ni to Bα\ni .\nLet Bi be limα<κ Bα\ni and let gi : Bi−1 →Bi be the limit homomorphism mapping\neach element of Bi−1 = B0\ni to its equivalence class in Bi. In the natural way, the\ngi give raise to a coherent sequence of homomorphisms, and by Proposition 2.5.5,\nB := limi<ω Bi is a model of T; let hi : Bi →B for i < ω be the corresponding limit\nhomomorphisms.\nThe structure B is epc in T. To verify this, let g be a homomorphism from B to\na model C of T, and suppose that there is a tuple ¯b over B and an existential positive\nformula φ such that C |= φ(g(¯b)). Then there is an i < ω and an ¯a ∈Bi such that\nhi(¯a) = ¯b. Then g ◦hi is a homomorphism from Bi to C, and by construction we\nhave that Bi+1 |= φ(gi+1(¯a)). Note that hi+1 ◦gi+1 = hi. Thus, since hi+1 preserves\nexistential positive formulas, we also have that B |= φ(¯b), which is what we had to\nshow.\n□\nFor an equivalent characterization of existentially closed models in terms of max-\nimal pp-types (Proposition 3.5.5), we need the following lemma, a close relative of\nTheorem 10.3.1 in [119].\nLemma 3.5.4. Let A and B be τ-structures, where B is pp-|A|-saturated. Suppose\nthat µ < |A| and that f is a mapping from {aα | α < µ} ⊆A to B such that all pp-\n(τ ∪{cα | α < µ})-sentences true on (A, (aα)α<µ) are true on (B, (f(aα))α<µ). Then\nf can be extended to a homomorphism from A to B.\nProof. Let (a′\nα)α<|A| well-order A such that {a′\nα | α < µ} = {aα | α < µ} (there\nis the implicit and harmless assumption that (aα)α<µ contains no repetitions). Set\n(bα)α<µ := (f(aα))α<µ.\nWe will construct by transﬁnite induction on β (up to |A|) a sequence (bα)α<β\nsuch that we maintain the inductive hypothesis\n(∗) all pp-(τ ∪{cα | α < β})-sentences true on (A; (a′\nα)α<β) are true on (B; (bα)α<β).\n• (Base Case.) β = µ. Follows from the hypothesis of the lemma.\n• (Inductive Step. Limit ordinals.) β = λ. Property (∗) holds, since a sentence\ncan only mention a ﬁnite collection of constants, whose indices must all be\nless than some γ < λ.\n• (Inductive Step. Successor ordinals.) β = γ+ < |A|. Set\nΣ :=\n\b\nφ(x) | φ is a pp-(τ ∪{cα | α < γ})-formula such that\n(A; (a′\nα)α<γ) |= φ(a′\nγ)\n\t\n.\nBy (∗), for every φ ∈Σ, (B; (bα)α<γ) |= ∃x.φ(x). By compactness, since Σ\nis closed under conjunction, we have that Σ is a pp-1-type of (B; (bα)α<γ).\nThen Σ is realized by some element bγ ∈B because B is pp-|A|-saturated.\nBy construction we maintain that all pp-(τ ∪{cα | α < γ+})-sentences true\non (A; (a′\nα)α<γ+) are true on (B; (bα)α<γ+).\nThe result follows by reading f as the function that maps a′\nα to bα for all α < |A|.\n□\nProposition 3.5.5. Let T be a theory, and let A be a model of T. Then A is epc\nfor T if and only if every complete pp-n-type of A is a maximal pp-type of T.\nProof. (Forwards.) Suppose p(x1, . . . , xn) is an pp-n-type, realized in A by the\ntuple (a1, . . . , an). Let c1, . . . , cn be new constant symbols that denote a1, . . . , an in\nA. Let φ(x1, . . . , xn) be a primitive positive formula such that T ∪p(c1, . . . , cn) ∪\n\n3.6. QUANTIFIER-ELIMINATION, MODEL-COMPLETENESS, CORES\n67\n{φ(c1, . . . , cn)} has a model (C; c1, . . . , cn).\nNow, let (Csat; c1, . . . , cn) be an |A|-\nsaturated model of Th(C; c1, . . . , cn); such a model always exists by Theorem 2.6.1.\nClearly (Csat; c1, . . . , cn) is pp-|A|-saturated, and all primitive positive formulas true\non (A, c1, . . . , cn) are true on (Csat; c1, . . . , cn). By Lemma 3.5.4, there is a homomor-\nphism h from (A, c1, . . . , cn) to (Csat). Now, since φ(c1, . . . , cn) holds on Csat and A\nis epc for T, we ﬁnd that (A, c1, . . . , cn) |= φ(c1, . . . , cn), and conclude that p is a\nmaximal pp-type of T.\n(Backwards.) Take B |= T, h: A →B a homomorphism, ¯a a tuple of elements\nof A, and φ(x1, . . . , xn) a primitive positive formula such that B |= φ(h(¯a)). Let p be\nthe pp-type of ¯a in A. Since B is a model of T and h preserves all primitive positive\nformulas, it follows that T ∪p ∪{φ} is satisﬁable. By maximality of p, we have that\nφ ∈p, and therefore A |= φ(¯a).\n□\nWe close this section with an observation that will be needed later on.\nLemma 3.5.6. The class of all epc models of a theory T is closed under direct\nlimits.\nProof. Suppose that A = limλ<κ Aλ for a sequence (Aλ)λ<κ of epc models of\nT, ¯a is a tuple from A, φ an existential positive formula, and h is a homomorphism\nfrom A into another model of T such that B |= φ(h(¯a)). Then there exists a λ < κ\nsuch that ¯a = gλ(¯a′) for ¯a′ from Aλ (where gλ is as in the deﬁnition of direct limits).\nNote that h ◦gλ is a homomorphism from Aλ to B, and since Aλ is an epc model\nof T, Aλ |= φ(¯a′). Since gλ preserves existential positive formulas, we thus also have\nthat A |= φ(¯a).\n□\n3.6. Quantiﬁer-elimination, Model-completeness, Cores\nThis section is concerned with structures B where various forms of syntactic\nrestrictions of ﬁrst-order logic have equal expressive power. In particular, we consider\nthe situation that in B every ﬁrst-order formula is equivalent to\n• a quantiﬁer-free formula (Section 3.6.1),\n• an existential formula (Section 3.6.2),\n• an existential positive formula (Sections 3.6.3 and 3.6.4).\nFor ω-categorical structures, such a deﬁnability collaps translates nicely into a prop-\nerty of the operations that preserve B, using the preservation theorems from Sec-\ntion 3.4. A survey picture is given in Figure 3.2. All these collapse results will be\nuseful when studying the complexity of CSPs. For example, these results clarify when\nthe so-called constraint entailment problem for A can be reduced to the constraint\nsatisfaction problem for A (see Section 3.6.4).\nWe also develop a theory that can be viewed as a positive variant of the classical\ntheory of model-completeness and model companions (Section 3.6.4 and 3.6.5). This\nallows us to clarify the question which CSPs can be formulated with an ω-categorical\ntemplate (Section 3.6.6).\n3.6.1. Quantiﬁer-elimination. We say that a τ-structure A admits quantiﬁer\nelimination if for every ﬁrst-order τ-formula there exists an equivalent quantiﬁer-free\nτ-formula.\nIn this context, our assumption that we allow ⊥as a ﬁrst-order formula (de-\nnoting the empty 0-ary relation) becomes relevant; Hodges [119] does not make this\nassumption, and therefore has to distinguish between quantiﬁer-elimination and what\nhe calls quantiﬁer-elimination for non-sentences. We will later often make use of the\nfollowing fact.\n\n68\n3. MODEL THEORY\npartial \nisomorphisms\nendomorphisms\nsurjective \nendomorphisms\nself-\nembeddings\nautomorphisms\nquantiﬁer-free\nexistential \npositive\nexistential \npositive\nfull ﬁrst-order \ncore\ncore\nquantiﬁer elimination\nhomogeneity\nmodel-\ncompleteness\nmodel-\ncompleteness\nFigure 3.2. Various forms of deﬁnability (left side), ordered by rel-\native strength, and the corresponding class of operations (right side).\nThe labels on the arrows indicate the condition on the structure\nwhen the corresponding two forms of deﬁnability coincide (left side),\nand correspondingly when one set of operations locally generates the\nother (right side).\nLemma 3.6.1 (Statement 2.22 in [70]). An ω-categorical structure B admits quan-\ntiﬁer elimination if and only if it is homogeneous.\nProof. By Theorem 3.1.4, the orbit of a k-tuple of elements of B is ﬁrst-\norder deﬁnable.\nSuppose that B has quantiﬁer-elimination.\nThen two k-tuples\n¯a = (a1, . . . , ak) and ¯b = (b1, . . . , bk) are in the same orbit if and only if the mapping\nthat sends ai to bi, for 1 ≤i ≤n, is an isomorphism between the structures induced\nby {a1, . . . , ak} and by {b1, . . . , bk}. This proves homogeneity.\nNow suppose that B is homogeneous, and let φ(x1, . . . , xk) be a ﬁrst-order for-\nmula. By the theorem of Ryll-Nardzewski (Theorem 3.1.4), there are ﬁnitely many\norbits O1, . . . , Om of orbits of k-typles that satisfy φ.\nClearly, it suﬃces to show\nthat each of those orbits can be deﬁned by a quantiﬁer-free formula. Let a ∈Bk\nbe such that B |= φ(a). We claim that the set of quantiﬁer-free formulas that hold\non (a1, . . . , ak) deﬁnes the orbit of a over B.\nTo see this, let (b1, . . . , bk) be an-\nother k-tuple that satisﬁes the same quantiﬁer-free formulas as (a1, . . . , ak). Then\nthe mapping that sends ai to bi is a partial isomorphism, and by homogeneity can\nbe extended to an automorphism of B.\nSince automorphisms preserve ﬁrst-order\nformulas, (b1, . . . , bk) also satisﬁes φ, which proves the claim.\n□\n3.6.2. Model-Completeness. The purpose of this section is to recall classical\nresults about model-completeness; they inspired the new results of the next section\nabout model-complete cores. A theory T is model-complete if every embedding be-\ntween models of T is elementary, i.e., preserves all ﬁrst-order formulas. There are\nseveral equivalent characterizations of model-completeness, stated in Theorem 3.6.2\nbelow.\nTheorem 3.6.2 (Theorem 7.3.1 in [120]). Let T be a theory. Then the following\nare equivalent.\n(1) T is model-complete.\n(2) Every model of T is an existentially closed model of T.\n\n3.6. QUANTIFIER-ELIMINATION, MODEL-COMPLETENESS, CORES\n69\n(3) Every ﬁrst-order formula is equivalent to an existential formula modulo T.\nFor the proof, we refer to [120]; but note that the theorem has a positive variant\n(Theorem 3.6.11 below) with an analogous proof that will be presented in full length.\nExample 3.6.3. The structure (Q+\n0 ; <), where Q+\n0 denotes the non-negative ra-\ntional numbers, is not model-complete, because the self-embedding x 7→x + 1 of\n(Q+\n0 ; <) does not preserve the formula φ(x) = ∀y (y > x ⇒∃z (x < z ∧z < y)) (which\nis satisﬁed only by 0).\nWhen A is not model-complete, we can sometimes ﬁnd a model-complete structure\nB that satisﬁes the same universal ﬁrst-order sentences as A.\nDefinition 3.6.4. A theory U is a model companion of a theory T if\n• U is model-complete;\n• Every model of U embeds into a model of T; and\n• every model of T embeds into a model of U.\nNote that the last two conditions in this deﬁnition are equivalent to saying that U\nand T imply exactly the same existential sentences (equivalently, the same universal\nsentences); the proof is analogous to the one of Proposition 2.4.5.\nIf T has a model-companion U, then U is unique up to equivalence of theories.\nTheorem 3.6.5 (Theorem 7.3.6. in [120]). For any two model-companions U1, U2\nof a theory T we have that U1 ⊢U2 and U2 ⊢U1.\nThe following theorem by Simmons [188] will not be used in this thesis; however,\nit has an existential positive version, Theorem 3.6.23 below, which has important\nconsequences for the study of the CSP. Recall the joint embedding property, which\nhas been deﬁned for classes of structures in Section 3.2; a theory T has the joint\nembedding property (JEP) if for any two models B1, B2 of T there exists a model C\nof T that embeds both B1 and B2.\nTheorem 3.6.6 (from [188]). Let T be a theory with the JEP. Then the following\nare equivalent.\n• T has an ω-categorical model companion.\n• For every n, T has ﬁnitely many maximal existential n-types.\nIn particular, every ω-categorical theory has an ω-categorical model companion [181].\nThe consequence stated for ω-categorical theories T at the end of Theorem 3.6.6\nis an earlier result by Saracino [181], and clearly follows from the ﬁrst part.\nWe say that a structure A is model-complete if and only if the ﬁrst-order theory\nTh(A) of A is model-complete. As we see below, for ω-categorical structures A model-\ncompleteness of A can be translated into a property of the self-embedding monoid of\nA, and into a property concerning the axiomatization of Th(A).\nIn the following\ntheorem, the equivalence of (1) and (4) can be found in [51]. The implication from\n(5) to (1) has been observed in [41].\nTheorem 3.6.7. Let B be ω-categorical. Then the following are equivalent.\n(1) The structure B is model-complete.\n(2) Th(B) is equivalent to a ∀∃-theory.\n(3) B has a homogeneous expansion by relations R1, R2, . . . such that both the\nRi and their complements have existential deﬁnitions in B.\n(4) Every self-embedding of B is locally generated by the automorphisms of B.\n(5) Every self-embedding of B is locally invertible (see Section 3.4.3).\n\n70\n3. MODEL THEORY\nProof. The implication from (1) to (2) holds for all structures B (we do not\nneed ω-categoricity; see e.g. Theorem 7.3.3 in [120]). The reverse direction is a direct\nconsequence of a result known as Lindstr¨om’s test (Theorem 7.3.4. in [120]).\nWe now prove (1) ⇒(3) ⇒(4) ⇒(5) ⇒(1).\nSuppose that (1) holds. By Theorem 3.6.2, every ﬁrst-order deﬁnable relation has\nan existential deﬁnition in B. Hence, when we expand B by all existentially deﬁnable\nrelations, every ﬁrst-order formula has a quantiﬁer-free deﬁnition. So Lemma 3.6.1\nshows that the expansion is homogeneous.\nNow suppose that (3) holds. We claim that every self-embedding e of B is in the\nclosure of the automorphisms of B. The restriction e′ of e to a ﬁnite subset S of the\ndomain of B is an isomorphism between ﬁnite induced substructures of B, and also\nan isomorphism between the expansion of B by all existentially deﬁnable relations.\nHomogeneity of this expansion implies that e′ can be extended to an automorphism\nof B, which proves the claim.\nThe implication from (4) to (5) is trivial. Finally, the implication from (5) to (1)\nit is a direct consequence of Theorem 3.4.12.\n□\nNote that all ﬁnite structures are model-complete: self-embeddings of B are\nautomorphisms, and hence they are elementary.\nEvery relation that is ﬁrst-order\ndeﬁnable in a ﬁnite structure also has an existential deﬁnition.\nUsing the concept of model completeness, we can restate Theorem 3.2.11, clari-\nfying in which sense the structure B constructed in Theorem 3.2.11 is unique. In the\nfollowing, τ is a ﬁnite relational signature.\nTheorem 3.6.8 (a variant of Theorem 3.2.11). Let N be a ﬁnite set of ﬁnite\nconnected τ-structures. Then there is a model-complete τ-structure B whose age is\nthe class of all ﬁnite N-free structures. The structure B is unique up to isomorphism.\nProof. Theorem 3.2.11 states the existence of an ω-categorical N-free struc-\nture which is universal for the class of all countable N-free structures which has a\nhomogeneous expansion by primitive positive deﬁnable relations. By (3) ⇒(1) in\nTheorem 3.6.7, the structure B is indeed model-complete. We have to show that\nevery model-complete structure C with the same age as B is isomorphic to B. Let T\nbe the ﬁrst-order theory of B, and S be the ﬁrst-order theory of C. Since B and C\nhave the same age, S and T imply the same existential sentences. By Theorem 3.6.5,\nS and T are equivalent theories. By ω-categoricity of T, B and C are isomorphic.\n□\n3.6.3. Cores. We have already encountered the concept of a core of a ﬁnite\nstructure in Section 1.1. To recall, a core is a structure B such that all endomor-\nphisms of B are embeddings, and a structure B is a core of A if B is a core and\nhomomorphically equivalent to A. The concept of the core of a ﬁnite relational struc-\nture plays an important role in the classiﬁcation program for ﬁnite-domain CSPs.\nThree crucial properties of ﬁnite cores are:\n• every ﬁnite structure A has a core B (Proposition 1.1.10);\n• all core structures B of A are isomorphic (Proposition 1.1.10);\n• orbits of k-tuples in ﬁnite cores B are primitive positive deﬁnable (Proposi-\ntion 1.2.9).\nAlso for every inﬁnite structure A there is a core B such that CSP(A) = CSP(B).\nThis follows from Lemma 3.5.3 and the following proposition.\nProposition 3.6.9. If B is an epc model for its universal negative theory, then\nB is a core.\n\n3.6. QUANTIFIER-ELIMINATION, MODEL-COMPLETENESS, CORES\n71\nProof. Suppose B is epc for its universal negative theory T, and let h be an\nendomorphism of B.\nBy epc, for b1, . . . , bk in B, if B |= R(h(b1), . . . , h(bk)) or\nB |= (h(b1) = h(b2)), then B |= R(b1, . . . , bk) or B |= (b1 = b2), respectively. It\nfollows that h is an embedding.\n□\nThere are many equivalent deﬁnitions of when a ﬁnite structure is a core: for\nexample, a ﬁnite structure is a core if and only if all endomorphisms are surjec-\ntive, or injective, or bijective, or all endomorphisms are automorphisms. For inﬁnite\nstructures (even when they are ω-categorical), these deﬁnitions are in general not\nequivalent, see [17, 18, 25].\nAs we will see in this section, our deﬁnition of cores\nis the most appropriate deﬁnition in many contexts, in particular in the context of\nconstraint satisfaction for ω-categorical templates.\nExample 3.6.10. The structure (Q; <) is easily seen to be a core: every endo-\nmorphism of (Q; <) must be injective, and must be strong. In contrast, the random\ngraph (V; E) is not a core. By the deﬁning property of the random graph, (V; E)\ncontains arbitrarily large ﬁnite cliques. By Lemma 3.1.5, it even has an inﬁnite clique\nas a subgraph. Therefore, (V; E) has endomorphisms with the property that they\nmap pairs of non-adjacent vertices to pairs of adjacent vertices, and thus is not a\ncore.\nBefore we prove general results about existence and uniqueness of cores, we state\nimportant properties of cores and model-complete cores for ω-categorical structures\nthat follow in a straightforward way from previous facts3.\nTheorem 3.6.11. Let B be ω-categorical. Then B is a core if and only if every\nexistential formula is equivalent to an existential positive formula over B. Moreover,\nthe following are equivalent.\n(1) B is a model-complete core;\n(2) B has a homogeneous expansion by relations R1, R2, . . . such that the rela-\ntions Ri and their complements have existential positive deﬁnitions;\n(3) Every ﬁrst-order formula is equivalent to an existential positive one over B;\n(4) The orbits of n-tuples in B are primitive positive deﬁnable in B;\n(5) The automorphisms locally generate the endomorphisms of B.\nProof. The ﬁrst statement is straightforward from Theorem 3.4.7. To prove the\nequivalence of (1)-(5), we show implications in cyclic order.\nFor the implication from (1) to (2), consider the expansion of B by all relations\nwith an existential positive deﬁnition in B. Since all endomorphisms of B also pre-\nserve the complements of those relations, the complements also have an existential\npositive deﬁnition by Theorem 3.4.7, and hence the expansion is of the desired type.\nThe orbits of n-tuples of B (and its expansion) are by assumption preserved by all\nendomorphisms of B, and therefore have an existential positive deﬁnition in B, and\nthus a quantiﬁer-free deﬁnition in the expansion. It follows that the expansion is\nhomogeneous.\nFor the implication from (2) to (3), let φ be a ﬁrst-order formula. Then φ has in\nthe homogeneous expansion of B a quantiﬁer-free deﬁnition ψ; assume without loss\nof generality that ψ is written in conjunctive normal form. If we replace all positive\nliterals that involve relations Ri by their existential positive deﬁnition in B, and\nall negative literals that involve relations Ri by the existential positive deﬁnition of\nthe complement of Ri in B, we arrrive at an equivalent formula which is existential\npositive in the signature of B.\n3Yet another characterization of when an ω-categorical structure is a model-complete core can\nbe found in Proposition 3.6.20.\n\n72\n3. MODEL THEORY\nFor the implication from (3) to (4), let O be an orbit of n-tuples in B.\nBy\nTheorem 3.3.8, O has a ﬁrst-order deﬁnition. Assuming (2), O even has an existential\npositive deﬁnition. Note that every existential positive formula can be written as a\ndisjunction of primitive positive formulas, so let φ be such a deﬁnition of O. We can\nalso assume without loss of generality that none of the disjuncts in φ implies another\n(otherwise, we simply omit it). Since O is a minimal ﬁrst-order deﬁnable relation, φ\ncan only contain a single disjunct, and therefore is primitive positive.\n(4) implies (5). Assume (4), and let e be an endomorphism of B. To show that\ne is locally generated by the automorphism of B, let t be a ﬁnite tuple of elements\nof B. We have to show that there is an automorphism α of B such that e(t) = α(t).\nThe orbit of t is primitive positive deﬁnable, and hence preserved by e. So e(t) is in\nthe same orbit as t, and we are done.\n(5) implies (1). Suppose (5), that is, suppose that all endomorphisms are gener-\nated by the automorphisms of B. Since the automorphisms preserve all ﬁrst-order\nformulas in B, the same is true for the endomorphisms of B, by Proposition 3.4.8.\n□\nThe fact that in ω-categorical model-complete cores the orbits of n-tuples are\nprimitive positive deﬁnable is one of the three key facts for ﬁnite cores B that we\nhave mentioned above.\nThe other two facts, existence and uniqueness of model-\ncomplete cores for ω-categorical structures, follow from more general theorems that\napply not only to ω-categorical structures, as we will see in Section 3.6.6.\n3.6.4. Core Theories. A theory T is called a core theory if every homomor-\nphism between models of T is an embedding.\nNote that a ﬁnite or ω-categorical\nstructure B is a core if and only if it has a core theory (for ω-categorical B, this is\nan easy consequence of the L¨owenheim-Skolem theorem – Theorem 2.3.3).\nProposition 3.6.12. Let T be a ﬁrst-order τ-theory. Then T is a core theory if\nand only if every existential formula is equivalent to an existential positive formula.\nProof. First assume that T is a core theory, and let φ be an existential formula.\nThen φ is preserved by all embeddings between models of T. Since all homomorphism\nbetween models of T are embeddings, φ is also preserved by all homomorphisms\nbetween models of T. Hence, Theorem 3.4.3 implies that φ is equivalent modulo T to\nan existential positive formula. The converse implication is trivial.\n□\nWe would like to point out an interesting corollary for CSPs. Let B be a structure\nwith ﬁnite relational signature τ. The constraint entailment problem for B is the\nfollowing computational problem. The input consists of a primitive positive τ-formula\nφ, and a single atomic τ-formula ψ, both φ and ψ with free variables x1, . . . , xn. The\nquestion is whether φ implies (entails) ψ in B, i.e., whether\nB |= ∀x1, . . . , xn (φ ⇒ψ) .\nCorollary 3.6.13. Let τ be a ﬁnite relational signature, and let B be a τ-\nstructure whose ﬁrst-order theory T is a core theory. Then there is a polynomial-time\nTuring reduction from the constraint entailment problem for B to CSP(B).\nProof. Let φ, ψ be an input to the constraint entailment problem for B. Since\nT is a core theory, ¬ψ is by Proposition 3.6.12 equivalent to an existential positive\nτ-formula, and hence equivalent to a disjunction ψ1 ∨· · · ∨ψm of primitive positive\nformulas. Since the signature τ is ﬁnite, we can consider the size of this disjunction is\nbounded by a constant, for all possible inputs. Then φ entails ψ if and only if for all\n1 ≤i ≤m, we have that ∃x1, . . . , xk (φ∧ψi) is false in B. Like this we have reduced the\nentailment problem to solving a constant number of constraint satisfaction problems\nfor the structure B.\n□\n\n3.6. QUANTIFIER-ELIMINATION, MODEL-COMPLETENESS, CORES\n73\nIf we combine the assumption that T is a core theory with the assumption that\nit is model-complete, we arrive at Theorem 3.6.14. Its proof closely follows the proof\nof Theorem 7.3.1 in [120].\nTheorem 3.6.14. Let T be a ﬁrst-order theory over signature τ. Then the fol-\nlowing are equivalent.\n(1) T is a model-complete core theory.\n(2) Every model of T is an existential positive complete model of T.\n(3) If A, B are models of T and h is a homomorphism from A to B then there\nare an elementary extension C of A and an embedding g of B into C such\nthat gh is the identity on A.\n(4) Every ﬁrst-order formula is equivalent to an existential positive formula mod-\nulo T.\nProof. (1) implies (2) is immediate from the deﬁnition of epc models: if A and\nB are models of T and h: A →B is a homomorphism from A to B, then h must\nbe an embedding since T is a core theory, and in fact must be elementary since T is\nmodel-complete. Hence, for every tuple ¯a from A and any existential positive formula\nφ such that h(¯a) satisﬁes φ we have that ¯a also satisﬁes φ.\n(2) implies (3).\nAssume (2).\nLet A and B be models of T, and let h be a\nhomomorphism from A to B. Choose ¯a to be a vector that enumerates the elements\nof A. Since A is an epc model of T, h is an embedding. Hence, every existential\nsentence that holds in (B, h(¯a)) also holds in (A, ¯a). Proposition 2.4.3 now directly\nimplies (3).\n(3) implies (4). We ﬁrst claim that if (3) holds, then every homomorphism be-\ntween models of T preserves all universal τ-formulas. For if h is a homomorphism\nof A into B, ¯a a tuple from A and φ(¯x) a universal τ-formula such that A |= φ(¯a),\nthen taking C and g as in (3) we have C |= φ(g(h(¯a))) and so B |= φ(h(¯a)) since φ\nis a universal formula. This proves the claim. It follows from Theorem 3.4.3 that all\nuniversal τ-formulas are equivalent to existential positive τ-formulas.\nTo ﬁnally prove (4), let φ(¯x) be any ﬁrst-order τ-formula, wlog. in prenex normal\nform. By a simple induction on the number of quantiﬁer-blocks we can transform φ\nto an existential formula, using the fact that the innermost quantiﬁer block is either\nexistential or universal, and can therefore be transformed into an existential formula\n(see Theorem 7.3.1 in [120]). Finally, existential τ-formulas are preserved by homo-\nmorphisms between models of T, since such homomorphisms must be embeddings.\nHence, the entire formula is even equivalent to an existential positive formula by\nTheorem 3.4.3.\n(4) implies (1). Existential positive formulas are preserved by homomorphisms\nbetween models of T.\n□\nFrom this we obtain a positive version of a fact known as Lindstr¨om’s test (The-\norem 7.3.4 in [120]).\nProposition 3.6.15. Let T be a λ-categorical τ-theory, for λ ≥|τ|, which has\nno ﬁnite models, and whose unique model of cardinality λ is epc for T. Then T is a\nmodel-complete core theory.\nProof. We prove that every model of T is an epc model of T and use Theo-\nrem 3.6.14. So let A and B be two models of T and let h be a homomorphism from\nA to B. Let ¯a be a tuple such that B |= φ(h(¯a)) and suppose for contradiction that\nA ̸|= φ(¯a). Then we can put those two structures into a new 2-sorted structure (com-\nprising A, B, and the homomorphism h between them) with ﬁrst-order theory T ′, and\napply the L¨owenheim-Skolem theorem (Theorem 2.3.3; here we use the assumption\n\n74\n3. MODEL THEORY\nthat λ ≥|τ|) to produce a countable model of T ′ (where both sorts have the same\ncardinality since T has no ﬁnite models). By applying L¨owenheim-Skolem again, this\ntime to T ′ augmented by sentences expressing a bijection between the two sorts over\na signature expanded by a new function symbol, we obtain a two-sorted model of\nT ′ where each sort has cardinality λ, inducing structures C and D, respectively. By\nassumption there exists an epc model of cardinality λ, and by λ-categoricity C is an\nepc model of T. This contradicts the fact that we can express in T ′ that A is not an\nepc model of T.\n□\nProposition 3.6.16. Let T be a model-complete core theory. Then T is equivalent\nto a ∀∃+-theory.\nProof. This is an immediate consequence of Theorem 3.4.6 (where the theory\ndenoted by T in Theorem 3.4.6 is empty and Φ from Theorem 3.4.6 equals the theory\nT from the statement here) because for any sequence (Bi)i<κ of models of T with\nhomomorphisms gij : Bi →Bj, the gij are elementary. By the Tarski-Vaught theorem\n(Theorem 2.5.2), we have that (limi<κ Bi) |= T.\n□\n3.6.5. Core Companions. In this section we study when we can pass from a\ntheory T to a model-complete core theory T ′ that has the same CSP.\nDefinition 3.6.17. Let T be a ﬁrst-order τ-theory. Then a τ-theory U is called\na core companion of T if\n• U is a model-complete core theory;\n• every model of U homomorphically maps to a model of T;\n• every model of T homomorphically maps to a model of U.\nRecall from Proposition 2.4.5 that the last two items in Deﬁnition 3.6.17 are\nequivalent to requiring that T and U imply the same universal negative sentences.\nProposition 3.6.18. Let T be a ∀∃+-theory with signature τ. If T has a core\ncompanion U, then U is up to equivalence of theories unique, and is the theory of the\nclass of all epc models of T.\nProof. It suﬃces to show that the epc models of T are precisely the models of\nU. We ﬁrst show that every model B of U is an epc model for T; that is, we have to\nshow that B is a model of T, and that B is epc for T.\nSince U is a core companion of T, there is a homomorphism e from B to a model\nA of T. The assumption that U is a core companion of T also implies that there\nexists a homomorphism f from A into a model C of U. Then f ◦e is a homomorphism\nbetween two models of U, and since U is a model-complete core theory it must be an\nelementary embedding. This shows in particular that e is an embedding.\nWe claim that B is a model of the ∀∃+-theory T. Let φ = ∀¯y.ψ be a sentence\nfrom T where ψ is a disjunction of existential positive and negated atomic τ-formulas,\nand let ¯b be a tuple from B. Since A is a model of T and therefore satisﬁes ∀y.ψ, in\nparticular the tuple e(¯b) satisﬁes ψ. If e(¯b) satisﬁes a negated atom in the disjunction\nψ then ¯b also satisﬁes ψ as e is an embedding. Otherwise, e(¯b) satisﬁes an existential\npositive formula in the disjunction ψ, and f(e(¯b)) satisﬁes φ in C as well since f is a\nhomomorphism. But this shows that ¯b satisﬁes ψ in B since f ◦e is elementary. Since\nthis holds for all ¯b, we have proven that B satisﬁes φ.\nThe veriﬁcation that B is an epc model for T is similar, and as follows. Let g\nbe a homomorphism from B into another model A of T, ¯b a tuple from B, and φ\nan existential positive formula with A |= φ(g(¯b)). We have to show that B |= φ(¯b).\nAgain, since U is a core companion of T there exists a homomorphism h from A\ninto a model C of U. Since U is a model-complete core theory, the mapping h ◦g\n\n3.6. QUANTIFIER-ELIMINATION, MODEL-COMPLETENESS, CORES\n75\nis elementary. Since h preserves existential positive formulas, C |= φ(h(g(¯b))). Since\nh ◦g is elementary, B |= φ(¯b).\nConversely, we show that every epc model B of T satisﬁes U.\nBy Proposi-\ntion 3.6.16, U is equivalent to a ∀∃+-theory, and thus it suﬃces to show that B\nsatisﬁes all ∀∃+-consequences ∀¯y.ψ(¯y) of U, where ψ is a disjunction of existential\npositive and negative atomic τ-formulas. Let ¯b be a tuple of elements of B. We have\nto show that B |= ψ(¯b). Since U is a core companion, there is a homomorphism h\nfrom B to a model A of U. Since A |= ∀¯y.ψ(¯y), at least one disjunct θ(h(¯b)) of ψ is\ntrue in A. If θ is a negative atomic formula, then θ(¯b) is also true in B since h is a\nhomomorphism. Now suppose that θ is an existential positive formula. Since U is a\ncore companion of T, there is a homomorphism g from A to a model C of T. Since g\npreserves θ we have that C |= θ(g(h(¯b))). Now B |= θ(¯b), since B is an epc model of\nT. In both cases we can conclude that B |= ψ(¯b).\n□\nProposition 3.6.19. Let T be a ∀∃+-theory with signature τ. Then T has a core\ncompanion if and only if the class of epc models of T is axiomatizable by a τ-theory.\nProof. If T has a core companion U, then Proposition 3.6.18 above implies that\nU axiomatizes the epc models of T.\nFor the converse, suppose that the class of epc models of T is the class of all\nmodels of a τ-theory U. Then every model of U is in particular a model of T, and\nevery model of T homomorphically maps to a model of U by Lemma 3.5.3. So we\nonly have to verify that U is a model-complete core theory to show that U is the\ncore companion of T. Every model A of U is an epc model of T, and in fact an epc\nmodel of U. It follows by the equivalence of (1) and (2) in Theorem 3.6.14 that U is\na model-complete core theory.\n□\n3.6.6. ω-categorical model-complete cores. We have already seen in Theo-\nrem 3.6.11 that whether an ω-categorical structure is a model-complete core can be\ncharacterized in many diﬀerent ways. The results in Section 3.6.4 provide a further\ncharacterization of ω-categorical model-complete cores in terms of their axiomatiza-\ntion, as we see in the following.\nProposition 3.6.20. Let B be a countable ω-categorical structure. Then B is a\nmodel-complete core if and only if its theory is equivalent to a ∀∃+-theory.\nProof. One direction is Proposition 3.6.16. For the other direction, assume that\nthe theory of B is equivalent to a ∀∃+-theory T. Then T has no ﬁnite models, and\nhence T has a countably inﬁnite model that is epc for T, by Lemma 3.5.3. Hence,\nby Proposition 3.6.15, T is a model-complete core theory (since T is ω-categorical,\nit is easy to see that we can assume for this application that the signature of T is\ncountable), and so B is a model-complete core.\n□\nWe now present an existential positive version of Simmons’ theorem (Theo-\nrem 3.6.6), which answers the question which CSPs can be formulated with an ω-\ncategorical template. For a satisﬁable theory T, let ∼T\nn be the equivalence relation\ndeﬁned on existential positive formulas with n free variables x1, . . . , xn (we could have\nequivalently used primitive positive formulas here) as follows. For two such formulas\nφ1 and φ2, let φ1 ∼T\nn φ2 if for all existential positive formulas ψ with free variables\nx1, . . . , xn we have that {φ1, ψ}∪T is satisﬁable if and only if {φ2, ψ}∪T is satisﬁable.\nTheorem 3.6.21. Let T be a theory with the joint homomorphism property (JHP;\nconfer Proposition 2.4.6). Then the following are equivalent.\n(i) T has a core companion that is either ω-categorical or the theory of a ﬁnite\nstructure.\n\n76\n3. MODEL THEORY\n(ii) ∼T\nn has ﬁnitely many equivalence classes for each n.\n(iii) T has ﬁnitely many maximal existential positive n-types for each n.\n(iv) There is a ﬁnite or ω-categorical model-complete core B that satisﬁes an\nexistential positive sentence φ if and only if T ∪{φ} is satisﬁable.\nProof. We show (i) ⇒(ii) ⇒(iii) ⇒(iv) ⇒(i).\n(i) ⇒(ii). Let U be the core companion of T. Since U and T entail the same\nuniversal negative sentences, we can deduce that for every existential positive formula\nψ the theory U ∪{ψ} is satisﬁable if and only if T ∪{ψ} is satisﬁable; from which it\nfollows that the indices of ∼U\nn and ∼T\nn coincide.\nFor a proof by contraposition, assume that ∼U\nn has inﬁnite index for some n. Let\nψ1 and ψ2 be two existential positive formulas from diﬀerent equivalence classes of ∼U\nn .\nHence, there is an existential positive formula ψ3 such that exactly one of {ψ1, ψ3}∪U\nand {ψ2, ψ3} ∪U is satisﬁable. This shows that ψ1 and ψ2 are inequivalent modulo\nU. Therefore there are inﬁnitely many ﬁrst-order formulas with n variables that are\ninequivalent modulo U, and U can neither be ω-categorical by Theorem 3.1.4 nor the\ntheory of a ﬁnite structure.\n(ii) ⇒(iii). We show that every maximal ep-n-type p is determined completely\nby the ∼T\nn equivalence classes of the existential positive formulas contained in p. Since\nthere are ﬁnitely many such classes, the result follows. Let p and q be maximal ep-\nn-types such that for every φ1 ∈p there exists φ′\n1 ∈q such that φ1 ∼T\nn φ′\n1 and for\nevery φ2 ∈q, there exists φ′\n2 ∈p such that φ2 ∼T\nn φ′\n2. We aim to prove that p = q.\nIf not then there exists, without loss of generality, ψ ∈p such that ψ /∈q. Since q is\nmaximal, T ∪q ∪{ψ} is not satisﬁable. By compactness, T ∪{θ, ψ} is not satisﬁable\nfor some ﬁnite conjunction θ of formulas from q. Now, θ ∈q by maximality and\nthere exists by assumption θ′ ∈p such that θ ∼T\nn θ′. By deﬁnition of ∼T\nn we deduce\nT ∪{θ′, ψ} satisﬁable iﬀT ∪{θ, ψ} satisﬁable. Since the latter is not satisﬁable, we\ndeduce that neither is the former, which yields the contradiction that T ∪p ∪{ψ} is\nnot satisﬁable.\n(iii) ⇒(iv). An existential positive formula φ(¯x) is said to isolate a maximal\nep-n-type p(¯x) of T, if p is the only maximal ep-n-type of T of which φ is a member.\nIf there is only a ﬁnite number of maximal ep-n-types of T, then it follows that\neach has an isolating formula. Assume (iii), and let S be the set of all existential\npositive sentences φ such that T ∪{φ} is satisﬁable, together with the set of all\nuniversal negative consequences of T. By Proposition 2.4.6, S has a model C, and by\nTheorem 2.3.3 we can assume that C is either ﬁnite or countable. Lemma 3.5.3 gives\na homomorphism from C to a ﬁnite or countable epc τ-model B of S. Note that also\nB satisﬁes exactly those existential positive sentences that are satisﬁable together\nwith T. We consider the signature τ ′, which is the expansion of τ by µn relations of\neach arity n, corresponding to the maximal pp-n-types of T. Any model of T has a\ncanonical (unique) expansion to a τ ′-structure, by the new relation symbols labeling\ntuples that attain their type. Consider this canonical τ ′-expansion B′ of B. We will\nshortly prove that B′ is homogeneous. From this it will follow that B′ and B are\nﬁnite, or ω-categorical by Lemma 3.2.10 (since variable identiﬁcations are primitive\npositive, there is only a ﬁnite number of inequivalent atomic formulas of each arity\nn), whereupon ω-categoricity is inherited by its τ-reduct B.\nTo prove that B is a model-complete core, we use Theorem 3.6.11, and show that\nevery ﬁrst-order formula φ is equivalent to an existential positive formula over B.\nSince B has a homogeneous expansion B′ by primitive positive deﬁnable relations,\nφ is equivalent to a Boolean combination of primitive positive formulas. Because we\nhave added a relation symbol for each maximal pp-n-type of T, and there are ﬁnitely\nmany of those for each n, the negation of a primitive positive formula is equivalent to\n\n3.6. QUANTIFIER-ELIMINATION, MODEL-COMPLETENESS, CORES\n77\na ﬁnite disjunction of maximal pp-n-types. This proves that φ is in B equivalent to\nan existential positive formula.\nIt remains to be shown that B′ is homogeneous. Let f : (a1, . . . , am) 7→(b1, . . . , bm)\nbe a partial automorphism of B′ (in the signature τ ′). Let a′ be an arbitrary element\nof B′. Consider the ep-n-types p(x1, . . . , xm) of (a1, . . . , am) and q(x1, . . . , xm, y) of\n(a1, . . . , am, a′) in B.\nBy Proposition 3.5.5, each of these types is maximal, and is isolated by the ep-\nformulas θp(x1, . . . , xm) and θq(x1, . . . , xm, y), respectively. Furthermore, the type of\n(b1, . . . , bm) in B is p, because the partial automorphism of B′ respects the signature\nτ ′. But now, since ∃y. θq(x1, . . . , xm, y) is in p (by maximality), we may deduce a b′\nsuch that B′ |= θq(b1, . . . , bm, b′) and consequently B′ |= q(b1, . . . , bm, b′). It follows\nthat f ′ : (a1, . . . , am, a′) 7→(b1, . . . , bm, b′) is a partial automorphism of B′ (in the\nsignature τ ′). A simple back-and-forth argument shows that we may extend to an\nautomorphism of B′, and the result follows.\nFor the implication (iv) ⇒(i), observe that a ﬁnite or ω-categorical structure B\nis a model-complete core if and only if it has a model-complete core theory – this is an\neasy consequence of the L¨owenheim-Skolem theorem (Theorem 2.3.3). So it suﬃces\nto show that the ﬁrst-order theory of B and T have the same universal negative\nconsequences, by Proposition 2.4.5. A universal negative sentence φ is implied by T\nif and only if T ∪{¬φ} is unsatisﬁable, which is the case if and only if B does not\nsatisfy ¬φ (and hence satisﬁes φ).\n□\nTheorem 3.6.21 implies a necessary and suﬃcient condition when an CSP can be\nformulated with an ω-categorical template.\nCorollary 3.6.22. Let A be a structure with a ﬁnite relational signature. Then\nthe following are equivalent.\n(1) There is an ω-categorical template B such that CSP(B) = CSP(A);\n(2) ∼Th(A)\nn\nhas ﬁnite index for all n;\n(3) There exists a structure B with CSP(B) = CSP(A) which has for all n ≥1\nﬁnitely many primitive positive deﬁnable relations of arity n.\nProof. The implications from (1) to (3) and from (3) to (2) are easy.\nThe\nimplication from (2) to (1) follows from (ii) ⇒(iv) in Theorem 3.6.21.\n□\nWe present a simple new proof of the following result from [25].\nTheorem 3.6.23 (of [25]). Every ω-categorical structure A is homomorphically\nequivalent to an ω-categorical model-complete core B. All model-complete cores of A\nare isomorphic to B.\nProof. Let T be the ﬁrst-order theory of A; clearly, T has the JHP. Since T is\nω-categorical, ∼T\nn has ﬁnite index for each n (Theorem 3.1.4), and Theorem 3.6.21\nimplies that T has a core companion S which is either ω-categorical or the theory of\na ﬁnite structure. By Proposition 3.6.18, the core companion of Th(A) is unique up\nto equivalence of ﬁrst-order theories. Since Th(B) is ω-categorical or the theory of a\nﬁnite structure, it follows that B is unique up to isomorphism.\n□\nSince the model-complete core B of A from the previous theorem is unique up\nto isomorphism, we call it the model-complete core of A.\nThe following gives an\nindication that the model-complete core of an ω-categorical structure A is typically\n‘simpler’ than A.\nProposition 3.6.24. Let A be an ω-categorical structure, and let B its model-\ncomplete core. Then\n\n78\n3. MODEL THEORY\n• for every n, the number of orbits of n-tuples in B is at most the number of\norbits of n-tuples in A;\n• if A is homogeneous, then B is homogeneous as well.\nProof. Let f be a homomorphism from A to B, and g be a homomorphism from\nB to A. It suﬃces to show that when two n-tuples t1, t2 from B are mapped by g\nto tuples s1, s2 in the same orbit in A, then t1 and t2 lie in the same orbit in B. Let\nα be an automorphism of A that maps s1 to s2. Since B is an ω-categorical model-\ncomplete core, there are primitive positive deﬁnitions φ1 and φ2 of the orbits of t1 and\nt2. Since g, α, and f preserve primitive positive formulas, the tuple t3 := f(αg(t1))\nsatisﬁes φ1. As αg(t1) = s2 = g(t2), the tuple t3 can also be written as f(g(t2)), and\nhence also satisﬁes φ2. Thus, φ1 and φ2 deﬁne the same orbit, and t1 and t2 are in\nthe same orbit.\nFor the second part of the statement, suppose that h is an isomorphism between\ntwo ﬁnite substructures C and C′ of B. Then g(C) induces in A a structure that\nis isomorphic to C, since otherwise the endomorphism e: x 7→f(g(x)) of B would\nnot preserve all ﬁrst-order formulas, contradicting the assumption that B is a model-\ncomplete core. Similarly, g(C′) induces in A a structure that is isomorphic to C′ and\nC, and by homogeneity of A there exists an automorphism α of A that maps g(C) to\ng(C′). The mapping e′ : x 7→f(αg(x)) is an endomorphism of B. By Theorem 3.6.11,\nthis mapping is locally generated by the automorphisms of B, and in particular there\nexists an automorphism β of B such that β(x) = e′(x) for all elements x of C. Since\ne is locally generated by the automorphisms of B, too, there exists γ ∈Aut(B) such\nthat γ(x) = e(x) for all elements x of C′. Then γ−1 ◦β ∈Aut(B) maps C to C′. This\nproves the homogeneity of B.\n□\nWhen the template of a CSP is a model-complete core, then this can be exploited\nin the study of the CSP in many ways. For instance, we have the following consequence\nof Theorem 3.6.11 and Lemma 1.2.8, which is essentially from [25].\nCorollary 3.6.25. Let B be an ω-categorical model-complete core, and let C be\nthe expansion of B by ﬁnitely many unary singleton relations, that is, relations of the\nform {c} for some element c of B. Then for every ﬁnite signature reduct C′ of C there\nexists a ﬁnite signature B′ of B such that CSP(C′) has a polynomial-time reduction\nto CSP(B′).\nProof. Let {c1}, . . . , {ck} be the relations of C that have been added to B, and\nlet C′ be a ﬁnite signature reduct of C. By Theorem 3.6.11, the orbit of (c1, . . . , ck) in\nB has a primitive positive deﬁnition φ in B. Let B′ be the reduct of B whose signature\ncontains all relation symbols mentioned in φ, and the relation symbols of C′ that are\nalso relation symbols in B; observe that the signature of B′ is ﬁnite. Lemma 1.2.8\nimplies that there is a polynomial-time reduction from CSP(C′) to CSP(B′).\n□\n\nCHAPTER 4\nExamples\nThe running examples in the previous chapter were the linear order (Q; <) and\nthe random graph (V; E). Structures deﬁnable in those structures provide further\nexamples of ω-categorical structures, and they will be studied in great detail in Chap-\nter 6, 9, and 10. In this chapter, we present other ω-categorical structures A that will\nnot be treated at the same level of detail as it will be done for (Q; <) and for (V; E)\nin Chapter 9 and Chapter 10. For example, we treat homogeneous C-relations, dense\nsemi-linear orders, and the atomless Boolean algebra. In each case, we give a brief\ndiscussion on what is known about CSPs with templates that can be deﬁned in those\nω-categorical structures. Thereby, we revisit many problems from Section 1.5. We\nalso discuss ω-categorical structures that serve as templates for problems in connected\nmonotone monadic SNP.\nThe ω-categorical structures presented in this chapter are chosen so that they\nilluminate the diversity of the class of all ω-categorical structures, and so that many\ncomputational problems and classes of computational problems from the literature\ncan be formulated as CSPs for those structures.\n4.1. Phylogeny Constraints and Homogeneous C-relations\nThe rooted-triple satisﬁability problem from Section 1.5.2 can be formulated as\nCSP(B) for an ω-categorical template B (an observation from [25]). There are various\ndiﬀerent ways how to deﬁne such a structure B; the most convenient for us is via\namalgamation.\n79\n\n80\n4. EXAMPLES\nLet T be the class of all ﬁnite rooted binary trees T. The leaf structure C of a\ntree T ∈T with leaves L is the relational structure (L; |) where | is a ternary relation\nsymbol, and ab|c holds in C iﬀyca(a, b) lies below yca(b, c) in T (recall that yca(a, b)\ndenotes the youngest common ancestor of a and b in a rooted tree T; see Section 1.5.2).\nWe also call T the underlying tree of C. Let C be the class of all leaf structures for\ntrees from T .\nProposition 4.1.1. The class C is an amalgamation class.\nProof. Closure under isomorphisms and induced substructures is by deﬁnition.\nFor the amalgamation property, let B1, B2 ∈C be such that A = B1 ∩B2 is an\ninduced substructure of both B1 and B2. We want to show that there is an amalgam\nof B1 and B2 over A in C. We inductively assume that the statement has been shown\nfor all triples (A, B′\n1, B′\n2) where B′\n1 ∪B′\n2 is a proper subset of B1 ∪B2.\nLet T1 be the rooted binary tree underlying B1, and T2 the rooted binary tree\nunderlying B2. Let B1\n1 ∈C be the substructure of B1 induced by the vertices below\nthe left child of T1, and B2\n1 ∈C be the substructure of B1 induced by the vertices\nbelow the right child of T1. The structures B1\n2 and B2\n2 are deﬁned analogously for\nB2 instead of B1.\nu\nv\nu\nv\nB1\nB2\n(B1)1\n(B1)2\n(B2)1\n(B2)2\nFigure 4.1. Illustration for the proof of Proposition 4.1.1.\nFirst consider the case that there is a vertex u that lies in both B1\n1 and B1\n2, and a\nvertex v that lies in both B1\n2 and B2\n1 (see Figure 4.1 for an illustration). We claim that\nin this case no vertex w from B2\n2 can lie inside B1: for otherwise, w is either in B1\n1,\nin which case we have uw|v in B1, or in B2\n1, in which case we have vw|u in B1. But\nsince u, v, w are in A, this is in contradiction to the fact that uv|w holds in B2. Let\nC′ ∈C be the amalgam of B1 and B1\n2 over A, which exists by inductive assumption,\nand let T′ ∈T be its underlying tree. Now let T be the tree with root r and T′ as a\nleft subtree, and the underlying tree of B2\n2 as a right subtree. It is straightforward to\nverify that the leaf structure of T is in C, and that it is an amalgam of B1 and B2\nover A (via the identity embeddings).\nUp to symmetry, the only remaining essentially diﬀerent case we have to consider\nis that B1\n1 ∪B1\n2 and B2\n1 ∪B2\n2 are disjoint. In this case it is similarly straightforward\nto ﬁrst amalgamate B1\n1 with B1\n2 and B2\n1 with B2\n2 to obtain the amalgam of B1 and\nB2; the details are left to the reader.\n□\n\n4.1. PHYLOGENY CONSTRAINTS AND HOMOGENEOUS C-RELATIONS\n81\nLet B denote the Fra¨ıss´e-limit of C. The structure B is homogeneous, so it is\na fortiori model-complete.\nIt is straightforward to verify that B is a core.\nSince\nthe age of B is the class of all leaf structures for structures from T , it is obvious\nthat CSP(B) is the rooted triple consistency problem. The relation | in B is closely\nrelated to so-called C-relations, following the terminology of [2]. C-relations became\nan important concept in model theory, see e.g. [111]. They are given axiomatically;\nthe presentation here follows [2,45].\nA ternary relation C is said to be a C-relation on a set L if for all a, b, c, d ∈L\nthe following conditions hold:\nC1 C(a; b, c) →C(a; c, b);\nC2 C(a; b, c) →¬C(b; a, c);\nC3 C(a; b, c) →C(a; d, c) ∨C(d; b, c);\nC4 a ̸= b →C(a; b, b).\nA C-relation is called dense if it satisﬁes\nC7 C(a; b, c) →∃e (C(e; b, c) ∧C(a; b, e)).\nThe structure (L; C) is also called a C-set.\nA structure Γ is said to be relatively\nk-transitive if for every partial isomorphism f between induced substructures of Γ\nof size k there exists an automorphism of Γ that extends f. Note that a relatively\n3-transitive C-set is necessarily 2-transitive (i.e., has a 2-transitive automorphism\ngroup, as deﬁned in Section 3.3.3).\nTheorem 4.1.2 (Theorem 14.7 in [2]). Let (L; C) be a relatively 3-transitive C-\nset. Then (L; C) is ω-categorical.\nIn fact, there is, up to isomorphism, a unique relatively 3-transitive countable C-\nset which is dense and uniform with branching number 2, that is, satisﬁes ∀x, y, z\n\u0000(x ̸=\ny ∨x ̸= z ∨y ̸= z) ⇒(C(x; y, z) ∨C(y; x, z) ∨C(z; x, y))\n\u0001\n(see the comments in [2]\nafter the statement of Theorem 14.7).\nIt is straightforward to verify that the Fra¨ıss´e-limit B of the amalgamation class\nfrom Proposition 4.1.1 has the same automorphism group (equivalently, is ﬁrst-order\ninterdeﬁnable; see Section 3.3) as the relatively 3-transitive dense countable C-set\nthat is uniform with branching number 2.\nA similar approach is possible to deﬁne a homogeneous template for the quartet\nsatisﬁability problem from Section 1.5.2.\nAlternatively, an ω-categorical template\n(B; Q) for the quartet satisﬁability problem can be given via a ﬁrst-order deﬁnition in\nthe structure B = (B; |) constructed above for the rooted triple consistency problem.\nThe following deﬁnition will be useful now, and later. Since yca is associative as\na binary operation, it makes sense to write yca(v1, . . . , vl) for\nyca(v1, . . . , yca(vl−1, vl) . . . ) .\nDefinition 4.1.3. When u1, . . . , uk and v1, . . . , vl are leaves in a rooted tree T,\nthen we write u1 . . . uk|v1 . . . , vl if u := yca(u1, . . . , uk) and v := yca(v1, . . . , vl) are\ndisjoint in T, i.e., neither u lies above v nor v lies above u in T.\nThe ﬁrst-order deﬁnition of Q(x, y, u, v) is\n(xy|uv) ∨(uv|x ∧vx|y) ∨(xy|u ∧yu|v) .\nIndeed, when u, v, x, y ∈B, and T is the tree underlying the substructure of (B; |)\ninduced by {u, v, x, y}, then the given formula describes the situation that the shortest\npath from x to y in T does not intersect the shortest path from u to v in T. Note\nthat whether this is true is in fact independent from the position of the root of T.\nWe leave the veriﬁcation to the reader that CSP((B; Q)) indeed describes the quartet\n\n82\n4. EXAMPLES\nsatisﬁability problem studied in comptuational biololgy. Lemma 3.1.10 implies ω-\ncategoricity of (B; Q).\nSimilarly as for the C-relation given above, an axiomatic\ntreatment of (B; Q) has been given in [2]; there, the relation Q has been called\na D-relation, and this became standard terminology in model theory. As we have\nmentioned above, the structure (B; Q) can also be deﬁned as a Fra¨ıss´e-limit of ﬁnite\nD-structures (see Cameron [70]).\n4.2. Branching-Time Constraints\nThe branching-time satisfaction problem from Section 1.5.3 can be formulated as\nCSP(B) for an ω-categorical structure B = (D; ≤, ∥, ̸=); this has already been ob-\nserved in [47]. This time, B has an explicit description. The domain B consists of the\nset of all non-empty ﬁnite sequences of rational numbers. For a = (q1, q1, . . . , qn), b =\n(q′\n1, q′\n1, . . . , q′\nm), n ≤m, we write a < b if one of the following conditions holds:\n• a is a proper initial subsequence of b, i.e., n < m and qi = q′\ni for 1 ≤i ≤n;\n• qi = q′\ni for 1 ≤i < n, and qn < q′\nn.\nWe use a ≤b to denote (a < b) ∨(a = b), and ∥denotes the binary relation that\ncontains all pairs of elements that are incomparable with respect to <; in particular,\nwe have a ∥a for all a. A proof that B = (B; ≤, ∥, ̸=) is 1-transitive and ω-categorical\ncan be found in [2] (Section 5).\nThe reduct (B; ≤) of this structure is a semi-linear order, i.e., for all x ∈D, the set\n{y | y ≤x} is linearly ordered by <; such structures have been studied systematically\nin the context of inﬁnite permutation groups; see [70, 87]. The structure B is not\nhomogeneous, and therefore cannot be described as the Fra¨ıss´e-limit of a class of ﬁnite\nstructures.\nHowever, it has an expansion by primitive positive deﬁnable relations\nwhich is homogeneous. The following is well-known and straightforward to verify.\nProposition 4.2.1. The expansion of B by the ternary relation with the primitive\npositive deﬁnition\n∃u\n\u0000(u ≤x) ∧(u ≤y) ∧(u ∥z)\n\u0001\nand the ternary relation with the primitive positive deﬁnition\n∃u\n\u0000x||y ∧x ̸= y ∧(u ≤x) ∧(u ≤y) ∧(z ≤u) ∧(z ̸= u)\n\u0001\nis homogeneous.\nTherefore it is possible to describe the structure (D; ≤, ∥, ̸=) as the reduct of the\nFra¨ıss´e-limit of an amalgamation class; the respective proof is similar to the proof of\nProposition 4.1.1. Proposition 4.2.1 in combination with Theorem 3.6.7 also shows\nthat B is model-complete.\nThe structure B has four orbitals, with the primitive\npositive deﬁnitions x ≤y ∧x ̸= y, y ≤x ∧x ̸= y, x ∥y ∧x ̸= y, and x = y. Since\nall relations of B are binary, this implies that every endomorphism of B must be an\nembedding, and hence B is a core.\nThe expansion B′ of B by the ﬁrst of the two ternary relations given in Proposi-\ntion 4.2.1 also has an age that has amalgamation; however, its Fra¨ıss´e-limit B′′ is not\nisomorphic to B′ because it lacks joins, that is, the second of the ternary relations in\nProposition 4.2.1 holds for all triples x, y, z with x||y, x ̸= y, z < y, and z < y.\n4.3. Set Constraints\nHere we discuss how the set constraint satisfaction problems discussed in Sec-\ntion 1.5.5, and many other set constraint satisfaction problems, can be formulated\nwith ω-categorical templates, following [34].\n\n4.3. SET CONSTRAINTS\n83\nHere, a set constraint satisfaction problem is a CSP for a template with a ﬁrst-\norder deﬁnition in the structure S with domain P(N), the set of all subsets of natural\nnumbers, and with signature {∩, ∪, c, 0, 1}, where\n• ∩is a binary function symbol that denotes intersection, i.e., ∩S = ∩;\n• ∪is a binary function symbol for union, i.e., ∪S = ∪;\n• c is a unary function symbol for complementation, i.e., cS is the function\nthat maps S ⊆N to N \\ S;\n• 0 and 1 are constants (treated as 0-ary function symbols) denoting the empty\nset ∅and the full set N, respectively.\nA set constraint language is a relational structure with a set of relations with\na quantiﬁer-free ﬁrst-order deﬁnition in S; we always allow equality in ﬁrst-order\nformulas. For example, the relation {(x, y, z) ∈P(N)3 | x ∩y ⊆z} has the quantiﬁer-\nfree ﬁrst-order deﬁnition z ∩(x ∩y) = x ∩y over S.\nProposition 4.3.1 (follows from Proposition 5.8 in [160]). Let B be a set con-\nstraint language with a ﬁnite signature. Then CSP(B) is in NP.\nThe ﬁrst-order theory of the structure S is certainly not ω-categorical – it is\neasy to verify that there are inﬁnitely many pairwise inequivalent ﬁrst-order formu-\nlas with one free variable. However, all set constraint satisfaction problems can be\nformulated with an ω-categorical template. To see this, ﬁrst note that the structure\n(P(N); ∪, ∩, c, 0, 1) is a Boolean algebra, with\n• 0 playing the role of false, and 1 playing the role of true;\n• c playing the role of ¬;\n• ∩and ∪playing the role of ∧and ∨, respectively.\nTo facilitate the notation, we write ¯x instead of c(x), and x ̸= y instead of ¬(x = y).\nAn atom in a Boolean algebra is an element x ̸= 0 such that for all y with\nx ∩y = y and x ̸= y we have y = 0.\nIf a Boolean algebra does not contains\natoms, it is called atomless.\nIt is well-known that there exist countable atomless\nBoolean algebras, and that all countable atomless Boolean algebras are isomorphic\n(Corollary 5.16 in [137]; also see Example 4 on page 100 in [119]). Let A denote\nsuch a countable atomless Boolean algebra; the domain A is denoted by A. Since the\naxioms of Boolean algebras and the property of not having atoms can all be written\nas ﬁrst-order sentences, it follows that A is ω-categorical. We also remark that the\nstructure A has quantiﬁer elimination (see Exercise 17 on Page 391 in [119]). The\nlink between the set constraint satisfaction problems over 2N mentioned in Section 1.5\nand the atomless Boolean algebra is the following.\nProposition 4.3.2. Let C be a set constraint language. Then there exists an\nω-categorical structure B such that B and C have the same existential theory. In\nparticular, when C has ﬁnite signature, then B and C have the same CSP.\nProof. Let φ1, φ2, . . . be quantiﬁer-free ﬁrst-order formulas that deﬁne the re-\nlations RC\n1 , RC\n2 , . . . of C over S = (P(N); ∪, ∩, c, 0, 1).\nLet RA\n1 , RA\n2 , . . . be the re-\nlations deﬁned by φ1, φ2, . . . over the atomless Boolean algebra A.\nThe structure\nB = (A; RA\n1 , RA\n2 , . . . ) is ω-categorical (see the comment after Lemma 3.1.10). To\nverify that B and C have the same existential theory, let Φ be a conjunction of\natomic formulas over the signature {R1, R2, . . . }. Replace each atomic formula of the\nform Ri(x1, . . . , xk) in Φ by the formula φi(x1, . . . , xk). The resulting formula is a\nquantiﬁer-free ﬁrst-order formula in the language of Boolean algebras, {∪, ∩, c, 0, 1}.\nWe claim that Φ is satisﬁable in S if and only if it is satisﬁable in A. This follows\nfrom Corollary 5.7 in [160]: Φ is satisﬁable in some inﬁnite Boolean algebra if and\nonly if Φ is satisﬁable in all inﬁnite Boolean algebras.\n□\n\n84\n4. EXAMPLES\nA large class of tractable set constraint languages has been described in [34]; the\nclass given there is maximal tractable in the sense that every strictly larger class of\nset constraint languages contains a ﬁnite subset with an NP-hard CSP.\n4.4. Spatial Reasoning\nThe essential reasons why the network satisfaction problem for RCC5 (introduced\nin Section 1.5.6) is not a set constraint satisfaction problem as introduced in the\nprevious section is that in RCC5 we exclude the empty set as a possible value for the\nvariables. To formulate the CSP for the network satisfaction problem of RCC5 and\nits fragments with ω-categorical templates, we again use structures with a ﬁrst-order\ndeﬁnition in the atomless Boolean algebra, but restrict those structures to non-zero\nelements (this observation has already been made in [89], Proposition 4.4).\nFormally, let A be the atomless Boolean algebra, and let DR, PO, PP, PPI, EQ be\nthe binary relations with the following ﬁrst-order deﬁnition in A (and their intuitive\nmeaning in quotes).\nDR(x, y) iﬀ(x ∩y = 0) ∧x ̸= y ∧x, y /∈{0, 1}\n‘x and y are disjoint’\nPP(x, y) iﬀ(x ∩y = x) ∧x ̸= y ∧x, y /∈{0, 1}\n‘y properly contains x’\nPPI(x, y) iﬀ(x ∩y = y) ∧x ̸= y ∧x, y /∈{0, 1}\n‘x properly contains y’\nEQ(x, y) iﬀx = y ∧x, y /∈{0, 1}\n‘x equals y’\nPO(x, y) iﬀ¬DR(x, y) ∧¬PP(x, y) ∧¬PPI(x, y) ∧x ̸= y ∧x, y /∈{0, 1}\n‘x and y properly overlap’\nWhen D is the structure that contains all binary relations that are ﬁrst-order deﬁn-\nable in (A \\ {0, 1}; DR, PO, PP, PPI, EQ) (so that we can associate a binary relation\nfrom D to every element of RCC5 in the natural way), then CSP(D) and the network\nsatisfaction problem for RCC5 are essentially the same problem (in the sense of Sec-\ntion 1.3.2). The structure D has a (1-dimensional) ﬁrst-order interpretation in A, and\nhence is ω-categorical by Lemma 3.1.10. It can be shown that the model companion\nof D gives a representation of RCC5.\n4.5. CSPs and Fragments of SNP\nRecall that a constraint satisfaction problem can be viewed as a class of ﬁnite\nstructures with ﬁnite relational signature (as described in Section 1.1 and Section 1.4),\nnamely the class of all satisﬁable instances of the CSP. In this section we study the\nquestion when this class can be described by a τ-sentence Φ from a ﬁxed logic L in\nthe sense that for all ﬁnite structures A, we have that A |= Φ if and only if A ∈C. If\nthere is such a sentence then we say that CSP(B) is in L.\nThe ﬁrst two logics considered here will be ﬁrst-order logic, and monadic SNP.\nIt turns out that CSPs that can be described by a sentence from those logics can\nbe formulated with ω-categorical templates.\nFinally, we present a new and more\nexpressive logic, called Amalgamation SNP. Again, every problem in amalgamation\nSNP describes a problem in NP that can be formulated as CSP(B) for an ω-categorical\ntemplate B, and the universal-algebraic techniques presented in later sections can be\napplied to study the computational complexity of the problems in this logic.\n\n4.5. CSPS AND FRAGMENTS OF SNP\n85\n4.5.1. First-order Deﬁnable CSPs. We ﬁrst consider the situation where\nCSP(B) is in FO, i.e., can be described by a ﬁrst-order sentence (in the sense just\ndescribed). The class of CSPs in FO is quite restricted. It is not hard to see that\nwhen CSP(B) is in FO, then in particular it can be solved in deterministic logarith-\nmic space. We will see that when CSP(A) is in FO, then there exists an ω-categorical\nstructure B that has the same CSP1. We use the following famous result.\nTheorem 4.5.1 (Homomorphism Preservation in the Finite [180]). Let τ be a\nﬁnite relational signature, and let Φ be a ﬁrst-order τ-sentence. Then Φ is equivalent\nto an existential positive ﬁrst-order sentence on all ﬁnite τ-structures if and only if\nthe class of all ﬁnite τ-models of Φ is closed under homomorphisms (Deﬁnition 1.1.6).\nIn the rest of this section, τ is a ﬁnite relational signature, and B be a τ-structure.\nRecall that CSP(B), viewed as a class of ﬁnite τ-structures, is closed under inverse\nhomomorphisms and disjoint unions. In particular, the class of all ﬁnite τ-structures\nthat do not homomorphically map to B is closed under homomorphisms, and by\nTheorem 4.5.1 describable by an existential positive τ-sentence Ψ. This leads us to\nthe following.\nTheorem 4.5.2. If CSP(B) is in FO, then there exists an ω-categorical structure\nB′ that has the same CSP.\nProof. From the remarks that precede the statement of the theorem, Theo-\nrem 4.5.1 shows that there is an existential positive τ-sentence Ψ such that A ho-\nmomorphically maps to B if and only if A satisﬁes ¬Ψ. The sentence ¬Ψ can be\nre-written as a universal negative sentence in conjunctive normal form; let Φ be such\na universal negative sentence of minimal size. We claim that the canonical database C\nfor each conjunct in Φ is connected. To see this, suppose that C has several connected\ncomponents. If one of them does not homomorphically map to B, then Φ was not\nof minimal size, since the corresponding conjunct could have been replaced by the\n(smaller) conjunctive query for the component. If all components homomorphically\nmap to B, then so does C, a contradiction to the fact that C is the canonical database\nof a conjunct of Φ.\nTherefore each conjunct in Φ is connected, and we can apply Theorem 3.2.11 to\nthe ﬁnite set N of canonical databases for all the conjuncts in Φ. From Theorem 3.2.11\nwe obtain an ω-categorical τ-structure which is universal for CSP(B), which is what\nwe had to show.\n□\n4.5.2. CSPs in Monadic SNP. Also every CSP in monadic SNP can be for-\nmulated with an ω-categorical template.\nTheorem 4.5.3 (from [31]). Let C be a structure with a ﬁnite relational signa-\nture. If CSP(C) can be described by a monadic SNP sentence Φ, then there is an\nω-categorical B such that CSP(B) = CSP(C).\nProof. By Corollary 1.4.15, we can assume without loss of generality that Φ is\na connected and monotone monadic SNP sentence.\nWe assume without loss of generality that Φ is written in negation normal form.\nLet P1, . . . , Pk be the existential monadic predicates in Φ. Let τ ′ be the signature\ncontaining the input relations from τ, the existential monadic relations Pi, and new\nsymbols P ′\ni for the negative occurrences of the existential relations.\nBy monotonicity, all such literals with input relations are positive. For each exis-\ntential monadic relation Pi we introduce an existentially quantiﬁed monadic relation\n1An exact characterization of those ω-categorical structures that are in FO can be found in [35],\nobtained by a slight modiﬁcation of a proof for ﬁnite domain CSPs in [144].\n\n86\n4. EXAMPLES\nsymbol P ′\ni, and replace negative literals of the form ¬Pi(x) in Φ by P ′\ni(x). We shall\ndenote the τ ′-formula obtained from Φ after this transformation by Φ′. We deﬁne N\nto be the set of τ ′-structures containing for each clause ψ in Φ′ its canonical database\n(as deﬁned in Section 1.4.3). We shall use the fact that a τ ′-structure A satisﬁes a\nclause ψ if and only if the canonical database of ψ is not homomorphic to A. Since\nΦ is connected, all structures in N are connected.\nThen Theorem 3.2.11 asserts the existence of a N-free ω-categorical τ ′-structure\nB′ that is universal for all N-free structures. We use B′ to deﬁne the template B with\nthe properties required in the statement of the theorem we are about to prove. The\nstructure B is the τ-reduct of the restriction of B′ to the points with the property\nthat for all existential monadic predicates Pi, 1 ≤i ≤k, either Pi or P ′\ni holds (but\nnot both Pi and P ′\ni). It follows from Theorem 3.1.10 that reducts of ω-categorical\nstructures, and restrictions to ﬁrst-order deﬁnable subsets of ω-categorical structures\nare again ω-categorical. Hence, the resulting τ-structure B is ω-categorical.\nWe claim that a τ-structure A satisﬁes Φ if and only if A homomorphically maps\nto B. First, let A be a structure that has a homomorphism h to B. Let A′ be the\nτ ′-expansion of A such that for all i ≤k and a ∈A the relation Pi(a) holds in A′ if\nand only if Pi(h(a)) holds in B′, and P ′\ni(a) holds in A′ if and only if P ′\ni(h(a)) holds\nin B′. Clearly, h deﬁnes a homomorphism from A′ to B′. In consequence, none of\nthe structures from N maps to A′. Hence, the τ-reduct A of A′ satisﬁes Φ.\nConversely, let A be a τ-structure satisfying Φ. Consequently, there exists a τ ′-\nexpansion A′ of A that satisﬁes the ﬁrst-order part of Φ′, and where for every a ∈A\nexactly one of Pi(a) or P ′\ni(a) holds. Clearly, no structure in N is homomorphic to\nA′, and by universality of B′ the τ ′-structure A′ is an induced substructure of B′.\nSince for every a ∈A exactly one of Pi(a) and P ′\ni(a) holds, A′ is also an induced\nsubstructure of the restriction of B′ to B. Consequently, A is homomorphic to the\nτ-reduct of this restriction. This completes the proof.\n□\n4.5.3. Amalgamation SNP. In this section we introduce a logic that describes\nonly CSPs with ω-categorical templates, and which we call Amalgamation SNP, or\nshort ASNP.\nDefinition 4.5.4. Amalgamation SNP is the logic that consists of all monotone\nSNP sentences Φ where the class of all ﬁnite models of the ﬁrst-order part of Φ has\nthe amalgamation property.\nIt can be veriﬁed that the examples of SNP sentences given for CSP((Z; <)) in\nExample 1.4.2 and for CSP((Z; Betw)) in Example 1.4.3 are in fact Amalgamation\nSNP sentences. Recall that a structure is called ﬁnitely bounded if its age can be\ndescribed by ﬁnitely many forbidden induced substructures (Deﬁnition 3.2.8).\nProposition 4.5.5. Every sentence in Amalgamation SNP describes a problem\nof the form CSP(B) for an ω-categorical structure B that can be expanded to a ho-\nmogeneous ﬁnitely bounded structure.\nProof. To prove the ﬁrst statement, let Φ be a sentence in ASNP, let τ be the\ninput signature of Φ (i.e., the free relation symbols in Φ), and let φ be the ﬁrst-order\npart of Φ (which is a σ-formula, for σ ⊇τ). Since the class of all ﬁnite models of φ\nhas the amalgamation property, Theorem 3.2.2 asserts the existence of a countable\nhomogeneous σ-structure C whose age is exactly the class of all ﬁnite σ-structures\nthat satisfy φ. The structure C is ﬁnitely bounded; this is witnessed by the set N\nof all σ-structures N with a minimal number of vertices that do not satisfy φ. None\nof those structures N can have larger size than the number of variables of φ, and\nhence N is ﬁnite.\nTo see that N indeed bounds the age of C, let A be a ﬁnite\n\n4.5. CSPS AND FRAGMENTS OF SNP\n87\ninduced substructure of C. Then A cannot have a substructure from N, since any\nsuch substructure would falsify φ, and hence also A would not satisfy φ. Now suppose\nthat C does not contain A as a ﬁnite induced substructure. This means that A falsiﬁes\nφ. Then there is a minimal number of elements witnessing that the universal formula\nφ is false in A, and those elements induce a structure from N, which proves the\nclaim. By Lemma 3.2.10 the structure C is ω-categorical. The τ-reduct B of C is also\nω-categorical (Lemma 3.1.10).\nWe ﬁnally show that every ﬁnite τ-structure A satisﬁes Φ if and only if it homo-\nmorphically maps (in fact, embeds) into B. When A is a τ-structure that satisﬁes\nΦ, then there exists a σ-expansion A′ of A that satisﬁes φ. By universality of C the\nsame map is an embedding of A′ into C, and this gives an embedding of A into B.\nConversely, suppose that there is a homomorphism f from a τ-structure A to B.\nThen we construct the σ-expansion A′ of A by putting for all S ∈σ \\ τ the tuple\n(t1, . . . , tn) into SA′ if and only if (f(t1), . . . , f(tn)) ∈SC. Suppose for contradiction\nthat there were a tuple t = (t1, . . . , tk) of elements that violates a clause of φ in this\nexpansion A′. Then the image of f induces a substructure in C that also violates φ,\nsince all relation symbols from τ appear negatively in φ. This is a contradiction, and\nhence A′ satisﬁes φ. We conclude that A satisﬁes Φ.\n□\nWe want to give an example of an ω-categorical structure B such that CSP(B)\nis in NP, but not in Amalgamation SNP. To show that CSP(B) is not in ASNP, the\nsequence (mn)n≥1 of numbers of maximal pp-n-types of Th(B) turns out to be useful\n(see Section 3.6.6). Note that when two structures have the same CSP, then they have\nthe same number of maximal pp-n-types. Hence, when Φ is a sentence from ASNP,\nthere is a unique sequence (mn)n≥1 such that mn equals the of maximal pp-n-types of\nTh(B) for any B such that Φ describes CSP(B). We call (mn)n≥1 the characteristic\nsequence of Φ.\nProposition 4.5.6. Let Φ be a sentence from Amalgamation SNP. Then the\ncharacteristic sequence of Φ is in O(2P (n)), for some polynomial P.\nProof. Proposition 4.5.5 shows that there exists an ω-categorical structure B\nsuch that Φ describes CSP(B). The proof of Proposition 4.5.5 shows that there exists\nan expansion C of B by ﬁnitely many relation symbols which is homogeneous. Hence,\nan orbit of n-tuples in C is uniquely described by the atomic formulas that hold on\na (equivalently, all) tuples from this orbit, and since the signature of C is ﬁnite, this\ngives a bound of 2P (n) on the number of orbits of n-tuples in C, for some polynomial\nwhose degree equals the maximal arity of the relations in C. The number of orbits of\nn-tuples is an upper bound on the number of maximal pp-n-tpyes (since two tuples\nwith the same orbit clearly have the same pp-type).\n□\nWe can now present the example of an ω-categorical structure B such that\nCSP(B) is in NP, but not in ASNP. We use a CSP for a set constraint languages, as\nintroduced in Section 1.5.5.\nExample 4.5.7. Let B be the structure that contains all relations of arity at most\nthree with a quantiﬁer-free ﬁrst-order deﬁnition in the atomless Boolean algebra A.\nSince A is ω-categorical, the signature of B is ﬁnite. By Proposition 4.3.1, CSP(B) is\nin NP. To prove that CSP(B) is not in ASNP it suﬃces to show that the characteristic\nsequence of Φ grows faster than O(2P (n)), for any polynomial P. We ﬁrst show that\nB is a model-complete core. Trivially, B is a core, since with each relation also the\ncomplement of the relation is a relation of B. To see that B is model-complete, let\nφ be a ﬁrst-order formula that deﬁnes a ﬁrst-order relation R over B; we have to\nshow that R also has an existential deﬁnition over B. By quantiﬁer-elimination of A\n\n88\n4. EXAMPLES\n(recall that A has function symbols ∪, ∩, c, 0, 1), there is a quantiﬁer-free ﬁrst-order\nformula ψ that deﬁnes R over A. By un-nesting terms in ψ with the help of new\nexistentially quantiﬁed variables, and replacing occurrences of atomic formulas by\nthe corresponding formulas in the language of B (for instance replacing formulas of\nthe form x ∩y = z by S(x, y, z) where S is the relation of B deﬁned by x ∩y = z), we\nﬁnd the required existential deﬁnition of R in B. By Theorem 3.6.11, the orbits of\nn-tuples in B are primitive positive deﬁnable, and so mn equals the number of orbits\nof n-tuples of B.\nWe show that mn ≥22⌊n/2⌋. To see this, let l = ⌊n/2⌋and X := {x1, . . . , xl}\nbe elements such that for any two distinct subsets S1, S2 of X the elements ∩S1 and\n∩S2 of A are distinct. Hence, there are 2l many elements a1, . . . , a2l that can by\nformed from x1, . . . , xl by applying ∩, and there are 22l many ways of selecting a\ntuple (y1, . . . , yl) of elements from {a1, . . . , a2l}. For any such selection, and since\nthe relations {(x, y, z) | x ∩y = z} and {(x, y, z) | x ∪y = z} are in B, the tuple\n(x1, . . . , xl, y1, . . . , yl) will lie in a distinct orbit, which shows the claim.\nFrom this example and the proof of Proposition 4.5.6 we can also see the following,\nwhich we note for later use.\nCorollary 4.5.8. There is no relational structure B that can deﬁne the atomless\nBoolean algebra and is homogeneous in a ﬁnite relational signature.\n4.5.4. CSPs in SNP without an ω-categorical template. We have seen\nin Section 1.4.3 that every CSP in SNP is also in connected monotone SNP. We\nhave also seen a characterization of those CSPs that can be formulated with an ω-\ncategorical template (Theorem 3.6.21). So it is natural to ask for a concrete example of\na connected monotone SNP sentence that cannot be formulated with an ω-categorical\ntemplate.\nExample 4.5.9. Let Φ be the following connected monotone SNP sentence.\n∃E, T ∀x, y, z\n\u0000‘E is equivalence relation’\n∧‘T is transitive irreﬂexive and extends succ’\n∧((succ(x, y) ∧E(x, z)) ⇒succ(z, y))\n∧((succ(x, y) ∧E(y, z)) ⇒E(x, z))\n∧((succ(x, y) ∧succ(x, z)) ⇒E(y, z))\n∧((succ(x, y) ∧succ(z, y)) ⇒E(y, z))\n∧(¬E(x, y) ∨¬succ(x, y))\n\u0001\nThe sentence Φ describes CSP((Z; succ)) where succ = {(x, y) ∈Z2 | y = x+1} (as in\nSection 1.7.4.1). The idea is that an {succ, E, T}-structure satisﬁes the quantiﬁer-free\npart of Φ if\n• E(x, y) holds if for all homomorphisms from the {succ}-reduct of the struc-\nture to (Z; succ) we have h(x) = h(y), and\n• T(x, y) holds for all homomorphisms h from the {succ}-reduct of the struc-\nture to (Z; succ) we have h(x) < h(y).\n□\nProposition 4.5.10. CSP((Z; succ)) cannot be formulated with an ω-categorical\ntemplate.\nProof. The number of maximal pp-n-types is the same in any structure B where\nCSP(B) is described by Φ, so by Corollary 3.6.22 it suﬃces to check that (Z; succ)\n\n4.5. CSPS AND FRAGMENTS OF SNP\n89\nhas an inﬁnite number of maximal pp-2-types. But this is clear since the formula\nφn(x0, xn) deﬁned by ∃x1, . . . , xn−1\nVn\ni=1 succ(xi−1, xi) is for each n in a diﬀerent\npp-2-type.\n□\n\n\nCHAPTER 5\nUniversal Algebra\nOne of the central concerns of universal algebra, similarly as in model-theory, is\nclassiﬁcation of mathematical structures. Often, model-theory is considered to be an\nextension of universal algebra, as formulated by Chang and Keisler in\nmodel-theory = univeral algebra + logic.\nUniversal algebra leads to classiﬁcation results with ﬁner distinctions: while model\ntheory often considers two relational structures to be equal when they are ﬁrst-order\n91\n\n92\n5. UNIVERSAL ALGEBRA\ninterdeﬁnable, universal algebra provides methods that allow to distinguish relational\nstructures up to primitive positive deﬁnability. To do so, we study higher-dimensional\ngeneralizations of endomorphisms monoids, called polymorphism clones; from the\nperspective of this text, we therefore have\nmodel-theory = one-dimensional universal algebra.\nThe strongest universal-algebraic classiﬁcation results are available on ﬁnite do-\nmains [118].\nIn recent years, strong links between deep and central questions in\nuniversal algebra and the Feder-Vardi conjecture have led to renewed activity. In\nfact, several important new and purely algebraic results, for example from [13,123,\n159,187], were originally motivated by questions about CSPs.\nThere has been less work on algebras over inﬁnite domains. However, a consid-\nerable amount of universal-algebraic techniques also applies when the algebra under\nconsideration contains as operations all the permutations from an oligomorphic per-\nmutation group; we will call such algebras oligomorphic. The assumption that the\nalgebra be oligomorphic seems to provide the necessary amount of ‘ﬁniteness’ that we\nneed for applying universal-algebraic methods.\nWe have decided to give a self-contained presentation of this section, even though\nthat this implies a certain redundancy for the reader who has already followed Chap-\nter 3. The step from algebras with only unary functions to algebras that contain\nhigher-ary functions is the step where universal algebra becomes interesting. At the\nsame time, the step from studying automorphisms and embeddings to studying poly-\nmorphisms is the step that is new to model-theorists, so we found it natural to divide\nthe material into a chapter on model theoretic and a chapter on universal algebraic\nbackground.\nThis chapter contains original material from [26,27,29,30,47].\n5.1. Oligomorphic Clones\nFix a countably inﬁnite base set B, also called the domain or base set.\nFor\nn ≥1, denote by O(n) the set BBn = (Bn →B) of n-ary operations on B. Then\nO := S\nn≥1 O(n) is the set of all operations on B of ﬁnite arity. A clone C is a subset\nof O satisfying the following two properties:\n• C contains all projections, i.e., for all 1 ≤k ≤n the operation πn\nk ∈O(n)\ndeﬁned by πn\nk (x1, . . . , xn) = xk, and\n• C is closed under composition, that is, for all f ∈C ∩O(n) and g1, . . . , gn ∈\nC ∩O(m) the operation f(g1, . . . , gn) ∈O(m) deﬁned by\n(x1, . . . , xm) 7→f(g1(x1, . . . , xm), . . . , gn(x1, . . . , xm))\nis an element of C .\nFor our applications of universal algebra in logic, we are interested in clones that\nsatisfy an additional topological closure property1. A clone C is called locally closed2\nif and only if it satisﬁes the following interpolation property:\nfor all n ≥1 and all g ∈O(n), if for all ﬁnite A ⊆Bn there exists\nan n-ary f ∈C which agrees with g on A, then g ∈C .\n1The corresponding topology is deﬁned as follows. Equip B with the discrete topology, and\nO(n) = BBn with the corresponding product (Tychonoﬀ) topology, for every n ≥1. (For background\nin topology, see Chapter 7.) A clone C is closed with respect to this topology iﬀeach of its n-ary\nfragments C ∩O(n) is a closed subset of O(n).\n2In universal algebra, locally closed clones are often just called local clones. Topologists would\ncall such objects just closed clones since the reference to the speciﬁc topology under consideration\nis clear. Our choice to call those objects locally closed is a compromise, and standard [190].\n\n5.2. THE INV-POL GALOIS CONNECTION\n93\nThe following proposition is folklore in universal algebra, see e.g. [190]. Its proof\nis very similar to the proof of Proposition 3.3.2, and we leave it to the reader.\nProposition 5.1.1. Let F ⊆O be a set of operations. Then the following are\nequivalent.\n(1) F is the polymorphism clone of a relational structure;\n(2) F is a locally closed clone.\nArbitrary intersections of clones are clones, and arbitrary intersections of locally\nclosed sets are locally closed. In fact, the set of all locally closed clones on B, partially\nordered by inclusion, forms a complete lattice. The join of a family (Ci)i∈I can be\nobtained as follows. First, take the set of all operations on B which can be obtained\nby composing operations from S\ni∈I Ci; this set is a clone, but might not be locally\nclosed. For this reason, we have to additionally form the topological closure of this\nset in order to arrive at the join in this lattice. For a set of operations F ⊆O, we\nwrite ⟨F⟩for the clone locally generated by F, i.e., for the smallest locally closed\nclone containing F.\nDefinition 5.1.2. Let C ⊆O be a clone. A unary operation e ∈C is called\ninvertible in C if there exists a unary i ∈C such that i(e(x)) = e(i(x)) = x for all\nx ∈B.\nSuppose that C is the polymorphism clone of a structure B. Then obviously any\ninvertible operation of C is an automorphism of B.\nDefinition 5.1.3. A clone C ⊆O is oligomorphic if the set of operations in C\nthat are invertible in C forms an oligomorphic permutation group.\nIt is immediate from Theorem 3.1.4 that a locally closed clone is oligomorphic if\nand only if it is the polymorphism clone of an ω-categorical structure.\n5.2. The Inv-Pol Galois Connection\nThe exposition in this section parallels that of Section 3.3. Let f be from O(n),\nand let R ⊆Bm be a relation. Then we say that f preserves R (and that R is in-\nvariant under f) iﬀf(r1, . . . , rn) ∈ρ whenever r1, . . . , rn ∈R, where f(r1, . . . , rn) is\ncalculated componentwise. For a relational structure B (or for a set of relations R)\nwith domain B, we write Pol(B) (or Pol(R), respectively) for the set of those oper-\nations in O which preserve all relations from B (all relations in R). The operations\nin Pol(B) are called polymorphisms of B. Note that the polymorphisms of B are\nexactly the homomorphism from ﬁnite powers of B to B.\nWe have seen how to assign sets of operations to sets of relations; likewise, we\ncan go the other way. Given a set of operations F ⊆O, we write Inv(F) for the\nset of all relations which are invariant under all f ∈F. Using the Galois connection\ndeﬁned by the operators Pol and Inv, we obtain the following well-known description\nof the hull operator F 7→Pol(Inv(F)) (confer [190], in particular Corollary 1.9).\nProposition 5.2.1. Let F ⊆O, and g ∈O. Then the following are equivalent.\n(1) g ∈⟨F⟩;\n(2) g is in the local closure of the operations of the clone generated by F;\n(3) For all n ≥1 and all a1, . . . , ak ∈Bn there is a f in the clone generated by\nF such that g(a1, . . . , ak) = f(a1, . . . , ak).\n(4) g ∈Pol(Inv(F));\nIn particular, ⟨F⟩= Pol(Inv(F)).\n\n94\n5. UNIVERSAL ALGEBRA\nProof. Note that the set F ′ of all operations that are in the local closure of\nthe clone generated by F is a clone and locally closed. Therefore, the clone ⟨F⟩is\ncontained in F ′, and (1) implies (2).\nFor the implication from (2) to (3), let g be a k-ary operation that is in the local\nclosure of the clone F ′ generated by F. Let a1, . . . , ak be from Bn for some n ≥1.\nSuppose ai = (a1\ni , . . . , an\ni ) for i ≤k, and let aj = (aj\n1, . . . , aj\nk) for j ≤n. Since g is in\nthe closure of F ′, there exists an f ∈F ′ that agrees with g on {a1, . . . , an} ⊆Bk.\nIn particular, g(a1, . . . , ak) = f(a1, . . . , ak).\nFor the implication from (3) to (4), assume (3), and let R be from Inv(F).\nWe have to show that g preserves R.\nLet t1, . . . , tk be from R.\nBy assumption\nf(t1, . . . , tk) = g(t1, . . . , tk) for some operation g generated from operations in F and\nprojections. Since all those operations preserve R, we have that f(t1, . . . , tk) ∈R.\nTo show that (4) implies (1), let f be a k-ary operation from Pol(Inv(F)). Let\nC be the clone generated by F. It suﬃces to show that for every ﬁnite subset A of\nB there is an operation g ∈C such that f(¯a) = g(¯a) for all ¯a ∈Ak. List all elements\nof Ak by a1, . . . , an, and consider the relation\nR := {(g(a1), . . . , g(an)) | g ∈C }.\nNote that R is preserved by all operations in F and so by assumption f preserves\nR.\nAlso note that (a1\ni , . . . , an\ni ) ∈R since C contains the projections.\nTherefore,\n(f(a1), . . . , f(an)) ∈R, and hence (f(a1), . . . , f(an)) = (g(a1), . . . , g(an)) for a g ∈C ,\nas required.\n□\nThe following is straightforward.\nProposition 5.2.2. Let B be any structure. Then Inv(Pol(B)) contains ⟨B⟩pp,\nthe set of all relations that are primitive positive deﬁnable in B.\nProof. Suppose that R is k-ary, has a primitive positive deﬁnition ψ, and let\nf be an l-ary polymorphism of B.\nTo show that f preserves R, let t1, . . . , tl be\ntuples from R. Then there must be witnesses for the existentially quantiﬁed variables\nxl+1, . . . , xn of ψ that show that ψ(ti) holds in B, for all 1 ≤i ≤n. Write si for the\nextension of ti such that si satisﬁes the quantiﬁer-free part ψ′(x1, . . . , xl, xl+1, . . . , xn)\nof ψ (we assume that ψ is written in prenex normal form). Then the tuple\n(f(s1[1], . . . , sl[1]), . . . , f(s1[n], . . . , sl[n]))\nsatisﬁes ψ′ as well. This shows that (f(s1[1], . . . , sl[1]), . . . , f(s1[k], . . . , sl[k])) satisﬁes\nψ in B, which is what we had to show.\n□\nA relation R has a primitive positive deﬁnition in a ﬁnite structure if and only\nif R is preserved by all polymorphisms of this structure.\nThis was discovered by\nGeiger [102] and independently by Bodnarcuk et al. [56], and is of central importance\nin universal algebra.\nWe have the following generalization of this theorem to ω-\ncategorical structures [46].\nTheorem 5.2.3 (from [46]). Let B be an ω-categorical or a ﬁnite structure. A\nrelation R has a primitive positive deﬁnition in B if and only if R is preserved by all\npolymorphisms of B; in symbols, Inv(Pol(B)) = ⟨B⟩pp.\nProof. One direction has been shown in Proposition 5.2.2. For the other di-\nrection, let R be a k-ary relation that is preserved by all polymorphisms of B. In\nparticular, R is preserved by all automorphisms of B, and hence R is a union of orbits\nof k-tuples in the automorphism group of B. By item (2) of Theorem 3.1.4, there is\na ﬁnite number of such orbits, O1, . . . , Ow. If R is empty, there is nothing to show\n(but we again use the assumption that ⊥is allowed as a primitive positive formula),\n\n5.3. ESSENTIAL ARITY\n95\nso let us assume that w ≥1. Fix for each 1 ≤j ≤w a k-tuple aj from Oj. Let B\nbe the domain of B. Let b1, b2, . . . be an enumeration of all w-tuples in Bw with the\nadditional property that for 1 ≤i ≤k we have bi = (a1[i], . . . , aw[i]).\nBy Lemma 3.1.8, if for every ﬁnite substructure A of Bw that contains b1, . . . , bk\nthere is a homomorphism from A to B that maps (b1, . . . , bk) to a tuple that is not in\nR, then there is also a homomorphism from Bk to B that maps (b1, . . . , bk) to a tuple\nthat is not in R, and this would be a polymorphism of B violating R (the properties\nof a mapping to be a polymorphism and to violate R have universal axiomatizations).\nSo there must be a ﬁnite substructure A containing the vertices b1, . . . , bk of Bw such\nthat all homomorphisms from A to B map b1, . . . , bk to a tuple in R.\nLet q1, . . . , ql be the vertices of A without b1, . . . , bk. Write ψ for the quantiﬁer-\nfree part of the canonical query of A (see Section 1.2.1).\nWe claim that the for-\nmula ∃q1, . . . , ql. ψ is a primitive positive deﬁnition of R. The above argument shows\nthat ∃q1, . . . , ql. ψ implies R(b1, . . . , bk).\nTo show that every tuple in R satisﬁes\n∃q1, . . . , ql. ψ, let f : A →B be a homomorphism such that the tuple (f(b1), . . . , f(bk))\nis from R. Then (f(b1), . . . , f(bk)) ∈Oj for some 1 ≤j ≤w. There is an automor-\nphism α of B sending aj to (f(b1), . . . , f(bk)). So we can extend f to a homomor-\nphism from Bw to B by setting f(x1, . . . , xn) := α(xj). This shows in particular that\nf(b1), . . . , f(bk)) satisﬁes ∃q1, . . . , ql. ψ.\n□\nAnalogously to Corollary 3.3.9, we obtain a Galois connection between structures\nwith a ﬁrst-order deﬁnition in an ω-categorical structure C, considered up to primitive\npositive interdeﬁnability, and locally closed clones containing Aut(C).\nTheorem 5.2.4. Let C be a countable ω-categorical structure. Then we have the\nfollowing.\n(1) The set of sets of the form ⟨B⟩pp, where B is ﬁrst-order deﬁnable in C,\nordered by inclusion, forms a lattice.\n(2) The set of locally closed clones that contain Aut(C), ordered by inclusion,\nforms a lattice.\n(3) The operator Inv is an anti-isomorphism between those two lattices, and Pol\nis its inverse.\nThe above theorem tells us that classifying the reducts of an ω-categorical struc-\nture C up to primitive positive interdeﬁnability really amounts to understanding the\nlattice of locally closed clones containing the automorphisms of C.\n5.3. Essential Arity\nThis section investigates the bottom of the lattice of locally closed clones C that\ncontain a ﬁxed oligomorphic permutation group.\n5.3.1. Essentially unary operations. We say that f ∈O(k) depends on the\nargument i ∈{1, . . . , k} if there is no (k−1)-ary operation f ′ such that f(x1, . . . , xk) =\nf ′(x1, . . . , xi−1, xi+1, . . . , xk) for all x1, . . . , xk ∈B. We can equivalently character-\nize k-ary operations that depend on the i-th argument by requiring that there are\nx1, . . . , xk ∈B and x′\ni ∈B such that\nf(x1, . . . , xk) ̸= f(x1, . . . , xi−1, x′\ni, xi+1, . . . , xk) .\nWe say that an operation f is essentially unary iﬀthere is an i ∈{1, . . . , k} and\na unary operation f0 such that f(x1, . . . , xk) = f0(xi).\nOperations that are not\nessentially unary are called essential.3\n3This is standard in clone theory, and it makes sense also for us, since the essential operations\nare those that are essential for complexity classiﬁcation.\n\n96\n5. UNIVERSAL ALGEBRA\nDefinition 5.3.1. For any set B, the relations P B\n3\nand P B\n4\nover B are deﬁned\nas follows.\nP B\n3\n=\n\b\n(a, b, c) ∈B3 | a = b or b = c\n\t\nP B\n4\n=\n\b\n(a, b, c, d) ∈B4 | a = b or c = d\n\t\nLemma 5.3.2. Let f ∈O be an operation on a set B. Then the following are\nequivalent.\n(1) f is essentially unary.\n(2) f preserves P B\n3 .\n(3) f preserves P B\n4 .\n(4) f depends on at most one argument.\nProof. Let k be the arity of f. The implication from (1) to (2) is obvious, since\nunary operations clearly preserve P B\n3 .\nTo show the implication from (2) to (3), we show the contrapositive, and assume\nthat f violates P B\n4 . By permuting arguments of f, we can assume that there are an\nl ≤k and 4-tuples a1, . . . , ak ∈P B\n4\nwith f(a1, . . . , ak) /∈P B\n4\nsuch that in a1, . . . , al\nthe ﬁrst two coordinates are equal, and in al+1, . . . , ak the last two coordinates are\nequal.\nLet c be the tuple (a1\n1, . . . , al\n1, al+1\n4\n, . . . , ak\n4).\nSince f(a1, . . . , ak) /∈P B\n4\nwe\nhave f(a1\n1, . . . , ak\n1) ̸= f(a1\n2, . . . , f k\n2 ), and therefore f(c) ̸= f(a1\n1, . . . , ak\n1) or f(c) ̸=\nf(a1\n2, . . . , ak\n2).\nLet d = (a1\n1, . . . , ak\n1) in the ﬁrst case, and d = (a1\n2, . . . , ak\n2) in the\nsecond case. Likewise, we have f(c) ̸= f(a1\n3, . . . , ak\n3) or f(c) ̸= f(a1\n4, . . . , ak\n4), and let\ne = (a1\n3, . . . , ak\n3) in the ﬁrst, and e = (a1\n4, . . . , ak\n4) in the second case. Then for each\ni ≤k, the tuple (di, ci, ei) is from P B\n3 , but (f(d), f(c), f(e)) /∈P B\n3 .\nThe proof of the implication from (3) to (4) is again by contraposition. Sup-\npose f depends on the i-th and j-th argument, 1 ≤i ̸= j ≤k.\nHence there\nexist tuples a1, b1, a2, b2 ∈Bk such that a1, b1 and a2, b2 only diﬀer at the en-\ntries i and j, respectively, and such that f(a1) ̸= f(b1) and f(a2) ̸= f(b2). Then\n(a1(l), b1(l), a2(l), b2(l)) ∈P B\n4\nfor all l ≤k, but (f(a1), f(b1), f(a2), f(b2)) /∈P B\n4 ,\nwhich shows that f violates P B\n4 .\nFor the implication from (4) to (1), suppose that f depends only on the ﬁrst ar-\ngument. Let i ≤k be maximal such that there is an operation g with f(x1, . . . , xk) =\ng(x1, . . . , xi).\nIf i = 1 then f is essentially unary and we are done.\nOtherwise,\nobserve that since f does not depend on the i-th argument, neither does g, and\nso there is an (i −1)-ary operation g′ such that for all x1, . . . , xn ∈B we have\nf(x1, . . . , xn) = g(x1, . . . , xi) = g′(x1, . . . , xi−1), contradicting the choice of i.\n□\nCombined with Theorem 3.4.7, we obtain for ω-categorical structures a character-\nization of the situation where disjunction can be eliminated from existential positive\nformulas.\nProposition 5.3.3. Let B be an ω-categorical structure, and let C be its poly-\nmorphism clone. Then the following are equivalent.\n(1) All relations with an existential positive deﬁnition in B also have a primitive\npositive deﬁnition in B.\n(2) The relation P B\n3 is contained in Inv(C ).\n(3) All operations in C are essentially unary.\nProof. (1) implies (2). The formula (x = y) ∨(y = z) is existential positive,\nand thus has a primitive positive deﬁnition in B; such formulas are preserved by C .\n(2) implies (3). Follows from Lemma 5.3.2.\n\n5.3. ESSENTIAL ARITY\n97\n(3) implies (1).\nUnary operations preserve all existentially positive formulas.\nHence, when φ is an existential positive formula, then by assumption all polymor-\nphisms of B preserve φ, and φ is equivalent to a primitive positive formula by Theo-\nrem 3.4.7.\n□\nIf all operations of a clone C are essentially unary, we say that C is essentially\nunary.\n5.3.2. Elementary Clones. If every polymorphism of an ω-categorical struc-\nture B is locally generated by the automorphisms of B, then B has the remarkable\nproperty that every ﬁrst-order formula is equivalent to a primitive positive formula\nover B. In this case, the polymorphism clone of B is the smallest element of the\nlattice of locally closed clones described in Section 5.2. The facts in this section are\nstraightforward combinations of previous results. We state them for future use.\nCorollary 5.3.4. Let B be an ω-categorical structure, and let C be its polymor-\nphism clone. Then the following are equivalent.\n(1) Every relation with a ﬁrst-order deﬁnition also has a primitive positive def-\ninition in B.\n(2) B is a model-complete core, and P B\n3 is primitive positive deﬁnable in B.\n(3) C is locally generated by the invertible operations in C .\n(4) All operations in C are elementary, i.e., preserve all ﬁrst-order deﬁnable\nrelations in B.\nProof. (1) implies (2). We assume that every ﬁrst-order deﬁnable relation has\na primitive positive deﬁnition, and hence is preserved by all polymorphisms of B. In\nparticular, the endomorphisms of B preserve all ﬁrst-order deﬁnable relations, and\nhence B is a model-complete core. Moreover, the relation P B\n3\nis clearly ﬁrst-order\ndeﬁnable, and therefore also primitive positive deﬁnable in B.\n(2) implies (3). Assume (2). Then Proposition 5.3.3 implies that all polymor-\nphisms of B are essentially unary. Thus, for every n-ary polymorphism f of B there\nis an endomorphism g of B and an j ≤n such that f(x1, . . . , xn) = g(xj). Since\nB is a model-complete core, and by Theorem 3.6.11, g is locally generated by the\nautomorphisms of B, and in particular by the invertible operations in C . Hence, f\nis locally generated by the locally invertible operations in C , which proves (3).\n(3) implies (4). Invertible operations of C preserve all ﬁrst-order deﬁnable rela-\ntions in B. Hence, the implication follows from Proposition 5.2.1.\n(4) implies (1). By Theorem 5.2.3.\n□\nWe will see in Corollary 5.5.10 that when the equivalent conditions from Corol-\nlary 5.3.4 apply, then B has a ﬁnite signature reduct B′ whose CSP is NP-hard.\n5.3.3. Arity Reduction. For many combinatorial arguments with oligomor-\nphic clones it is crucial to have bounds on the arity of operations with certain proper-\nties. A basic, yet extremely useful observation to obtain such bounds is the following\n(which holds for arbitrary structures B).\nLemma 5.3.5. Let B be a relational structure and let R be a k-ary relation con-\ntained in m orbits of k-tuples of Aut(B). If B has a polymorphism f that violates R,\nthen B also has an at most m-ary polymorphism that violates R.\nProof. Let f ′ be an polymorphism of B of smallest arity l that violates R.\nThen there are k-tuples t1, . . . , tl ∈R such that f ′(t1, . . . , tl) /∈R. For l > m there\nare two tuples ti and tj that lie in the same orbit of k-tuples, and therefore B has\n\n98\n5. UNIVERSAL ALGEBRA\nan automorphism α such that αtj = ti. By permuting the arguments of f ′, we can\nassume that i = 1 and j = 2. Then the (l −1)-ary operation g deﬁned as\ng(x2, . . . , xl) := f ′(αx2, x2, . . . , xl)\nis also a polymorphism of B, and also violates R, a contradiction. Hence, l ≤m.\n□\nWe present applications of Lemma 5.3.5. Recall that r(G ) denotes the rank of G ,\ni.e., the number of orbitals of G (see Section 3.3).\nCorollary 5.3.6. Let B be a structure with an automorphism group G . If B\nhas an essential polymorphism, then it must also have an essential polymorphism of\narity at most 2r(G ) −1.\nProof. The structure B has an essential polymorphism if and only if it has\na polymorphism that violates the relation P B\n3 , where B is the domain of B, by\nProposition 5.3.3. The relation P B\n3\nconsists of at most 2r(G ) −1 orbits of triples:\nthere are at most r(G ) orbits of triples (t1, t2, t3) where t1 = t2 ̸= t3, and at most that\nmany where t1 ̸= t2 = t3. Only the orbit of the tuple where t1 = t2 = t3 is counted\ntwice. The statement follows from Lemma 5.3.5.\n□\nCorollary 5.3.7. Let B be ﬁrst-order deﬁnable in (Q; <), and suppose there is\na polymorphism of B that violates <. Then there is also an endomorphism of B that\nviolates <.\nProof. Observe that < consists of a single orbit of pairs in Aut((Q; <)), and\ntherefore also in Aut(B).\n□\nCorollary 5.3.8. Let F ⊆O be a local clone that contains a 2-transitive per-\nmutation group G . If there is an f ∈F that violates ̸=, then F contains a constant\noperation.\nProof. The relation ̸= consists of a single orbit of pairs in G . Hence, there\nis a unary operation in F that violates ̸= by Lemma 5.3.5.\nThe rest follows by\nLemma 3.4.11.\n□\nAnother application of Lemma 5.3.5 can be found in Section 5.4, and many ap-\nplications can be found in Chapters 9 and 10.\n5.3.4. K´ara’s method. We present another method for showing that an oligo-\nmorphic clone with essential operations must contain a binary essential operation.\nThe method applies in many cases where the arity bounds from Corollary 5.3.6 are\ntoo weak. The idea is taken from [40], where it has been stated only for structures\nthat are preserved by all permutations of the domain, and it has been generalized\nslightly in [51]. To state the method in full generality, we introduce the following,\napparently new, concept.\nDefinition 5.3.9. A permutation group G on a set B has the orbital extension\nproperty if there is an orbital O such that for all b1, b2 ∈B there is an element c ∈B\nsuch that (c, b1) ∈O and (c, b2) ∈O.\nNote that every permutation group with the orbital extension property is transi-\ntive, and that every 2-transitive inﬁnite permutation group has the orbital extension\nproperty. More examples of oligomorphic permutation groups with the orbital exten-\nsion property are the automorphism group of the Random graph, (Q; <), the univer-\nsal homogeneous poset, the universal homogeneous C-relation, and many more. An\nexample of a structure without the orbital extension property is Kω,ω, the complete\nbipartite graph where both parts are countably inﬁnite. An example of an imprimitive\n\n5.3. ESSENTIAL ARITY\n99\noligomorphic permutation group with the orbital extension property is the automor-\nphism group of an equivalence relation on an inﬁnite set with inﬁnitely many inﬁnite\nclasses.\nLemma 5.3.10. Let C be a clone that contains a permutation group G with the\norbital extension property. Then, if C contains an essential operation, it must also\ncontain a binary essential operation.\nProof. Let f be an essential operation in C , and let k be the arity of f. Assume\nwithout loss of generality that f depends all its arguments and is at least ternary.\nIn particular, there are a1, . . . , ak and a′\n1 such that f(a1, . . . , ak) ̸= f(a′\n1, a2, . . . , ak).\nLet O be the orbital of G which exist due to the orbital extension property of G . We\ndistinguish two cases.\nCase 1. There are elements b1, . . . , bk such that (bi, ai) ∈O for 2 ≤i ≤k and\nf(b1, a2, . . . , ak) ̸= f(b1, . . . , bk). Then there are α3, . . . , αk ∈G such that αi(a2) = ai\nand αi(b2) = bi. We deﬁne\ng(x, y) := f(x, y, α3(y), . . . , αk(y)) ,\nwhich clearly depends on both arguments.\nCase 2. For all b1, . . . , bk, if (ai, bi) ∈O for 2 ≤i ≤k, then f(b1, a2, . . . , ak) =\nf(b1, b2, . . . , bk). Since f depends on its second coordinate, there are c1, . . . , ck and\nc′\n2 such that f(c1, c2, c3, . . . , ck) ̸= f(c1, c′\n2, c3, . . . , ck). Then f(c1, a2, . . . , ak) can be\nequal to either f(c1, c2, c3, . . . , ck), or to f(c1, c′\n2, c3, . . . , ck), but not to both. We\nassume without loss of generality that f(c1, a2, . . . , ak) ̸= f(c1, c2, c3, . . . , ck). Since\nG has the orbital extension property, we can choose d2, . . . , dk such that for each\n2 ≤i ≤k, the pairs (di, ai) all lie in O and the pairs (di, ci) all lie in O. Hence,\nthere are α3, . . . , αk ∈G such that αi(c2) = ci and αi(d2) = di. We claim that the\noperation g deﬁned by\ng(x, y) := f(x, y, α3(y), . . . , αk(y))\ndepends on both arguments. Indeed, we know that g(a1, d2) = f(a1, d2, . . . , dk) =\nf(a1, . . . , ak), and that f(a′\n1, d2) = f(a′\n1, d2, . . . , dk) = f(a′\n1, a2, . . . , ak). By the choice\nof the values a1, . . . , ak and a′\n1 these two values are distinct, and we have that g\ndepends on the ﬁrst argument.\nFor the second argument, note that g(c1, d2) =\nf(c1, d2, . . . , dk) = f(c1, a2, . . . , ak) and that g(c1, c2) = f(c1, c2, . . . , ck).\nBecause\nf(c1, a2, . . . , ak) and f(c1, c2, . . . , ck) are distinct, the function g also depends on the\nsecond argument.\n□\nCorollary 5.3.11. Let B be 2-transitive with an essential polymorphism. Then\nB also has a binary essential polymorphism.\n5.3.5. Minimal Operations. In some classiﬁcation results, e.g. in Chapter 9\nand Chapter 10 it turns out that a bottom-up approach works best: for example in\nChapter 9 we ﬁrst classify all the minimal (with respect to set inclusion) locally closed\nclones that strictly contain the automorphism group of the random graph, and then\nthe classiﬁcation argument is organised according to those minimal clones.\nDefinition 5.3.12. Let C ⊆O be a locally closed clone. We say that\n• a local clone D ⊆O is minimal above C if C ⊊D, and C ⊊E ⊆D implies\nE = D for all locally closed clones E .\n• a function f ∈O is minimal above C if f is not from C , and of minimal\narity such that for every g /∈C that is locally generated by C ∪{f} we have\nthat C ∪{g} locally generates f.\nThe following is obvious from the deﬁnitions.\n\n100\n5. UNIVERSAL ALGEBRA\nProposition 5.3.13. Let C be a locally closed clone. Then every minimal oper-\nation above C locally generates a clone that is minimal above C , and every clone that\nis minimal above C is locally generated by a minimal operation above C .\nFor oligomorphic clones C , minimality translates into maximality of Inv(C ), and\nwe obtain the following.\nProposition 5.3.14. Let B be an ω-categorical structure, and let C be primitive\npositive deﬁnable in B. Then Pol(C) is minimal above Pol(B) if and only if for every\nR ∈⟨B⟩pp \\ ⟨C⟩pp the structure B has a primitive positive deﬁnition in (C, R).\nProof. The equivalence follows from Proposition 5.2.4.\n□\nIt is well-known that every clone over a ﬁnite domain contains a clone D which\nis minimal above the trivial clone that just contains the projections [81]. The same\nis not true for inﬁnite domains: the clone with domain N generated by the operation\nx 7→x + 1 does not contain a clone that is minimal above the set of all projections\nover N. The situation is again better when C is oligomorphic.\nTheorem 5.3.15 (from [27]). Let B be a ﬁnite or ω-categorical structure with a\nﬁnite relational signature, and let B be its polymorphism clone. Then any clone C\nthat contains B contains a locally closed clone D that is minimal above B.\nProof. By Proposition 5.3.14, it suﬃces to show that there is a structure D\nwhose relations are a subset of Inv(B) such that for every R ∈Inv(B) \\ Inv(C ) there\nis a primitive positive deﬁnition of B in (D, R).\nConsider the partially ordered set of all locally closed clones that contain B and\nthat are contained in C , ordered by inclusion. From this poset we remove B, which is\nthe unique minimal element; the resulting poset will be denoted by P. We claim that\nin P, all descending chains S1 ⊇S2 ⊇· · · are bounded, i.e., for all such chains there\nexists an S ∈P such that Si ⊇S for all i ≥1. To see this, observe that S\ni≥1 Inv(Si)\nis closed under primitive positive deﬁnability in the sense that it can be written as\n⟨S⟩pp for some relational structure S (since only a ﬁnite number of relations can be\nmentioned in a formula, and since each of the Si is closed under primitive positive\ndeﬁnability).\nMoreover, there must be a relation R ∈B that is not contained in S\ni≥1 Inv(Si);\notherwise, since B has ﬁnitely many relations, there is a j < ω such that Inv(Sj)\ncontains all relations from B, and hence equals Inv(B), which is impossible since B\nis not an element of P. Hence, by Theorem 5.2.4, the structure S has a polymorphism\nf that is not from B. Then B ∪{f} is contained in T\ni≥1 Si and is a lower bound\nof the descending chain (Si)i≥0. We can thus apply Zorn’s lemma and conclude that\nP contains a minimal element S. Any structure D whose relations are exactly the\nrelations from S satisﬁes the initial requirements.\n□\nFor essentially unary oligomorpic clones B, we can bound the arity of minimal\nfunctions above B; this follows from the following.\nProposition 5.3.16 (from [54]). Let B be any relational structure with a ﬁnite\nnumber p of orbitals.\nThen every minimal clone above End(B) is generated by a\nfunction of arity at most 2 · p −1 together with End(B).\nProof. Let C be a minimal clone above End(B). If all the functions in C are\nessentially unary, then C is generated by a unary operation together with End(B)\nand we are done. Otherwise, let f be an essential operation in C . By Lemma 5.3.2\nthe operation f violates P B\n3\nover the domain B of B; recall that P B\n3\nis deﬁned by\nthe formula (x = y) ∨(y = z). The subset of P B\n3 that contains all tuples of the form\n\n5.4. SCHAEFER’S THEOREM\n101\n(a, a, b), for a, b ∈B, clearly consists of p orbits in B. Similarly, the subset of P B\n3 that\ncontains all tuples of the form (a, b, c), for a, b ∈B, consists of the same number of\norbits. The intersection of these two relations consists of exactly one orbit (namely,\nthe triples with three equal entries), and therefore P 3\n3 is the union of 2·p−1 diﬀerent\norbits. The assertion now follows from Lemma 5.3.5.\n□\nIn Section 8.3 we will see that under further Ramsey-theoretic assumptions on\nthe structure B, there are only ﬁnitely many minimal closed clones above the poly-\nmorphism clone of B.\n5.4. Schaefer’s Theorem\nSchaefer’s theorem states that every CSP for a 2-element template is either in P\nor NP-hard. Via the Inv-Pol Galois connection (Section 5.2), most of the classiﬁcation\narguments in Schaefer’s article follow from earlier work of Post [176], who classiﬁed\nall clones on a two-element domain. We present a short proof of Schaefer’s theorem\nhere, using the results and ideas from Section 5.3.\nThe following operations are important in this context.\nA ternary function\nf : B3 →B is called a minority function if it satisﬁes f(x, y, y) = f(y, x, y) =\nf(y, y, x) = x for all x, y ∈B.\nIt is called a majority function if f(x, x, y) =\nf(x, y, x) = f(y, x, x) = x for all x, y ∈B.\nNote that on Boolean domains, the\ngiven identities determine f uniquely. A k-ary operation f is called idempotent iﬀ\nf(x, . . . , x) = x. Also recall the deﬁnition of NAE and 1IN3.\nNAE ={(0, 0, 1), (0, 1, 0), (1, 0, 0), (1, 1, 0), (1, 0, 1), (1, 1, 0)}\n1IN3 ={(0, 0, 1), (0, 1, 0), (1, 0, 0)}\nLemma 5.4.1. Let f be an idempotent function on the domain {0, 1} that violates\n1IN3.\n• If f is binary, then f must be (x, y) 7→min(x, y) or (x, y) 7→max(x, y).\n• If f is ternary, then f generates min, max, the majority, or the minority\noperation.\nProof. There are only four binary idempotent operations on {0, 1}, two of which\nare projections and therefore preserve 1IN3. The other two operations are min and\nmax. If f is ternary, then the operations deﬁned by f(x, x, y), f(x, y, x), and f(y, x, x)\nmust be projections, or otherwise they generate min or max and we are done. So we\nconsider the following eight cases.\nCases\n(1)\n(2)\n(3)\n(4)\n(5)\n(6)\n(7)\n(8)\nf(x, x, y)\nx\nx\nx\nx\ny\ny\ny\ny\nf(x, y, x)\nx\nx\ny\ny\nx\nx\ny\ny\nf(y, x, x)\nx\ny\nx\ny\nx\ny\nx\ny\nIn case (1) the operation f is a majority, and in case (8) a minority. The cases (2), (3),\nand (5) are impossible since in this case f would preserve 1IN3. In the remaining three\ncases, which are symmetric with respect to permuting arguments of f, the function\ndeﬁned by f(x, f(x, y, z), z) is a majority.\n□\nThe following is well-known; the short proof is taken from [72].\nTheorem 5.4.2. If R is a Boolean relation preserved by the minority operation,\nthen R has a deﬁnition by a conjunction of linear equalities modulo 2.\n\n102\n5. UNIVERSAL ALGEBRA\nProof. The proof is by induction on the arity k of R. The statement is clear\nwhen R is unary.\nOtherwise, let R0 be the Boolean relation of arity k −1 de-\nﬁned by R0(x2, . . . , xk) ≡R(0, x2, . . . , xk), and let R1 ⊆{0, 1}k−1 be deﬁned by\nR1(x2, . . . , xk) ≡R(1, x2, . . . , xk).\nBy the inductive assumption, there are con-\njunctions of linear equalities ψ0 and ψ1 deﬁning R0 and R1, respectively.\nIf R0\nis empty, we may express R(x1, . . . , xk) by x1 = 1 ∧ψ1.\nThe case that R1 is\nempty can be treated analogously.\nWhen both R0 and R1 are non-empty, ﬁx a\ntuple (c0\n2, . . . , c0\nk) ∈R0 and a tuple (c1\n2, . . . , c1\nk) ∈R1. Deﬁne c0 to be (0, c0\n2, . . . , c0\nk)\nand c1 to be (1, c0\n2, . . . , c0\nk). Let b be an arbitrary tuple from {0, 1}k. Observe that\nif b ∈R, then minority(b, c0, c1) ∈R, since c0 ∈R and c1 ∈R.\nMoreover, if\nminority(b, c0, c1) ∈R, then minority(minority(b, c0, c1), c0, c1) = b ∈R. Thus, b ∈R\nif and only if minority(b, c0, c1) ∈R. Specializing this to b1 = 1, we obtain\n(b2, . . . , bk) ∈R1 ⇔(minority(b2, c0\n2, c1\n2), . . . , minority(bk, c0\nk, c1\nk)) ∈R0 .\nThis implies\n(b1, . . . , bk) ∈R ⇔(minority(b2, c0\n2b1, c1\n2b1), . . . , minority(bk, c0\nkb1, c1\nkb1)) ∈R0 .\nThus, R(x1, . . . , xk) is deﬁned by the formula\n∃x′\n2, . . . , x′\nk(φ0(x′\n2, . . . , x′\nk) ∧\n^\ni∈{2,...,k}\n(xi + c0\ni x1 + c1\ni x1 = x′\ni)) .\n□\nA binary relation is called bijunctive if it can be deﬁned by a propositional formula\nthat is a conjunction of clauses of size two (aka 2CNF formulas).\nTheorem 5.4.3 (of Post [176] and Schaefer [182]). Let B be a structure over a\ntwo-element universe. Then either ({0, 1}; NAE) has a primitive positive deﬁnition\nin B, and CSP(B) is NP-complete, or\n(1) B is preserved by a constant operation.\n(2) B is preserved by min. In this case, every relation of B has a deﬁnition by\na propositional Horn formula.\n(3) B is preserved by max. In this case, every relation of B has a deﬁnition\nby a dual-Horn formula, that is, by a propositional formula in CNF where\nevery clause contains at most one negative literal.\n(4) B is preserved by the majority operation. In this case, every relation of B\nis bijunctive.\n(5) B is preserved by the minority operation. In this case, every relation of B\ncan be deﬁned by a conjunction of linear equations modulo 2.\nIn case (1) to case (5), CSP(B) can be solved in polynomial time.\nProof. If the relation 1IN3 = {(0, 0, 1), (0, 1, 0), (1, 0, 0)} has a primitive positive\ndeﬁnition in B, then Lemma 1.2.6 shows that the NP-hard problem positive 1-in-3-\n3SAT [101] (see Example 1.2.2) can be reduced to CSP(B). In this case, also the\nrelation NAE is primitive positive deﬁnable in B, as we have seen in Example 1.2.7.\nIf 1IN3 is not primitive positive deﬁnable in B, then by Theorem 5.2.3 there is\na polymorphism f of B that violates 1IN3; let f be such an operation of minimal\narity. Because 1IN3 consists of three tuples only, Lemma 5.3.5 asserts that f is at\nmost ternary.\nIf f is not unary, then ˆf : {0, 1} →{0, 1} deﬁned by x 7→f(x, . . . , x) must preserve\n1IN3 by the choice of f. Hence, ˆf is the identity and f is idempotent. If f is binary,\nthen by Lemma 5.4.1 it is either min or max. In case that f is min, we show that all\nrelations in B can be deﬁned by propositional Horn formulas. It is well-known that\n\n5.4. SCHAEFER’S THEOREM\n103\npositive unit-resolution is a polynomial-time decision procedure for the satisﬁability\nproblem of propositional Horn-clauses [183]. The case that f is max is dual to this\ncase.\nSo let R be a Boolean relation preserved by min. Let φ be a propositional formula\nin CNF that deﬁnes φ. We can assume without loss of generality that for all literals\nin clauses of φ, when we remove this literal from the clause, the resulting formula is\nnot equivalent to φ. (Otherwise, we keep on removing literals until the formula has\nthe required property.) Now suppose for contradiction that φ contains a clause C\nwith two positive literals x and y. Since φ is reduced, there is an assignment s1 that\nsatisﬁes φ such that s1(x) = 1, and such that all other literals of C evaluate to 0.\nSimilarly, there is a satisfying assignment s2 for φ such that s2(y) = 1 and all other\nliteral s of C evaluate to 0. Then s0 : x 7→min(s1(x), s2(y)) does not satisfy C, and\ndoes not satisfy φ, in contradiction to the assumption that min preserves R.\nIf f is ternary, then f either generates the minority or the majority operation,\nby Lemma 5.4.1 and the choice of f. If f generates the majority operation, we show\nthat every relation of B is bijunctive. Hence, in this case CSP(B) is equivalent to\nthe 2SAT problem, and can be solved in linear time [7]. Let again φ be a reduced\ndeﬁnition of a relation from R, and suppose that φ contains a clause C with three\nliterals l1, l2, l3. Since φ is reduced, there must be satisfying assignments s1, s2, s3 to\nφ such that under si all literals of C evaluate to 0 except for li. Then the mapping\ns0 : x 7→majority(s1(x), s2(x), s3(x)) does not satisfy C and therefore does not satisfy\nφ, in contradiction to the assumption that majority preserves R.\nIf f generates the minority operation, and R is a relation of B, then by Theo-\nrem 5.4.2 the relation R has a deﬁnition by a conjunction of linear equalities modulo\n2. Then CSP(B) can be solved in polynomial time by Gaussian elimination.\nFinally, if f is unary, then f is either constant, and we are done, or f is the\noperation ¬ deﬁned by x 7→1−x. If f is ¬, then NAE consists of three orbits of triples.\nIf NAE is primitive positive deﬁnable in Φ, then CSP(B) is NP-hard by reduction\nfrom positive not-all-equal-3SAT [101] (see again Example 1.2.2).\nOtherwise, by\nLemma 5.3.5, there is an at most ternary operation g that violates NAE.\nSince\nall non-constant unary operations preserve NAE, we can assume that g is at least\nbinary.\nIf g is binary and violates NAE, then there are t1, t2 ∈NAE such that\nt0 = g(t1, t2) /∈NAE. For i ∈{1, 2}, if ti ∈1IN3, set αi to be id, otherwise set\nαi to be ¬, and note that αiti ∈1IN3.\nThen either h: (x, y) 7→g(α1x, α2y) or\nh: (x, y) 7→¬g(α1x, α2y) is idempotent and violates 1IN3, and the statement follows\nfrom the above proof when we take h ∈Pol(B) in place of f. The argument for\nternary g follows the same lines.\n□\nHard Boolean constraint languages can be characterized in many equivalent ways\nvia Corollary 5.3.4. To see this, we need the following proposition.\nProposition 5.4.4. Let B be a structure over a two-element universe. Then the\nfollowing are equivalent.\n(1) ({0, 1}; NAE) has a primitive positive deﬁnition in B.\n(2) B is neither preserved by min, max, minority, majority, nor the constant\noperations.\n(3) The polymorphism clone of B either contains only projections, or is gener-\nated by the unary operation x 7→−x.\n(4) In B every ﬁrst-order formula is equivalent to a primitive positive formula.\nProof. The implication from (1) to (2) follows from the fact that NAE is not pre-\nserved by min, max, minority, majority, and constant operations, which is straight-\nforward to verify.\nA proof that (2) implies (3) can for instance be found in [72]\n\n104\n5. UNIVERSAL ALGEBRA\n(Theorem 5.1). The implication from (3) to (4) follows from Corollary 5.3.4. For\nthe implication from (4) to (1), note that NAE is preserved by x 7→−x, and hence\npreserved by all automorphisms of B. In particular, NAE is ﬁrst-order deﬁnable in\nB. So (4) implies that NAE also has a primitive positive deﬁnition in B.\n□\n5.5. Pseudo-varieties and Primitive Positive Interpretations\nPrimitive positive deﬁnability is a strong tool to prove that certain CSPs are\nhard, but in some cases this tool is not strong enough. In this section we discuss the\nconcept of primitive positive interpretations, and the matching universal-algebraic\nconcept, which is the concept of pseudo-varieties.\n5.5.1. Algebras. Algebras have been deﬁned in Chapter 2: they are simply\nstructures with a purely functional signature. When A is an algebra with signature\nτ and domain A, we denote by Clo(A) the set of all functions with domain A of the\nform (x1, . . . , xn) 7→t(x1, . . . , xn) where t is any term over the signature τ whose set\nof variables is contained in {x1, . . . , xn}; clearly, Clo(A) is closed under compositions,\nand contains the projections, and therefore forms a clone. In this section we recall\nsome basic universal-algebraic facts that will be used in the following subsections.\nWhen K is a class of algebras of the same signature, then\n• P(K) denotes the class of all products of algebras from K.\n• Pﬁn(K) denotes the class of all ﬁnite products of algebras from K.\n• S(K) denotes the class of all subalgebras of algebras from K.\n• H(K) denotes the class of all homomorphic images of algebras from K.\n(Products, subalgebras, and homomorphic images have been deﬁned in Chapter 2.)\nNote that closure under homomorphic images implies in particular closure under\nisomorphism. For the operators P, Pﬁn, S and H we often omit the brackets when\napplying them to single algebras, i.e., we write H(A) instead of H({A}). The elements\nof HS(A) are also called the factors of A.\nA class V of algebras with the same signature τ is called a pseudo-variety if V\ncontains all homomorphic images, subalgebras, and direct products of algebras in\nV, i.e., H(V) = S(V) = Pﬁn(V). The class V is called a variety if V also contains\nall (ﬁnite and inﬁnite) products of algebras in V.\nSo the only diﬀerence between\npseudo-varieties and varieties is that pseudo-varieties need not be closed under direct\nproducts of inﬁnite cardinality. The smallest pseudo-variety (variety) that contains\nan algebra A is called the pseudo-variety (variety) generated by A.\nDefinition 5.5.1. Let B be a relational structure with domain B. An algebra\nwith domain B whose operations are exactly the polymorphisms of B is called a poly-\nmorphism algebra of B.\nNote that a relational structure can have many diﬀerent polymorphism algebras,\nsince Deﬁnition 5.5.1 does not prescribe how to assign function symbols to the poly-\nmorphisms of B. In our applications, the precise choice of the signature never plays\na role, and therefore we sometimes refer to the polymorphism algebra of B, and de-\nnote it by Alg(B). So statements about a polymorphism algebra of B (or about the\npolymorphism algebra Alg(B)) can typically be translated to statements that hold\nfor all polymorphism algebras of B (e.g. in Theorem 5.5.6 below).\nAlso note that when B is ω-categorical, then the signature of the polymorphism\nalgebra has cardinality 2ω. This follows directly from Theorem 7.3.2 and the remark\nafter Lemma 3.1.10.\n\n5.5. PSEUDO-VARIETIES AND PRIMITIVE POSITIVE INTERPRETATIONS\n105\nCongruences and Quotients. When µ: C →D is a map, then the kernel of\nµ is the equivalence relation E on C where (c, c′) ∈E if µ(c) = µ(c′). For c ∈C, we\ndenote by c/E the equivalence class of c in E, and by C/E the set of all equivalence\nclasses of elements of C. A congruence of an algebra A is an equivalence relation\nthat is preserved by all operations in A. The results in Section 5.2 show that for\nω-categorical structures B with polymorphism algebra B, the congruences of B are\nexactly the primitive positive deﬁnable equivalence relations over B.\nProposition 5.5.2 (see [68]). Let A be an algebra. Then E is a congruence of\nA if and only if E is the kernel of a homomorphism from A to some other algebra B.\nWhen K is a congruence of a τ-algebra A, then A/K denotes τ-algebra with\ndomain A/K where\nf A/K(a1/K, . . . , ak/K) = f A(a1, . . . , ak)/K\nwhere a1, . . . , ak ∈A and f ∈τ is k-ary. This is well-deﬁned since K is preserved by\nall operations of A. If K is the kernel of µ then we also write A/µ instead of A/K.\nThe following is well-known.\nLemma 5.5.3 (The Homomorphism Lemma). Let A be a τ-algebra, let K be a\ncongruence of A, and let µ1 : A →B1 and µ2 : A →B2 be two mappings with kernel\nK. Then A/µ1 is isomorphic to A/µ2.\nThe following is also well known (see e.g. Theorem 6.3 in [68]).\nLemma 5.5.4. Let A and B be algebras with the same signature, and let µ: A →\nB be a homomorphism. Then the image of any subalgebra A′ of A under µ is a\nsubalgebra of B, and the preimage of any subalgebra B′ of B under µ is a subalgebra\nof A.\nProof. Let f ∈τ be k-ary. Then for all a1, . . . , ak ∈A′,\nf B(µ(a1), . . . , µ(ak)) = µ(f A(a1, . . . , ak)) ∈h(A′) ,\nso µ(A′) is a subalgebra of C. Now suppose that µ(a1), . . . , µ(ak) are in B′; then\nf B(µ(a1), . . . , µ(ak)) ∈B′ and hence µ(f A(a1, . . . , ak)) ∈B′. So, f A(a1, . . . , ak)) ∈\nµ−1(B′) which shows that µ−1(B′) induces a subalgebra of A.\n□\n5.5.2. Primitive Positive Interpretations. In Chapter 3, we have seen that\nﬁrst-order interpretations are a convenient tool to construct ω-categorical structures\nfrom other ω-categorical structures. Primitive positive interpretations are interpreta-\ntions I where the domain formula δI and all the deﬁning formulas φI are primitive\npositive. As we will see, such interpretations can be used to study the computational\ncomplexity of constraint satisfaction problems.\nDefinition 5.5.5. Let I be an interpretation.\nIf the domain formula δI and\nthe interpreting formulas φI are primitive positive, then we say that I is a primitive\npositive interpretation.\nWe ﬁrst start with a result that is known for ﬁnite domain constraint satisfaction,\nalbeit not using the terminology of primitive positive interpretations [66].\nIn the\npresent form, it appears ﬁrst in [26].\nTheorem 5.5.6. Let B and C be structures with ﬁnite relational signatures. If\nthere is a primitive positive interpretation of B in C, then there is a polynomial-time\nreduction from CSP(B) to CSP(C).\n\n106\n5. UNIVERSAL ALGEBRA\nProof. Let d be the dimension of the primitive positive interpretation I of the\nτ-structure B in the σ-structure C, let δI(x1, . . . , xd) be the domain formula, let\nh: δI(Cd) →D(B) be the coordinate map, and let φI(x1, . . . , xdk) be the formula for\nthe k-ary relation R from B.\nLet φ be an instance of CSP(B) with variable set U = {x1, . . . , xn}. We construct\nan instance ψ of CSP(C) as follows. For distinct variables V := {y1\n1, . . . , yd\nn}, we set\nψ1 to be the formula\n^\n1≤i≤n\nδ(y1\ni , . . . , yd\ni ) .\nLet ψ2 be the conjunction of the formulas θI(y1\ni1, . . . , yd\ni1, . . . , y1\nik, . . . , yd\nik) over all\nconjuncts θ = R(xi1, . . . , xik) of φ. By moving existential quantiﬁers to the front, the\nsentence\n∃y1\n1, . . . , yd\nn (ψ1 ∧ψ2)\ncan be re-written to a primitive positive σ-formula ψ, and clearly ψ can be constructed\nin polynomial time in the size of A.\nWe claim that φ is true in B if and only ψ is true in C. Let C be the domain of\nC, B the domain of B, and suppose that f : U →C satisﬁes all conjuncts of ψ in C.\nHence, by construction of ψ, if φ has a conjunct θ = R(xi1, . . . , xik), then\nC |= θI((f(y1\ni1), . . . , f(yd\ni1)), . . . , (f(y1\nik), . . . , f(yd\nik))) .\nBy the deﬁnition of interpretations, this implies that\nB |= R(h(f(y1\ni1), . . . , f(yd\ni1)), . . . , h(f(y1\nik), . . . , f(yd\nik))) .\nHence, the mapping g: U →B that sends xi to h(f(y1\ni ), . . . , f(yd\ni )) satisﬁes all con-\njuncts of φ in B.\nNow, suppose that f : U →B satisﬁes all conjuncts of φ over B.\nSince h is\na surjective mapping from δ(Cd) to B, there are elements c1\ni , . . . , cd\ni in C such that\nh(c1\ni , . . . , cd\ni ) = f(xi), for all i ∈{1, . . . , n}. We claim that the mapping g: V →C\nthat maps yj\ni to cj\ni is a homomorphism from ψ to C. By construction, any constraint\nin ψ either comes from ψ1 or from ψ2. If it comes from ψ1 then it must be of the\nform δI(y1\ni , . . . , yd\ni ), and is satisﬁed since the pre-image of h is δI(Cd). If the constraint\ncomes from ψ2, then it must be a conjunct of a formula θI(y1\ni1, . . . , yd\ni1, . . . , y1\nik, . . . , yd\nik)\nthat was introduced for a constraint θ = R(xi1, . . . , xik) in A. It therefore suﬃces to\nshow that\nC |= θI(g(y1\ni1), . . . , g(yd\ni1), . . . , g(y1\nik), . . . , g(yd\nik)) .\nBy assumption, R(f(xi1), . . . , f(xik)) holds in B. By the choice of c1\n1, . . . , cd\nn, this\nshows that R(h(c1\ni1, . . . , cd\ni1), . . . , h(c1\nik, . . . , cd\nik)) holds in C. By the deﬁnition of in-\nterpretations, this is the case if and only if θI(c1\ni1, . . . , cd\n1, . . . , c1\nik, . . . , cd\nik) holds in C,\nwhich is what we had to show.\n□\nWe describe how to compose interpretations, and observe that compositions of\nprimitive positive interpretations are again primitive positive. Note that if C2 has a\nd1-dimensional interpretation I1 in C1, and C3 has an d2-dimensional interpretation\nI2 in C2, then C3 has a natural (d1d2)-dimensional interpretation in C1, which we\ndenote by I2 ◦I1. To formally describe I2 ◦I1, suppose that the signature of Ci is τi\nfor i = 1, 2, 3, and that I1 = (d1, S1, h1) and I2 = (d2, S2, h2). When φ is a τ2-formula,\nlet φI1 denote the τ1-formula obtained from φ by replacing each atomic τ2 formula ψ in\nφ by the τ1-formula ψI1. Note that when φ is primitive positive (existential positive),\n\n5.5. PSEUDO-VARIETIES AND PRIMITIVE POSITIVE INTERPRETATIONS\n107\nand the interpreting formulas of I1 are primitive positive (existential positive), then\nφI2 is again primitive positive (existential positive)4.\nNow the interpretation I2◦I1 is given by (d1d2, S, h) where S := (δI2)I1((C1)d1d2),\nand where the coordinate map h: S →C3 is deﬁned by\n(a1\n1, . . . , ad1\n1 , . . . , a1\nd2, . . . , ad1\nd2) 7→h2(h1(a1\n1, . . . , ad1\n1 ), . . . , h1(a1\nd2, . . . , ad1\nd2)) .\nObserve that when I1 and I2 are primitive positive interpretations, then I2 ◦I1 is also\nprimitive positive.\nIn many hardness proofs we use Theorem 5.5.6 in the following way.\nCorollary 5.5.7. Let B be an ω-categorical relational structure. If there is a\nprimitive positive interpretation of ({0, 1}; 1IN3) or ({0, 1}; NAE) in B, then B has\na reduct with ﬁnite signature whose CSP is NP-hard.\nProof. The primitive positive formulas involved in the primitive positive inter-\npretation can mention only ﬁnitely many relations from B. Let B′ be the reduct of\nB that contains exactly those relations. Then NP-hardness of CSP(B′) follows from\nthe NP-hardness of CSP(({0, 1}; 1IN3)) and CSP(({0, 1}; NAE)) (see Section 1.2 in\nChapter 1, Example 1.2.2) via Theorem 5.5.6.\n□\nWe present an application of Theorem 5.5.6 and prove a hardness result that\nbecomes useful at several occasions in later sections.\nDefinition 5.5.8. For any set B, we write IB\n6 for the relation\n\b\n(x1, x2, y1, y2, z1, z2) ∈B6 | (x1 = x2 ∧y1 ̸= y2 ∧z1 ̸= z2)\n∨(x1 ̸= x2 ∧y1 = y2 ∧z1 ̸= z2)\n∨(x1 ̸= x2 ∧y1 ̸= y2 ∧z1 = z2)\n\t\n.\nProposition 5.5.9. For any set B with |B| ≥2, the structure ({0, 1}; 1IN3) has\na primitive positive interpretation in (B; IB\n6 ), and CSP((B; IB\n6 )) is NP-hard.\nProof. Recall that 1IN3 denotes the boolean relation {(1, 0, 0), (0, 1, 0), (0, 0, 1)}.\nWe give a primitive positive interpretation I of the structure B := ({0, 1}; 1IN3) in\n(B; IB\n6 ). The dimension of I is 2, and the domain formula is δI := ⊤(for true).\nThe formula 1IN3(x1, x2, y1, y2, z1, z2)I is IB\n6 (x1, x2, y1, y2, z1, z2), and the formula\n=I (x1, x2, y1, y2) is\n∃a1, a2, u1, u2, u3, u4, z1, z2\n\u0000a1 = a2 ∧IB\n6 (a1, a2, u1, u2, u3, u4)\n∧IB\n6 (u1, u2, x1, x2, z1, z2) ∧IB\n6 (u3, u4, z1, z2, y1, y2)\n\u0001\n.\nNote that the primitive positive formula =I (x1, x2, y1, y2) is equivalent to x1 = x2 ⇔\ny1 = y2. The map h maps (b1, b2) ∈B2 to 1 if b1 = b2, and to 0 otherwise. NP-\nhardness of CSP((B; IB\n6 )) then follows from Corollary 5.5.7.\n□\nCorollary 5.5.10. Let B be an ω-categorical structure where all ﬁrst-order for-\nmulas are equivalent to primitive positive formulas (or that satisﬁes some of the other\nequivalent conditions from Corollary 5.3.4). Then there is a primitive positive in-\nterpretation of ({0, 1}; 1IN3) in B, and B has a ﬁnite signature reduct B′ such that\nCSP(B′) is NP-hard.\nProof. Since IB\n6 is ﬁrst-order deﬁnable, it also has a primitive positive deﬁnition\nin B by assumption. Proposition 5.5.9 implies that the structure ({0, 1}; 1IN3) has\na primitive positive interpretation in B. The last part of the statement follows from\nCorollary 5.5.7.\n□\n4Note that this is in general false for existential formulas: there are existential formulas φ and\nexistential interpretations I1 such that φI1 is no longer existential.\n\n108\n5. UNIVERSAL ALGEBRA\nIn fact, we could have weakened the assumptions in Corollary 5.5.10 by only re-\nquiring that all polymorphisms of B are essentially unary, and that all endomorphisms\nof B are injective, because it is then easy to see that the relation IB\n6 is preserved by all\npolymorphisms of B, and hence primitive positive deﬁnable in B, by Theorem 5.2.3.\nThere are many situations where Theorem 5.5.6 can be combined with Lemma 1.2.8\nto prove hardness of CSPs, as described in the following.\nProposition 5.5.11. Let A be a structure with ﬁnite relational signature, and let\nB be a structure with elements c1, . . . , ck such that\n• the orbit of (c1, . . . , ck) in B is primitive positive deﬁnable, and\n• A has a primitive positive interpretation in (B, c1, . . . , ck).\nThen there is a ﬁnite signature reduct B′ of B and a polynomial-time reduction from\nCSP(A) to CSP(B′).\nProof. Let C denote the expansion of B by the unary relations {c1}, . . . , {ck}.\nThen the interpretation of A in (B, c1, . . . , ck) shows that there is also a primitive\npositive interpretation of A in C, and this interpretation mentions only ﬁnitely many\nrelations of C. Let C′ be the ﬁnite signature reduct of C that contains exactly those\nrelations and the relations that are mentioned in the primitive positive deﬁnition of the\norbit of (c1, . . . , ck). Since C′ still interprets A, there is a polynomial-time reduction\nfrom CSP(A) to CSP(C′) by Theorem 5.5.6. Since there is still a primitive positive\ndeﬁnition of the orbit of (c1, . . . , ck) in C′, we can apply Corollary 3.6.25 and get a\npolynomial-time reduction from CSP(C′) to CSP(B′), where B′ is the reduct of B\nthat only contains the relations that are also in C′; note that B′ has ﬁnite signature.\nComposing reductions, we conclude that there is a polynomial-time reduction from\nCSP(A) to CSP(B′).\n□\nTogether with Corollary 3.6.25 we have the following consequence.\nCorollary 5.5.12. Let B be an ω-categorical model-complete core, and let A\nbe a structure with a ﬁnite signature and a hard CSP. If A has a primitive positive\ninterpretation with parameters in B, then B has a reduct with ﬁnite signature whose\nCSP is NP-hard.\nWe give an application of this technique in Proposition 5.5.13 below. Many more\napplications can be found in Section 9.2 and Section 10.2.3.\nWe have deﬁned in\nExample 1.1.3 the relation Betw on Z; we use the analogous deﬁnition for Betw over\nQ, that is,\nBetw := {(x, y, z) ∈Q3 | x < y < z ∨z < y < x} .\nProposition 5.5.13. The structure ({0, 1}; NAE) has a primitive positive inter-\npretation in (Q; Betw, 0), and CSP((Q; Betw)) is NP-hard.\nProof. Recall that the relation NAE is {0, 1}3 \\ {(0, 0, 0), (1, 1, 1)}. The dimen-\nsion of our interpretation I is one, and the domain formula is ∃z. Betw(x, 0, z), which\nis equivalent to x ̸= 0. The formula =I (x1, y1) is\n∃z\n\u0000Betw(x1, 0, z) ∧Betw(z, 0, y1)\n\u0001\n.\nNote that =I is over (Q; Betw, 0) equivalent to (x1 > 0 ⇔y1 > 0). Finally, the\nformula NAE(x1, y1, z1)I is\n∃u\n\u0000Betw(x1, u, y1) ∧Betw(u, 0, z1)\n\u0001\n.\nThe map h maps positive points to 1, and all other points from Q to 0.\nSince the orbit of 0 is the entire set Q it is in particular primitive positive deﬁnable,\nand we can show NP-hardness of CSP\n\u0000(Q; Betw)\n\u0001\nusing Proposition 5.5.11 and the\nfact that CSP\n\u0000({0, 1}; NAE)\n\u0001\nis NP-hard.\n□\n\n5.5. PSEUDO-VARIETIES AND PRIMITIVE POSITIVE INTERPRETATIONS\n109\n5.5.3. Pseudo-varieties. We present the mentioned connection between prim-\nitive positive interpretations and pseudo-varieties.\nTheorem 5.5.14 (from [26]). Let C be a ﬁnite or ω-categorical relational struc-\nture, and let C be a polymorphism algebra of C. Then a structure B has a primitive\npositive interpretation in C if and only if there is an algebra B in the pseudo-variety\ngenerated by C such that all operations of B are polymorphisms of B.\nProof. Let τ be the signature of C, and let V be the pseudo-variety generated\nby C. Similarly to the famous HSP theorem for varieties (see e.g. [68]), every algebra\nin V is the homomorphic image of a subalgebra of a ﬁnite direct product of C. To\nsee this, we have to verify that HSPﬁn(C) is closed under H, S, and Pﬁn.\nIt is\nclear that H(HSPﬁn(C)) = HSPﬁn(C). Lemma 5.5.4 implies that S(HSPﬁn(C)) ⊆\nHSSPﬁn(C) = HSPﬁn(C). Finally,\nPﬁn(HSPﬁn(C)) ⊆H Pﬁn S Pﬁn(C) ⊆HSPﬁn Pﬁn(C) = HSPﬁn(C) .\nFirst assume that there is an algebra B in V all of whose operations are polymor-\nphisms of B. Then there exists a ﬁnite number d ≥1, a subalgebra D of Cd, and a\nsurjective homomorphism h from D to B. We claim that B has a ﬁrst-order inter-\npretation I of dimension d in C. All operations of C preserve D (viewed as a d-ary\nrelation over C), since D is a subalgebra of Cd. By Theorem 5.2.3, this implies that\nD has a primitive positive deﬁnition δ(x1, . . . , xd) in C, which becomes the domain\nformula δI of I. As coordinate map we choose the mapping h.\nIf R is a k-ary relation in B, let R′ ⊆Cdk be deﬁned by\n(a1\n1, . . . , ad\n1, . . . , a1\nk, . . . , ad\nk) ∈R′ ⇔(h(a1\n1, . . . , ad\n1), . . . , h(a1\nk, . . . , ad\nk)) ∈R .\nLet f ∈τ be arbitrary. By assumption, f B preserves R. It is easy to verify that\nthen f C preserves R′. Hence, all polymorphisms of C preserve R′, and because C is\nω-categorical, the relation R′ has a primitive positive deﬁnition in C (Theorem 5.2.3),\nwhich becomes the deﬁning formula for R(x1, . . . , xk) in I. Finally, since h is an alge-\nbra homomorphism, the kernel K of h is a congruence of D. It follows that K, viewed\nas a 2d-ary relation over C, is preserved by all operations from C. Theorem 5.2.3\nimplies that K has a primitive positive deﬁnition in C. This deﬁnition becomes the\nformula =I. It is straightforward to verify that I is a primitive positive interpretation\nof B in C.\nTo prove the opposite direction, suppose that B has a primitive positive interpre-\ntation I in C. We have to show that V contains a τ-algebra B such that all operations\nin B are polymorphisms of B. Let d be the dimension and δ be the primitive positive\ndomain formula of I. Clearly, the set δ(Cd) is preserved by all operations in C, and\ntherefore induces a subalgebra D of Cd.\nWe ﬁrst show that the kernel K of the coordinate map h of the interpretation is a\ncongruence of D. For all d-tuples a, b ∈D, the 2d-tuple (a, b) satisﬁes =I in C if and\nonly if h(a) = h(b). Let S be the 2d-ary relation deﬁned by =I over C. Then S can be\nviewed as a binary relation over Cd, and we have S ∩D2 = K. Since =I is primitive\npositive deﬁnable in C, S is preserved by all polymorphisms of C. To show that K\nis a congruence of D, let f ∈τ be k-ary, and let (a1, b1), . . . , (ak, bk) be pairs from\nK. Let a = f D(a1, . . . , ak) and b = f D(b1, . . . , bk). We have to show that (a, b) ∈K.\nSince D is a subalgebra of Cd, a, b ∈D, and hence it suﬃces to show that (a, b) ∈S.\nRecall that f D is deﬁned by applying f C component-wise. Since (ai, bi) ∈S for all\ni ≤k and f C preserves S, we thus have that (a, b) ∈S. Hence, K is a congruence of\nD and h is a surjective homomorphism from D to B := D/h.\nWe ﬁnally verify that every operation in B is a polymorphism of B, i.e., for\nevery f ∈τ, every relation R of B is preserved by f B. The operation f B preserves\n\n110\n5. UNIVERSAL ALGEBRA\nφ := R(x1, . . . , xk) if and only if f C preserves φI. Since f C is a polymorphism of C,\nand since φI is primitive positive over C, the operation f C indeed preserves φI.\n□\nThe proof of Theorem 5.5.14 above gives more information about the link between\nthe algebras in HSPﬁn(Alg(B)) and the primitive positive interpretations in B, and\nwe state it explicitly.\nTheorem 5.5.15. Let C be a ﬁnite or ω-categorical structure, and let B be an\narbitrary structure. Then the following are equivalent.\n(1) there is a polymorphism algebra C of C, an algebra S ∈S(Cd) with domain\nS, and a surjective homomorphism h from S to an algebra B such that\nClo(B) ⊆Pol(B);\n(2) B has the primitive positive interpretation (d, S, h) in C.\nWe return to applications of these concepts to CSPs.\nCorollary 5.5.16. Let B be ω-categorical. If there is an expansion C of the\nmodel-complete core of B by ﬁnitely many constants such that the pseudo-variety V\ngenerated by Alg(C) contains a 2-element algebra where all operations are projections,\nthen B has a ﬁnite signature reduct with an NP-hard CSP.\nProof. Let D be the 2-element algebra in V where all operations are projections.\nAll operations of D preserve the relation 1IN3. By Theorem 5.5.14, the structure\n({0, 1}; 1IN3) has a primitive positive interpretation in C. Then Corollary 5.5.7 shows\nthat B has a ﬁnite signature reduct B′ with an NP-hard CSP.\n□\nAll templates B with a ﬁrst-order deﬁnition in a homogeneous structure with\nﬁnite relational signature known to the author that have an NP-complete CSP satisfy\nthe condition from Corollary 5.5.16. For ﬁnite templates B there is the conjecture\n(and strong evidence) that CSP(B) is NP-hard if and only if B satisﬁes this condition\n(see Section 5.6.1).\nTheorem 5.5.17. Let B be any structure. Then the following are equivalent.\n(1) there is a primitive positive interpretation of ({0, 1}; 1IN3) in B.\n(2) there is a primitive positive interpretation of ({0, 1}; NAE) in B;\n(3) B interprets a structure with at least two elements where all ﬁrst-order for-\nmulas are equivalent to primitive positive formulas;\n(4) all ﬁnite structures have a primitive positive interpretation in B.\nIf B is ω-categorical, the following two conditions are equivalent to the conditions\nabove.\n(5) the pseudo-variety V generated by Alg(B) contains for all n an algebra on\nn elements all of whose operations are projections;\n(6) the pseudo-variety V generated by Alg(B) contains a 2-element algebra all\nof whose operations are projections.\nProof. The ﬁrst statement can be shown by proving implications in cyclic order,\n(1) ⇒(2) ⇒(3) ⇒(4) ⇒(1). Obviously, (4) implies (1). We have given a primitive\npositive deﬁnition of NAE in ({0, 1}; 1IN3) in the proof of Theorem 5.4.3, which\nimplies that (1) implies (2). The implication from (2) to (3) is by Proposition 5.4.4.\nFor the implication (3) ⇒(4), let B′ be the structure that has a primitive positive\ninterpretation in B, has at least two elements, and where all ﬁrst-order formulas\nare equivalent to primitive positive formulas. Let A be a τ-structure with domain\n{1, . . . , n}. We prove that A has a ﬁrst-order interpretation in B′. This yields in fact\na primitive positive interpretation since every ﬁrst-order formula is equivalent to a\n\n5.5. PSEUDO-VARIETIES AND PRIMITIVE POSITIVE INTERPRETATIONS\n111\nprimitive positive formula in B′. The claim then follows by composing the primitive\npositive interpretation of B′ in B with that of A in B′.\nOur ﬁrst-order interpretation I of A in B′ is 2n-dimensional. The domain formula\nδI(x1, . . . , xn, x′\n1, . . . , x′\nn) expresses that for exactly one i ≤n we have xi = x′\ni; clearly\nthis is ﬁrst-order. Equality is interpreted by the formula\n=I (x1, . . . , xn, x′\n1, . . . , x′\nn, y1, . . . , yn, y′\n1, . . . , y′\nn) :=\nn\n^\ni=1\n\u0000(xi = x′\ni) ⇔(yi = y′\ni)\n\u0001\n.\nNote that the equivalence relation deﬁned by =I on δ((B′)2n) has exactly n equiva-\nlence classes, and the coordinate map sends (x1, . . . , xn, x′\n1, . . . , x′\nn) to i if and only if\nxi = x′\ni. It is now straightforward to write down ﬁrst-order formulas φI that interpret\natomic τ-formulas φ. When R ∈τ is k-ary, then the formula R(x1, . . . , xk)I is a dis-\njunction of conjunctions with the 2nk variables x1,1, . . . , xk,n, x′\n1,1, . . . , x′\nk,n. For each\ntuple (t1, . . . , tk) from RA the disjunction contains the conjunct V\ni≤k xi,ti = x′\ni,ti.\nNow suppose that B is ω-categorical. We prove that (4) implies (5), that (5)\nimplies (6), and that (6) implies (1). For (4) ⇒(5), let A be the structure with\ndomain A = {1, . . . , n}, the relations P A\n3 , and for each i ∈{1, . . . , n} the unary\nrelation {i}. By (4) there is a primitive positive interpretation of A in B. Hence,\nTheorem 5.5.14 implies that there is an algebra A′ ∈V such that all operations of\nA′ are polymorphisms of A.\nBut all polymorphisms of A are projections (Corol-\nlary 5.3.4). The implication (5) ⇒(6) is trivial. The implication (6) ⇒(1) follows\nfrom Theorem 5.5.14 and the fact that the projections preserve 1IN3.\n□\n5.5.4. Bi-interpretations and Classiﬁcation Transfer. Let C be a structure\nwith ﬁnite relational signature. By the classiﬁcation project for C we mean a com-\nplexity classiﬁcation for CSP(B) for all ﬁrst-order expansions B of C that have ﬁnite\nrelational signature. For instance, the classiﬁcation project for the random graph\n(V; E) is treated in Chapter 9, and the classiﬁcation project for (Q; <) is treated in\nChapter 10.\nSometimes, it is possible to derive the complexity classiﬁcation project for C from\nthe complexity classiﬁcation project for D, for another ω-categorical structure D. For\ninstance, we will show below how to derive the classiﬁcation project for the directed\ngraph\nC := (N2; {(x, y), (u, v) | y = u})\nfrom the classiﬁcation project for D := (N; =) (which will be given in Chapter 6);\na more advanced application of such a classiﬁcation transfer can be found in Theo-\nrem 5.5.23 below.\nPrimitive positive interpretability is a crucial concept for the transfer of complex-\nity classiﬁcations. In particular, this section studies primitive positive bi-interpretations\nin this context. Two interpretations of C in D with coordinate maps h1 and h2 are\ncalled homotopic5 if the relation {(¯x, ¯y) | h1(¯x) = h2(¯y)} is ﬁrst-order deﬁnable in\nD. If this relation is even primitive positive deﬁnable in D, we say that the two in-\nterpretations are pp-homotopic. The identity interpretation of a τ-structure C is the\ninterpretation I = (1, true, h) of C in C whose coordinate map h is the identity (note\nthat the identity interpretation is primitive positive). Recall that we write I1 ◦I2 for\nthe natural composition of two interpretations I1 and I2, deﬁned in Section 5.5.2.\nDefinition 5.5.18. Two structures C and D with an interpretation I of C in D\nand an interpretation J of C in D are called mutually interpretable. If both I ◦J and\n5We are following the terminology from [3].\n\n112\n5. UNIVERSAL ALGEBRA\nJ ◦I are homotopic to the identity interpretation (of D and of C, respectively), then\nwe say that C and D are bi-interpretable.\nWhen both interpretations I and J are primitive positive, then C and D are called\nmutually pp-interpretable. If moreover I◦J and J ◦I are pp-homotopic to the identity\ninterpretation, then C and D are called primitive positive bi-interpretable.\nExample 5.5.19. The directed graph C := (N2; M) where\nM :=\n\b\n((u1, u2), (v1, v2)) | u2 = v1\n\t\nand the structure D := (N; =) are primitive positive bi-interpretable. The interpre-\ntation I of C in D is 2-dimensional, the domain formula is true, and the coordinate\nmap h is the identity. The interpretation J of D in C is 1-dimensional, the domain\nformula is true, and the coordinate map g sends (x, y) to x. Both interpretations are\nclearly primitive positive.\nThen g(h(x, y)) = z is deﬁnable by the formula x = z, and hence I ◦J is pp-\nhomotopic to the identity interpretation of D. Moreover, h(g(u), g(v)) = w is primi-\ntive positive deﬁnable by\nM(w, v) ∧∃p (M(p, u) ∧M(p, w)) ,\nso J ◦I is also pp-homotopic to the identity interpretation of C.\n□\nExample 5.5.20. The structures C :=\n\u0000N2; {(x, y), (u, v) | x = u}\n\u0001\nand D :=\n(N; =) are mutually primitive positive interpretable, but not primitive positive bi-\ninterpretable. There is a primitive positive interpretation I1 of D in C, and a primitive\npositive interpretation of C in D such that I2 ◦I1 is pp-homotopic to the identity\ninterpretation. However, the two structures are not even ﬁrst-order bi-interpretable,\nas we will see in Example 7.4.2 in Section 7.4.\n□\nHere comes the central lemma for complexity classiﬁcation transfer.\nLemma 5.5.21. Suppose D has a primitive positive interpretation I in C, and C\nhas a primitive positive interpretation J in D such that J ◦I is pp-homotopic to the\nidentity interpretation of C. Then for every ﬁrst-order expansion C′ of C there is a\nﬁrst-order expansion D′ of D such that C′ and D′ are mutually pp-interpretable.\nProof. Let I = (c, U, g) and J = (d, V, h) be the primitive positive interpreta-\ntions from the statement, and let C′ be a ﬁrst-order expansion of C. Then we set D′\nto be the expansion of D that contains for every k-ary R in the signature of C′ the\n(dk)-ary relation S deﬁned as follows. When φ is the ﬁrst-order deﬁnition of R in C,\nthen S is the relation deﬁned by φJ in D (see Section 3.1 and Section 5.5.2).\nWe claim that C′ has the primitive positive interpretation (d, V, h) in D′. First\nnote that V is primitive positive deﬁnable in D′ since D′ is an expansion of D.\nAn atomic formula ψ with free variables x1, . . . , xk in the signature of C′ can be\ninterpreted in D′ as follows. We replace the relation symbol in ψ by its deﬁnition in\nC, and obtain a formula φ in the language of C. Let S be the symbol in the language\nof D′ for the relation deﬁned by φJ(x1\n1, . . . , xd\n1, . . . , x1\nk, . . . , xd\nk) over D′. Then indeed\nS(x1\n1, . . . , xd\n1, . . . , x1\nk, . . . , xd\nk) is a deﬁning formula for ψ, because\nC′ |= ψ(h(a1\n1, . . . , ad\n1), . . . , h(a1\nk, . . . , ad\nk)) ⇔D′ |= S(a1\n1, . . . , ad\n1, . . . , a1\nk, . . . , ad\nk)\nfor all a1, . . . , ak ∈V .\nConversely, we claim that D′ has the primitive positive interpretation (c, U, g)\nin C′.\nAgain, U is primitive positive deﬁnable in C′ since C′ is an expansion of\nC.\nLet φ be an atomic formula in the (relational) signature of D′.\nIf the rela-\ntion symbol in φ is already in the signature of D, then there is a primitive posi-\ntive interpreting formula in C and therefore also in C′. Otherwise, by deﬁnition of\n\n5.5. PSEUDO-VARIETIES AND PRIMITIVE POSITIVE INTERPRETATIONS\n113\nD′, the relation symbol in φ has arity dk, and has been introduced for a k-ary re-\nlation R from C′.\nWe have to ﬁnd a deﬁning formula having kcd variables.\nLet\nθ(x0, x1,1, . . . , x1,c, . . . , xd,1, . . . , xc,d) be the primitive positive formula of arity cd + 1\nthat shows that h(g(x1,1, . . . , xc,1), . . . , g(x1,d, . . . , xc,d)) = x0 is primitive positive de-\nﬁnable in C. Then the deﬁning formula for the atomic formula φ(x1\n1, . . . , xk\nd) has free\nvariables x1\n1,1, . . . , xk\nc,d and equals\n∃x1, . . . , xk \u0000R(x1, . . . , xk) ∧\nk^\ni=1\nθ(xi, xi\n1,1, . . . , xi\nc,d)\n\u0001\n.\n□\nIn particular, when C, D, C′ and D′ are as in Lemma 5.5.21, and C′ and D′ have a\nﬁnite relational signature, then CSP(C′) and CSP(D′) have the same computational\ncomplexity, by Theorem 5.5.6. Hence, Lemma 5.5.21 shows that the classiﬁcation\nproject for C can be reduced to the classiﬁcation project for D.\nWith a slightly\nstronger assumption we can get the following consequence.\nCorollary 5.5.22. Let C and D be primitive positive bi-interpretable ω-categorical\nstructures. Then every ﬁrst-order expansion of C is primitive positive bi-interpretable\nwith a ﬁrst-order expansion of D.\nMore about ﬁrst-order bi-interpretability can be found in Section 7.4. Let us\nconclude with a concrete application of Corollary 5.5.22.\nTheorem 5.5.23. Let B be a reduct of Allen’s interval algebra (Example 3.1.11)\nthat contains the relation m =\n\b\n((u1, u2), (v1, v2)) | u2 = v1\n\t\n. Then CSP(B) is either\nin P or NP-complete.\nProof. We show that the structure (I; m) is primitive positive bi-interpretable\nwith (Q; <). It follows that B is primitive positive bi-interpretable with a temporal\nconstraint language B′, and the result follows by the main result of Chapter 10 and\nCorollary 5.5.22.\nLet I be the 2-dimensional interpretation of (I; m) in (Q; <) with domain formula\nx < y, the formula (y1 = y2)I is true, and the formula (m(y1, y2))I has variables\nx1\n1, x1\n2, x2\n1, x2\n2 and is given by x1\n2 = x2\n1. The coordinate map g sends (x, y) ∈Q2 with\nx < y to the interval [x, y] ∈I.\nLet J be the 1-dimensional interpretation with domain formula true, and where\nthe coordinate map h is [x, y] 7→x. The formula (x < y)I is the primitive positive\nformula\n∃u, v\n\u0000m(u, x1) ∧m(u, v) ∧m(v, x2)\n\u0001\n.\nWe show that J ◦I and J ◦I are pp-homotopic to the identity interpretation. The\nrelation\n\b\n(x1, x2, y) | h(g(x1, x2)) = y\n\t\nhas the primitive positive deﬁnition x1 = y.\nTo see that the relation R :=\n\b\n(u, v, w) | g(h(u), h(v)) = w\n\t\nhas a primitive positive\ndeﬁnition in (I; m), ﬁrst note that the relation\n\b\n(u, v) | u = [u1, u2], v = [v1, v2], u1 = v1\n\t\nhas the primitive positive deﬁnition φ1(u, v) = ∃w\n\u0000m(w, u1) ∧m(w, u2)\n\u0001\nin (I; m).\nSimilarly, {(u, v) | u = [u1, u2], v = [v1, v2], u2 = v2} has a primitive positive deﬁnition\nφ2(u, v). Then the formula φ1(u, w) ∧φ2(v, w) is equivalent to a primitive positive\nformula over (I; m), and deﬁnes R.\n□\n\n114\n5. UNIVERSAL ALGEBRA\n5.6. Varieties\nVarieties (which we have introduced brieﬂy in Section 5.5) are a fascinatingly\npowerful concept to study classes of algebras. For a ﬁnite structure B with ﬁnite\nsignature, the complexity of CSP(B) only depends on the variety generated by the\npolymorphism algebra of B. This is in particular related to the fact that a ﬁnite\nalgebra is in the variety generated by a ﬁnite algebra B if and only if it is in the\npseudo-variety generated by B; the link between the pseudo-variety generated by B\nand the CSP has already been explained in Section 5.5.\nThe section has two parts. In Section 5.6.1 we explain the role of varieties for\nthe study of CSPs with ﬁnite templates. In particular, we present various equivalent\nforms of the tractability conjecture for ﬁnite domain constraint satisfaction.\nThe second part studies the situation for ω-categorical templates.\nIt is open\nwhether the complexity of an ω-categorical model-complete core only depends on\nthe variety generated by the polymorphism algebra of B. But it will turn out that\nthe tractability frontier in the classiﬁcation results in Chapter 9 and Chapter 10\ncan be described elegantly using varieties, and the description is very similar to the\ntractability conjecture for ﬁnite domain constraint satisfaction. In Section 5.6.2 we\nprovide some partial explanation for this phenomenon.\n5.6.1. The Tractability Conjecture. In this section, we present some clas-\nsical results that speciﬁcally hold for ﬁnite algebras and are relevant to constraint\nsatisfaction. We also discuss more recent universal-algebraic results about ﬁnite alge-\nbras. We cannot cover all recent developments here, but sketch in this section some\nof the highlights.\nWe have already mentioned in the introduction the dichotomy conjecture of Feder\nand Vardi [95], which we state here since it is one of the central stimulating conjectures\nfor ﬁnite domain constraint satisfaction.\nConjecture 5.1 (Dichotomy Conjecture [95]). Let B be a structure with ﬁnite\nrelational signature and ﬁnite domain. Then CSP(B) is in P or NP-complete.\nWe will now see a stronger conjecture, due to [65, 66], that exactly describes\nwhich ﬁnite-domain CSPs are NP-hard, and which can be solved in polynomial time.\nThis conjecture is called the tractability conjecture, and it has been conﬁrmed in many\nimportant cases, for example for\n• ﬁnite structures B that contain a unary relation symbol for each subset of\nthe domain of B, due to [61] (see also [11]),\n• structures over a 3-element domain [63], and\n• digraphs without sources and sinks [15], and which includes the case of\nundirected graphs.\nThe tractability conjecture can be formulated in terms of primitive positive in-\nterpretability (Section 5.5) as follows.\nConjecture 5.2 (Tractability Conjecture). Let B be a ﬁnite structure with ﬁnite\nrelational signature, and let C be the core of B. Then CSP(B) is NP-hard if there is\na primitive positive interpretation of ({0, 1}; 1IN3) with parameters in C, and can be\nsolved in polynomial-time otherwise.\nWe remark that the ﬁrst part of this conjecture follows directly from Corol-\nlary 5.5.12. Moreover, we have also seen that CSP(B) is polynomial-time equivalent\nto CSP(C), so all that remains to be shown is to prove polynomial-time tractability of\nCSP(C) when C does not admit a primitive positive interpretation of a hard Boolean\n\n5.6. VARIETIES\n115\nCSP. By the results in Section 5.5, this condition can be translated into a condition\nof the pseudo-variety generated by the polymorphism algebra C of C.\nWhen B is a ﬁnite algebra, it turns out that a ﬁnitely generated algebra (and in\nparticular a ﬁnite algebra) A is in the pseudo-variety generated by B if and only if\nA is in the variety generated by B (see [68]; the claim follows from Exercise 11.5 in\ncombination with the proof of Lemma 11.8 there). Varieties have the advantage that\nthey can be described by the equations satisﬁed by its members.\nTheorem 5.6.1 (Birkhoﬀ; see e.g. [119] or [68]). Let τ be a functional signature,\nA a τ-algebra, and C be a class of τ-algebras. Then the following are equivalent.\n• All universal conjunctive sentences that hold in all members of C also hold\nin A.\n• A is in the variety generated by C.\n• A ∈HSP(C).\nTheorem 5.6.1 is important for constraint satisfaction since it can be used to\ntransform the ‘negative’ statement of not interpreting certain hard boolean CSPs\ninto a ‘positive’ statement of having polymorphisms satisfying non-trivial identities.\nThe following theorem is an application of this philosophy, and goes back to Walter\nTaylor (Corollary 5.3 in [192]; see also Lemma 9.4 in [118]).\nTheorem 5.6.2. Let B be a ﬁnite structure, and suppose that the polymorphism\nalgebra B of B is idempotent. Then the following are equivalent.\n• ({0, 1}; 1IN3) does not have a primitive positive interpretation in B.\n• every 2-element algebra in the pseudo-variety generated by B contains an\nessential operation.\n• every 2-element algebra in HSP(B) contains an essential operation.\n• B has a Taylor term, that is, an n-ary operation, for n ≥2, such that for\nevery 1 ≤i ≤n there are x1, . . . , xn, y1, . . . , yn ∈{x, y} such that (B; f)\nsatisﬁes\n∀x, y. f(x1, . . . , xi−1, x, xi+1, . . . , xn)\n=f(y1, . . . , yi−1, y, yi+1, . . . , yn) .\nThe equations satisﬁed by Taylor terms are a special form of a linear equation,\nthat is, an equation of the form\n∀x1, . . . , xn. f(u1, . . . , un) = f(v1, . . . , vn)\nwhere u1, . . . , un, v1, . . . , vn ∈{x1, . . . , xn}.\nEven though Theorem 5.6.2 is of central importance in universal algebra, it was\ndiscovered only recently and under the inﬂuence of work in the context of constraint\nsatisfaction that the existence of Taylor terms is equivalent to the existence of various\nother terms satisfying stronger conditions, which are likely to be of greater use in the\nquest for polynomial-time algorithms for CSPs.\nTheorem 5.6.3 (of [14, 187]). Let B be a ﬁnite idempotent algebra. Then the\nfollowing are equivalent.\n• B has a Taylor term.\n• B has a weak near unanimity, that is, an n-ary idempotent operation f, for\nn ≥2, that satisﬁes\n∀x, y. f(x, . . . , x, y) = f(x, . . . , x, y, x) = · · · = f(y, x, . . . , x) .\n\n116\n5. UNIVERSAL ALGEBRA\n• B has a Siggers term6, that is, a four-ary operation f that satisﬁes\n∀x, y. f(y, y, x, x) = f(x, x, x, y) = f(y, x, y, x) .\n• B has a cyclic term, i.e., an n-ary operation f, for n ≥2, that satisﬁes\n∀x1, . . . , xn. f(x1, . . . , xn) = f(x2, . . . , xn, x1) .\nNote that weak near unanimities, Siggers terms and cyclic terms are (special)\nTaylor terms, and that cyclic terms are (special) weak near unanimities. Also note\nthat the existence of a Siggers term can be decided (for an explicitly given ﬁnite\nidempotent algebra B), and hence the condition of the tractability conjecture for\nﬁnite domain constraint satisfaction is decidable. We would also like to remark that\nbinary commutative operations, that is, operations f satisfying f(x, y) = f(y, x), are\nTaylor terms, and that Conjecture 5.2 is already open in this special case.\nAnother improvement of Theorem 5.6.2 is the following result from [65] (Propo-\nsition 4.14).\nTheorem 5.6.4 (of [65]). Let B be a ﬁnite idempotent algebra. Then HSP(B)\ncontains an algebra without essential operations if and only if HS(B) does.\nSince all algebras in HS(B) are smaller than B (or isomorphic to B), this leads to\nanother algorithm that decides whether a given structure B satisﬁes the equivalent\nconditions in Theorem 5.6.2 (besides the approach via searching for Siggers terms\nmentioned above).\n5.6.2. Canonical Clones. We cannot oﬀer an full analog of Theorem 5.6.2 for\nω-categorical structures B. This section treats the special case where the polymor-\nphism algebra of an ω-categorical structure B resembles a ﬁnite algebra in a certain\nformal sense; in this case, an analog of Theorem 5.6.2 can be transferred from the\nﬁnite.\nLet B be a structure. Then f : Bk →B is called m-canonical (with respect to\nB) if for all m-tuples t1, . . . , tk, the m-type of f(t1, . . . , tk) in B only depends on the\nm-types of t1, . . . , tk in B. It is called canonical if it is m-canonical for all ﬁnite m.\nA clone (or an algebra) is called canonical if all its operations are canonical (this is\nstill with respect to some base structure B).\nLemma 5.6.5. Let B be a structure with a ﬁnite number q of m-types, and let B be\nan algebra with signature τ such that all operations of B are m-canonical with respect\nto B. Then there exists a τ-algebra A of size q and a surjective homomorphism µ\nfrom Bm to A.\nProof. Let p1, . . . , pq be the m-types of B.\nDeﬁne µ: Bm →{1, . . . , q} by\ng(b1, . . . , bm) = i if (b1, . . . , bm) has type pi. Since the operations of B are m-canonical,\nthe kernel of µ is a congruence K of Bm. Then A := Bm/K satisﬁes the requirements\nof the statement.\n□\nThe algebra A constructed from B in the proof of the previous lemma will be\ncalled the type algebra of B, denoted by Tm(B).\nLemma 5.6.6. Let B be an ω-categorical model-complete core, and suppose that\nall operations of the polymorphism algebra B of B are m-canonical with respect to B.\nThen Tm(B) is idempotent.\n6Originally, Siggers gave equations for a six-ary operation, using the universal-algebraic formu-\nlation from [62] of the dichotomy theorem for the CSPs for undirected graphs H from [113]. This\nwas later improved by an anonymous referee of [187] to the given identities for a 4-ary operation,\nusing the main result from [15]; see concluding comments in [187].\n\n5.6. VARIETIES\n117\nProof. When B is an ω-categorical model-complete core, then all orbits of m-\ntuples in B are preserved by the endomorphisms of B. It follows that every operation\nf of Tm(B) satisﬁes ∀x. f(x, . . . , x) = x.\n□\nNote that if B is homogeneous in a relational signature with maximal arity m\n(or ﬁrst-order interdeﬁnable with such a structure), then being m-canonical implies\nbeing n-canonical for all n ≥m. In this case, we simply write T(B) instead of Tm(B).\nWe say that an operation f : Bn →B is cyclic modulo e1, e2 : B →B if\n∀x1, . . . , xn. e1(f(x1, . . . , xn)) = e2(f(x2, . . . , xn, x1)) .\nSimilarly, we say that f : Bn →B is a weak near unanimity modulo e1, . . . , en : B →B\nif the following is satisﬁed.\n∀¯x. e1(f(x, . . . , x, y)) = e2(f(x, . . . , y, x)) = · · · = en(f(y, x, . . . , x))\nThe same deﬁnition can be made for any type of equation, and we therefore also deﬁne\nTaylor operations modulo unary operations and Siggers polymorphisms modulo unary\noperations analogously.\nThe idea of the following lemma comes from the proof of Proposition 6.6 in\nBodirsky, Pinsker, and Pongracz [53], and has been used in [36].\nLemma 5.6.7. Let B be ω-categorical, and f ∈Pol(B). Suppose that for every\nﬁnite A ⊂B there exists an α ∈Aut(B) such that f(x1, . . . , xn) = αf(x2, . . . , xn, x1)\nfor all x1, . . . , xn ∈A. Then B has a cyclic polymorphism modulo endomorphisms.\nThe analogous statement holds linear equations modulo unary operations in general.\nProof. We show that there are e1, e2 ∈Aut(B) such that e1(f(x1, . . . , xn)) =\ne2(f(x2, . . . , xn, x1)) for all x1, . . . , xn from the domain B of B. Construct a rooted\ntree as follows.\nEach vertex of the tree lies on some level n ∈N.\nLet d1, d2, . . .\nbe an enumeration of B. Let Fn be the set of partial isomorphisms of B with do-\nmain Dn := {d1, . . . , dn}, and deﬁne the equivalence relation ∼on F 2\nn as follows:\n(α1, α2) ∼(β1, β2) if there exists a δ ∈Aut(B) such that αi = δ ◦βi for i ∈{1, 2}.\nNote that for each n, the relation ∼has ﬁnitely many equivalence classes on F 2\nn, by\nthe ω-categoricity of B and Theorem 3.1.4. The vertices of the tree on level n are\nprecisely the equivalence classes E of ∼on F 2\nn such that for all (α1, α2) ∈E and\nx1, . . . , xn ∈B satisfying {f(x1, . . . , xn), f(x2, . . . , xn, x1)} ⊆Dn := {d1, . . . , dn} we\nhave α1(f(x1, . . . , xn)) = α2(f(x2, . . . , xn, x1)).\nThe equivalence class of the partial map with the empty domain D0 becomes the\nroot of the tree, on level n = 0. We deﬁne adjacency in the tree by restriction as\nfollows: when E is a vertex on level n, and E′ a vertex on level n + 1, and E contains\n(α1, α2) and E′ contains (α′\n1, α′\n2) such that α1 = α′\n1 ↾Dn and α2 = α′\n2 ↾Dn, then we\nmake E and E′ adjacent in the tree. Note that the resulting rooted tree is ﬁnitely\nbranching. By assumption, the tree has vertices on all levels. Hence, by K¨onig’s tree\nlemma, there exists an inﬁnite path E0, E1, E2, . . . in the tree, where Ei is from level\ni ∈N.\nWe deﬁne e1, e2 ∈Aut(B) as follows. Suppose e1, e2 are already deﬁned on Dn\nsuch that α1 := e1 ↾Dn, α2 := e2 ↾Dn, and (α1, α2) ∈En. We want to deﬁne e1 and\ne2 on dn+1, and we will do it in such a way that (e1 ↾Dn+1, e2 ↾Dn+1) ∈En+1. Since\nEn and En+1 are adjacent, there exist (β1, β2) ∈En and (β′\n1, β′\n2) ∈En+1 such that\nβ1 = β′\n1 ↾Dn and β2 = β′\n2 ↾Dn. By the deﬁnition of ∼there exists a δ ∈Aut(B)\nsuch that α1 = δ ◦β1 and α2 = δ ◦β2. For j ∈{1, 2}, deﬁne α′\nj := δ ◦β′\nj so that\n(α′\n1, α′\n2) ∈En+1 and observe that\nα′\nj ↾Dn:= (δ ◦β′\nj) ↾Dn= δ ◦βj = αj ,\n\n118\n5. UNIVERSAL ALGEBRA\nand hence that α′\nj extends αj. Deﬁne ej(dn+1) := α′\nj(dn+1). The proof for general\nlinear equations modulo unary operations is analogous.\n□\nCorollary 5.6.8. Let C be a structure which is homogeneous in a ﬁnite relational\nlanguage, and let B be a model-complete core which is ﬁrst-order interdeﬁnable with\nC such that all the operations of the polymorphism algebra B of B are canonical with\nrespect to B. Then the following are equivalent:\n(1) The type algebra T(B) contains a cyclic operation;\n(2) B has a cyclic polymorphism modulo endomorphisms;\n(3) B has a weak near unanimity polymorphism modulo endomorphisms;\n(4) B has a Siggers polymorphism modulo endomorphisms.\nProof. Let m be the maximal arity of τ. By Lemma 5.6.6 the ﬁnite algebra\nT(B) is idempotent. Hence, by Theorem 5.6.3 it has a cyclic operation if and only if\nit has a weak near unanimity operation if and only if it has a Siggers operation.\nSuppose now that B has a cyclic polymorphism gB modulo endomorphisms eB\n1\nand eB\n2 . Let µ be the homomorphism from B to T(B). , eT (B)\n1\n= eT (B)\n2\nmust be the\nidentity, and gT (B) is a cyclic operation. Hence, 2 implies 1. Analogously one can\nshow that 3 implies 1 and that 4 implies 1.\nConversely, suppose that T(B) has an n-ary cyclic operation f T (B). We claim\nthat f B satisﬁes the assumptions of Lemma 5.6.7. To show this, it suﬃces to prove\nthat for all ﬁnite m and all b1, . . . , bm ∈Bn, the m-tuples (f B(b1), . . . , f B(bm)) and\n(f B(b1\n2, . . . , b1\nn, b1\n1), . . . , f B(bm\n2 , . . . , bm\nn , bm\n1 )) lie in the same orbit of C. Indeed, we\nhave\ntpC(f B(b1), . . . , f B(bm)) = f T (B)(tp(b1\n1, . . . , bm\n1 ), . . . , tp(b1\nn, . . . , bm\nn ))\n= f T (B)(tp(b1\n2, . . . , bm\n2 ), . . . , tp(b1\nn, . . . , bm\nn ), tp(b1\n1, . . . , bm\n1 ))\n= tp(f B(b1\n2, . . . , b1\nn, b1\n1), . . . , f B(bm\n2 , . . . , bm\nn , bm\n1 ))\nLemma 5.6.7 shows the existence of a cyclic polymorphism modulo endomorphisms of\nB. Analogously one can show the existence of weak near unanimity polymorphisms\nand Siggers polymorphisms modulo endomorphisms.\n□\nAnother important consequence of Lemma 5.6.7 is that the existence of cyclic\npolymorphisms modulo endomorphisms of an ω-categorical model-complete core is\ninherited by expansions by constants. I am thankful to Trung Van Pham for com-\nmunicating the proof of the following proposition to me which strengthens a weaker\nstatement in earlier versions of this text.\nProposition 5.6.9. Let B be an ω-categorical model-complete core. If B has an\nn-ary cyclic polymorphism modulo endomorphisms, then the expansion of B by ﬁnitely\nmany constants also has an n-ary cyclic polymorphism modulo endomorphisms. Anal-\nogous statements hold for weak near unanimity operations modulo unary operations,\nand other operations satisfying linear equations modulo unary operations.\nProof. By the assumption there exist f ∈Pol(B) of arity k and e1, e2 ∈End(B)\nsuch that e1(f(x1, x2, . . . , xk)) = e2(f(x2, x3, . . . , xk, x1)) for all x1, . . . , xn from the\ndomain B of B. Let ˆf : B →B be given by ˆf(x) := f(x, x, . . . , x) for all x ∈B.\nClearly, ˆf is an endomorphism of B. Let a = (a1, . . . , an) ∈Bn be an arbitrary tuple\nof n constants. Then a, ˆf(a), and e1( ˆf(a)) = e2( ˆf(a)) lie in the same orbit of Aut(B)\nbecause B is a model-complete core. Let α, β ∈Aut(B) be such that αe1( ˆf(a)) = a\nand β( ˆf(a)) = a. Let h1 := αe1β−1 and h2 := αe2β−1, and g := βf. Clearly, we\n\n5.6. VARIETIES\n119\nhave g(a, . . . , a) = β ˆf(a) = a by the choice of β. We will show that h1(a) = a and\nh2(a) = a. We have\nh1(a) = h1(g(a, . . . , a)) = αe1β−1(βf(a, . . . , a)) = αe1( ˆf(a)) = a .\nSimilarly one can show that h2(a) = a. It follows that h1, h2 ∈End(B, a1, a2, . . . , an)\nand that g ∈Pol(B, a1, a2, . . . , an). Moreover, for all x1, x2, . . . , xk ∈B we have that\nh1(g(x1, x2, . . . , xk)) = αe1β−1(βf(x1, x2, . . . , xk))\n= αe1(f(x1, . . . , xk))\n= αe2(f(x2, . . . , xk, x1))\n= αe2β−1(βf(x2, . . . , xk, x1))\n= h2(g(x2, x3, . . . , xk, x1)) .\nThis shows that (B, a1, . . . , an) has a cyclic polymorphism modulo endomorphisms.\nThe proof for other linear equations modulo endomorphisms is analogous.\n□\nHow strong is the assumption that every operation of an oligomorphic clone is\ncanonical with respect to some homogeneous structure C over a ﬁnite relational sig-\nnature? In Chapter 8, we see that under fairly general Ramsey-theoretic assumptions\non C we can ﬁnd canonical operations in a natural way. Indeed, it turns out that\nwhen B is ﬁrst-order deﬁnable over the random graph (V; E) and does not primi-\ntively positively interpret ({0, 1}; 1IN3), then B is the reduct of a structure where all\npolymorphisms are canonical, and which still does not primitively positively interpret\n({0, 1}; 1IN3) (Theorem 9.8.3). The same statement is not true when we replace the\nrandom graph by (Q; <). However, we make the following general conjecture.\nConjecture 5.3. Let B be a countable ω-categorical model-complete core. Then\neither B interprets all ﬁnite structures primitively positively with parameters, or B\nhas a k-ary weak near unanimity operation modulo endomorphisms.\nThis conjecture has been conﬁrmed for all B that have a ﬁrst-order deﬁnition\nover (Q; <), and for all B that are deﬁnable over the random graph.\nLet us remark that in order to ‘prevent’ primitive positive interpretations of all\nﬁnite structures, it suﬃces to have a Taylor term f modulo unary operations applied\nto the arguments of f and to the function value of f, in the following sense.\nProposition 5.6.10. Let B be an ω-categorical structure whose polymorphism\nalgebra B contains an n-ary f and unary a0, . . . , an, b0, . . . , bn such that for all i ≤n\nthere are x1, . . . , xn, y1, . . . , yn ∈{x, y} such that B satisﬁes\n∀¯x. a0(f(a1(x1), . . . , ai−1(xi−1), ai(x), ai+1(xi+1), . . . , an(xn)))\n= b0(f(b1(y1), . . . , bi−1(yi−1), bi(y), bi+1(yi+1), . . . , bn(yn))) .\n(8)\nThen there is no primitive positive interpretation of ({0, 1}; 1IN3) in B.\nProof. Suppose that ({0, 1}; 1IN3) had a primitive positive interpretation in\nB. Then by Theorem 5.5.17 there is a 2-element algebra A in the pseudo-variety\ngenerated by B all of whose operations are projections. The algebra A is in particular\nin the variety generated by B, and satisﬁes (8). Since the unary function symbols of\nB must denote the identity in A, and A has more than one element, the i-th equation\nprevents that f is the i-th projection. Because we have such an equation for each\nargument of f, the operation f cannot be a projection.\n□\nIn particular, if B is a structure with a weak near unanimity polymorphism\nmodulo endomorphisms, then ({0, 1}; 1IN3) is not primitively positively interpretable\nin B. Using Proposition 5.6.9, we even get the following.\n\n120\n5. UNIVERSAL ALGEBRA\nCorollary 5.6.11. The two cases in Conjecture 5.3 are indeed disjoint: every\nω-categorical model-complete core with a weak near unanimity polymorphism modulo\nendomorphisms does not interpret ({0, 1}; 1IN3) primitively positively with parame-\nters.\n\nCHAPTER 6\nEquality Constraint Satisfaction Problems\nJan K´ara, 2005\nThis section is about structures with a ﬁrst-order deﬁnition in (N; =); such struc-\ntures will be called equality constraint languages. From a model-theoretic perspective,\nequality constraint languages appear to be trivial altogether. However, the set of all\nsuch structures, taken up to primitive positive interdeﬁnability and ordered by inclu-\nsion, is a quite complicated object (there are actually 2ω many equality constraint\nlanguages that pairwise do not deﬁne each other primitively positively [30]).\nBy the results of Section 3.3, a structure B is isomorphic to an equality constraint\nlanguage if and only if B is preserved by all permutations of its domain. Therefore,\nthis chapter is about locally closed clones that contain all permutations of the domain.\nOn a ﬁnite domain, such clones have been completely described in [110]; it turns out\nthat the number of clones that contain all permutations of a ﬁxed ﬁnite domain\nis ﬁnite.\nClones on inﬁnite sets that contain all permutations are of independent\ninterest in universal algebra [112,152,173,174]. Local closure is a strong additional\nassumption, which allows a good understanding of the lattice of all locally closed\nclones that contain all permutations [30].\nThe CSP for a ﬁnite equality constraint language is called an equality constraint\nsatisfaction problem. Equality CSPs are of fundamental importance in inﬁnite domain\nconstraint satisfaction; we mention some reasons.\n• NP-hard equality relations are very good candidates for establishing hard-\nness results of other inﬁnite domain CSPs. For instance, it follows from the\nresults presented in this section that every structure which admits a primi-\ntive positive deﬁnition of the relation {(x, y, z) | (x = y ̸= z) ∨(x ̸= y = z)}\nhas an NP-hard CSP.\n121\n\n122\n6. EQUALITY CONSTRAINT SATISFACTION PROBLEMS\n• When analyzing an ω-categorical structure B with the universal-algebraic\napproach, the question which equality constraint languages can be deﬁned in\nB is of crucial importance, as we will see for instance in Chapter 9 and 10.\nFor example, if the relation {(x, y, u, v) | x = y ⇔u = v} is primitive\npositive deﬁnable in B, then every polymorphism of B that depends on all\nits arguments must be injective (Proposition 6.1.4).\n• Suppose we want to classify the computational complexity of CSP(B) when\nB has a ﬁrst-order deﬁnition in a ﬁxed inﬁnite structure C; examples of such\nclassiﬁcations will be given in Chapter 9 and 10. Then such a classiﬁcation\nincludes the classiﬁcation of equality constraint satisfaction problems.\nThe complexity of equality CSPs has been completely classiﬁed [40]; those prob-\nlems are in P or NP-hard. In this chapter we present a new proof of this result, and\nshow that either the template B has a binary injective polymorphism, in which case\nB has a quantiﬁer-free Horn deﬁnition in (N; =), and CSP(B) is in P, or ({0, 1}; NAE)\nhas a primitive positive interpretation in B, and CSP(B) is NP-complete. The new\nproof has the advantage that it divides the argument into several steps that each\nholds for a much larger class of structures. Indeed, several results of this chapter turn\nout to be useful in later classiﬁcation arguments, in particular in Chapter 9.\nWe would also like to mention that the fact that satisﬁability of quantiﬁer-free\nHorn clauses over (N; =) can be decided in polynomial time has already been observed\nin [129]. Here, we derive the algorithm from more general principles that will also be\nimportant for our algorithmic results in Chapter 9 and Chapter 10.\n6.1. Independence of Disequality\nThe importance of independence in constraint satisfaction has been recognized\nseveral times; the ﬁrst appearance of this concept in the literature seems to be\nin [148], and, subsequently, in [149]. In this thesis, we focus on independence of\ndisequality, which found most applications; the general deﬁnition of independence has\nbeen worked out in [76]. Applications of this concept have been studied in metric\ntemporal reasoning [126,138] and qualitative reasoning cacluli [59,60]; also see [37].\nDefinition 6.1.1 (Independence of Disequality). Let B be a structure with re-\nlational signature τ. Then we say that ̸= is independent from B if for all primitive\npositive τ-formula φ, if both φ ∧x ̸= y and φ ∧u ̸= v are satisﬁable over B, then\nφ ∧x ̸= y ∧u ̸= v is satisﬁable over B as well.\nIn this section we prove that for many ω-categorical structures independence of\ndisequality is equivalent to the existence of a binary injective polymorphism. The\nfollowing deﬁnition comes from [40].\nDefinition 6.1.2. A relation R ⊆Bk is called intersection-closed if for all k-\ntuples (u1, . . . , uk), (v1, . . . , vk) ∈R there is a tuple (w1, . . . , wk) ∈R such that for all\n1 ≤i, j ≤k we have wi ̸= wj whenever ui ̸= uj or vi ̸= vj.\nLemma 6.1.3. Let B be an ω-categorical structure where ̸= has an primitive\npositive deﬁnition. Then the following are equivalent.\n(1) Disequality is independent from B.\n(2) Every ﬁnite induced substructure of B2 admits an injective homomorphism\ninto B.\n(3) B has a binary injective polymorphism.\n(4) All primitive positive deﬁnable relations in B are intersection-closed.\nProof. Throughout the proof, let b1, b2, . . . be an enumeration of the domain\nB of B. If f is a binary injective polymorphism of B, then clearly every relation\n\n6.1. INDEPENDENCE OF DISEQUALITY\n123\nin B is intersection-closed, so (3) implies (4).\nThe implication from (4) to (1) is\nstraightforward as well.\nWe now show the implication from (1) to (2). Let A be a ﬁnite induced substruc-\nture of B2. Then the domain of A is contained in {b1, . . . , bn}2, for suﬃciently large\nn. It clearly suﬃces to show that the structure induced by {b1, . . . , bn}2 in B2 ho-\nmomorphically and injectively maps to B, so let us assume without loss of generality\nthat the domain of A is {b1, . . . , bn}2.\nConsider the formula φ whose variables x1, . . . , xn2 are the elements of A,\nx1 := (b1, b1), . . . , xn := (b1, bn), . . . , xn2−n+1 := (bn, b1), . . . , xn2 := (bn, bn) ,\nand which is the conjunction over all literals R((bi1, bj1), . . . , (bik, bjk)) such that\nR(bi1, . . . , bik) and R(bj1, . . . , bjk) hold in B. So φ states precisely which relations\nhold in A.\nUsing induction over the number m of disequalities, we will now show that for any\nconjunction σ := V\n1≤k≤m xik ̸= xjk with the property that ik ̸= jk for all 1 ≤k ≤m,\nthe formula φ ∧σ is satisﬁable over B. This implies that there exists an n2-tuple t in\nB with pairwise distinct entries which satisﬁes φ; the assignment that sends every xi\nto ti is an injective homomorphism from A into B.\nFor the induction beginning, let xi ̸= xj be any disequality.\nLet r, s be the\nn2-tuples deﬁned as follows.\nr := (b1, . . . , b1, b2, . . . , b2, . . . , bn, . . . , bn)\ns := (b1, b2, . . . , bn, b1, b2, . . . , bn, . . . , b1, b2, . . . , bn).\nThese two tuples satisfy φ, because the projections to the ﬁrst and second coordinate,\nrespectively, are homomorphisms from A to B. Now either r or s satisﬁes xi ̸= xj,\nproving that φ ∧xi ̸= xj is satisﬁable in B.\nIn the induction step, let a conjunction σ := V\nk∈{1,...,m} xik ̸= xjk be given,\nwhere m ≥2. Set σ′ := V\n3≤k≤m xik ̸= xjk, and φ′ := φ ∧σ′. Observe that φ′ has\na primitive positive deﬁnition in B, as φ and ̸= have such deﬁnitions. By induction\nhypothesis, both φ′ ∧xi1 ̸= xj1 and φ′ ∧xi2 ̸= xj2 are satisﬁable in B. But then\nφ′ ∧xi1 ̸= xj1 ∧xi2 ̸= xj2, which is equivalent to φ ∧σ, is satisﬁable over B as well\nby (1), concluding the proof.\nThe implication from (2) to (3) follows from Lemma 3.1.8, because the property\nthat a function is injective can be described by the universal ﬁrst-order sentence\n∀¯x, ¯y\n\u0000¯x ̸= ¯y ⇒f(¯x) ̸= f(¯y)\n\u0001\n.\n□\nAlso the situation that the polymorphisms f of an ω-categorical structure are\n‘essentially injective’ can be characterized using equality relations.\nProposition 6.1.4. Let f be an operation from Bk to B that depends on all\narguments. Then the following is equivalent.\n(1) f is injective.\n(2) f preserves the relation deﬁned by x = y ⇔u = v.\n(3) f preserves the relation deﬁned by x = y ⇒u = v.\nProof. For the implication from (1) to (2), suppose that f is injective.\nWe\ncheck that f preserves x = y ⇔u = v. Let a, b, c, d be elements of Bk such that\nai = bi ⇔ci = di for all i ≤k, and let t be the tuple (f(a), f(b), f(c), f(d)). If\na = b, we thus have that ci = di for all i ≤k, and so c = d. In this case, t satisﬁes\nt1 = t2 and t3 = t4, and we are done. Similarly, if c = d then a = b and we are done.\nOtherwise, a ̸= b and c ̸= d, and by injectivity of f we have t1 ̸= t2 and t3 ̸= t4. So\nwe have in all cases that t1 = t2 if and only if t3 = t4.\n\n124\n6. EQUALITY CONSTRAINT SATISFACTION PROBLEMS\nFor the implication from (2) to (3), note that x = y ⇒u = v is equivalent to a\nprimitive positive formula over (B; R) where R = {(a, b, c, d) | a = b ⇔c = d}). The\nprimitive positive formula is\n∃w (R(x, y, u, w) ∧R(x, y, w, v)) .\nFinally, for the implication from (3) to (1), suppose that there are distinct a, b ∈\nBk such that f(a) = f(b). We want to prove that f violates x = y ⇒u = v. Let\nI be the set of all i ∈{1, . . . , k} such that ai ̸= bi. Since a and b are distinct, I is\nnon-empty; let i ∈I be arbitrary. Since f depends on the i-th argument, there are\nc, d ∈Dk with cj = dj for all j ̸= i, and ci ̸= di. We claim that (a, b, c, d) shows that\nf violates x = y ⇒u = v. First, note that for all j ∈{1, . . . , k} \\ I, we have that\naj = bj and cj = dj. Next, note that for all j ∈I we have that aj ̸= bj. We conclude\nthat for all j ∈{1, . . . , k} we have that ai = bi implies ci = di. However, f(a) = f(b)\nand f(c) ̸= f(d).\n□\nWe close with an application to CSPs. When A is an instance of CSP(B), then\nan injective homomorphism from A to B is also called an injective solution for A.\nProposition 6.1.5. Suppose that B has a binary injective polymorphism h. Then\nevery satisﬁable instance A of CSP(B) either has an injective solution, or A has two\ndistinct elements a, a′ such that s(a) = s(a′) in all solutions s for A.\nProof. Suppose that A has a solution, but no injective solution. Let f be a\nsolution such that the cardinality of f is maximal. Since there is no injective solution,\nthere are two elements a, a′ of A such that f(a) = f(a′). We claim that s(a) = s(a′)\nin all solutions s of A. Otherwise, if s(a) ̸= s(a′) for some solution s, then by the\nchoice of f there must be another pair b, b′ such that s(b) ̸= s(b′) but f(b) ̸= f(b′).\nThen the mapping x 7→h(f(x), s(x)) is also a solution to A, but has a strictly larger\nimage than f, a contradiction.\n□\n6.2. Two-transitive Templates\nWe show that two-transitive structures (in particular, equality constraint lan-\nguages) with essential but without constant polymorphisms also have binary injective\npolymorphisms. Here we use Corollary 5.3.11 about existence of binary essential poly-\nmorphisms, and Lemma 6.1.3 about the existence of binary injective polymorphisms.\nTheorem 6.2.1. Let B be a two-transitive structure without a constant polymor-\nphism, but with an essential polymorphism. Then B has a binary injective polymor-\nphism.\nProof. Corollary 5.3.11 implies that B is preserved by a binary essential opera-\ntion f. Since B has no constant polymorphism and is 2-set transitive, Corollary 5.3.8\nimplies that all polymorphisms of B preserve ̸=, and hence ̸= is primitive positive\ndeﬁnable in B. So we can apply Lemma 6.1.3, and have to show that for every prim-\nitive positive formula φ the formula φ ∧x ̸= y ∧u ̸= v is satisﬁable over B whenever\nφ ∧x ̸= y and φ ∧u ̸= v are satisﬁable over B.\nLet V be the variables of φ, and let s: V →B be a satisfying assignment for\nφ ∧x ̸= y, and t: V →B be a satisfying assignment for φ ∧u ̸= v. We can assume\nthat s(u) = s(v) and t(x) = t(y), otherwise we are done. Let k be the cardinality of\nthe set {s(x), s(y), s(u), t(u), t(v), t(x)}; note that 4 ≤k ≤6. Suppose that k = 6, the\nother cases are simpler. Since f is essential, it violates the relation P B\n3 (Lemma 5.3.2).\nSince f preserves ̸=, we can therefore assume that there are tuples (a, a, b) for\na ̸= b and (c, d, d) for c ̸= d such that f(a, c) ̸= f(a, d) and f(a, d) ̸= f(b, d). By 2-\ntransitivity of Aut(B), there are α, β ∈Aut(B) such that α(s(u), s(x)) = (a, b), and\n\n6.3. HORN FORMULAS\n125\nβ(t(u), t(x)) = (c, d). Since s(x) ̸= s(y) and t(v) ̸= t(u), and f preserves ̸=, we have\nf(α(s(x)), β(t(v))) ̸= f(α(s(y)), β(t(u))).\nThis implies that f(α(s(x)), β(t(v))) =\nf(α(s(y)), β(t(v))) and f(α(s(y)), β(t(v))) = f(α(s(y)), β(t(u))) cannot both be true.\nBy 2-transitivity of Aut(B), there exist α′, β′ such that α′(a, α(u)) = (α(u), a), and\nβ′(d, β(v)) = (β(v), d).\nIf f(α(s(x)), β(t(v))) ̸= f(α(s(y)), β(t(v))), then z 7→f(αs(z), β′t(z)) is a satis-\nfying assignment for φ ∧x ̸= y ∧u ̸= v. If f(α(s(y)), β(t(v))) ̸= f(α(s(y)), β(t(u))),\nthen z 7→f(α′s(z), βt(z)) is a satisfying assignment for φ ∧x ̸= y ∧u ̸= v.\n□\n6.3. Horn Formulas\nIn this section we show that B has certain binary injective polymorphisms if and\nonly if all relations in B have a quantiﬁer-free Horn deﬁnition over a ‘base’ structure\nC; this will often be useful to design algorithms for CSP(B).\nThe structure (N; =) has quantiﬁer-elimination: this follows from Lemma 3.6.1\nby the observation that every bijection between ﬁnite subsets of N can be extended to\na permutation of N. So we could have deﬁned equality constraint languages as those\nrelational structures where all relations have a quantiﬁer-free deﬁnition in (N; =).\nNote that not all equality constraint languages have quantiﬁer-elimination; however,\nall equality constraint languages are model-complete.\nProposition 6.3.1. Every equality constraint language B is model-complete.\nProof. The permutations of N locally generate all injective self-maps on N.\nHence, the statement follows from Theorem 3.6.7 by the observation that the embed-\ndings of B are locally generated by automorphisms of B.\n□\nThe following is a simple, but very useful deﬁnition to prove syntactic results.\nDefinition 6.3.2 (as in [30]). A quantiﬁer-free ﬁrst-order formula φ in conjunc-\ntive normal form is called reduced (over a structure B) if every formula obtained\nfrom φ by removing a literal or a clause is not equivalent to φ (over B).\nClearly, every quantiﬁer-free formula is equivalent to a reduced formula over B,\nbecause we can ﬁnd one by successively removing literals and clauses from φ. The\nfollowing theorem is from [29] and [35] (stated there for quantiﬁer-free Horn formulas\nonly).\nTheorem 6.3.3. Let B be a structure with an embedding e from B2 into B.\nThen a relation R with a quantiﬁer-free deﬁnition in B has a quantiﬁer-free Horn\ndeﬁnition in B if and only if R is preserved by e.\nProof. (Backwards.) Let δ be a quantiﬁer-free Horn deﬁnition of R over B,\nwritten in prenex conjunctive normal form. It suﬃces to demonstrate that e preserves\neach clause in δ. Note that a Horn clause ψ of δ can always be written in the form\n(φ1 ∧· · · ∧φl) →φ0, for atomic τ-formulas φ0, . . . , φl. Let V be the variables of ψ,\nand let s1, s2 : V →N be two assignments that satisfy the clause. We claim that\ns3 : V →N deﬁned by s3(x, y) = e(s1(x), s2(y)) satisﬁes ψ. There are two cases cases\nto consider. Either there is an i ≤l such that s1 or s2 does not satisfy φi. In this\ncase, since e is an embedding from B2 to B, s3 does not satisfy φi, and therefore\nsatisﬁes ψ. Or, if for all i ≤l both s1 and s2 satisfy φi, then they also satisfy φ0.\nSince e is a polymorphism of B, it follows that s3 satisﬁes φ0, and therefore also ψ.\n(Forwards.)\nConsider a quantiﬁer-free deﬁnition δ of R in B such that δ is\nin prenex normal form, and that the quantiﬁer-free part η of δ is a reduced CNF\nformula over B. Assume for contradiction that δ is not Horn, that is, η has a clause\nψ = φ1 ∨φ2 ∨φ3 ∨· · · ∨φl where φ1, φ2 are positive literals, and φ3, . . . , φl are\n\n126\n6. EQUALITY CONSTRAINT SATISFACTION PROBLEMS\npositive or negative literals.\nLet V be the variables of η.\nSince η is reduced, it\nhas a satisfying assignment s1 : V →N such that φi is false for all i ≤l except for\ni = 1; otherwise, we could remove φi from ψ and would obtain a formula that is\nequivalent to η over B, contradicting the assumption that η is reduced. Similarly, η\nhas a satisfying assignment s2 : V →N such that φi is false for all i ≤l except for\ni = 2. Then s3 : V →N deﬁned by s3(x, y) = e(s1(x), s2(y)) does not satisfy ψ, a\ncontradiction.\n□\nThe structure B := (N; =) is an obvious example with an embedding from B2\ninto B. When B is a relational structure, then B¬ denotes the expansion of B by all\nrelations that are the complement of a relation from B. The following is from [29]\n(note that we de not assume ω-categoricity of B and C).\nTheorem 6.3.4. Let C be a structure with an embedding e from C2 into C. Let\nB be a relational structure with ﬁnite signature σ that is preserved by e and has a\nquantiﬁer-free deﬁnition in C. Then there is a polynomial-time Turing reduction from\nCSP(B) to CSP(C¬).\n// Input: An instance φ of CSP(B)\n// Assumption: B has a quantiﬁer-free Horn deﬁnition in a τ-structure C.\nReplace each constraint R(x1, . . . , xn) from φ by δ(x1, . . . , xn),\nwhere δ is a quantiﬁer-free Horn deﬁnition of R in C.\nLet ψ be the resulting τ-sentence, written in prenex conjunctive normal form.\nRepeat := true\nWhile Repeat = true do\nRepeat := false\nLet Ψ be the set of all singleton clauses in ψ.\nIf Ψ is unsatisﬁable over C then reject.\nFor each negative literal η of ψ do\nIf Ψ ∪η, considered as an instance of CSP(C¬), is unsatisﬁable\nRemove η from its clause in ψ\nRepeat := true\nEnd for\nLoop\nAccept\nFigure 6.1. A polynomial-time Turing reduction from CSP(B) to\nCSP(C¬) when B has a polymorphism that is an embedding of C2\ninto C.\nProof. We use the algorithm shown in Figure 6.1, which is due to [76]. By\nTheorem 6.3.3, every relation of B has a quantiﬁer-free Horn deﬁnition in C. Let\nφ be an input instance of CSP(B), and let ψ be the sentence in the language of C\nobtained from φ as described in the algorithm. Since σ is ﬁnite and ﬁxed, and does\nnot depend on the input, there is only a linear number of literals that can be deleted\nfrom ψ in the course of the algorithm. It is thus clear that the algorithm works in\npolynomial time.\nTo show that the algorithm is correct, observe that φ is false in B if and only if\nψ is false in C. We ﬁrst show that if the algorithm rejects, then ψ is false in B. The\nreason is that whenever a negative literal η is removed from a clause of ψ, then in\nfact ¬η is implied by the other clauses in ψ, and therefore removing η from ψ leads\nto an equivalent formula.\n\n6.4. CLASSIFICATION\n127\nFinally, we show that if the algorithm accepts, then ψ is true in C. Let B be the\ndomain of B and C, and let V be the set of variables of ψ. Consider the negative\nliterals η1, . . . , ηm that are in clauses of ψ at the ﬁnal stage of the algorithm. For all\ni ≤m, let ti : V →B be an assignment that satisﬁes all clauses of ψ without negative\nliterals, and which also satisﬁes ηi. Such an assignment must exist, since otherwise ηi\nwould have been false in all solutions, and our algorithm would have removed ηi in\nthe inner loop of the algorithm. We claim that s: V →B given by\ns(x) = e(t1(x), e(t2(x), . . . e(tm−1(x), tm(x)) . . . ))\nsatisﬁes all clauses of ψ. Negative literals ηk are satisﬁed because tk satisﬁes ηk, and\ne is an embedding of C2 into C. Positive literals from ψ are satisﬁed by s because\nthey are satisﬁed by all the ti, and since e is a polymorphism of C.\n□\n6.4. Classiﬁcation\nWe now ﬁnish the complexity classiﬁcation for CSP(B) where B is an equality\nconstraint language, combining the results from the previous sections of this chapter.\nCorollary 6.4.1. Let B be an equality constraint language. Then one of the\nfollowing cases applies.\n(1) B has a constant polymorphism.\n(2) B has a binary injective polymorphism.\n(3) In B every ﬁrst-order formula is equivalent to a primitive positive formula.\nProof. Suppose that B does not have a constant polymorphism. Since equality\nconstraint languages have 2-transitive automorphism groups, we can use the contra-\npositive of Corollary 5.3.8 to derive that all polymorphisms of B must preserve ̸=.\nThe endomorphisms of B are therefore injective, and locally generated by the auto-\nmorphisms of B. If B does not have essential polymorphisms, then Corollary 5.3.4\nshows that all relations that are ﬁrst-order deﬁnable in B are also primitive positive\ndeﬁnable in B, and we are in case (3). If B has an essential polymorphism, then B\nhas a binary injective polymorphism by Theorem 6.2.1.\n□\nWe can now give the complexity classiﬁcation for equality constraint languages,\nwhich conﬁrms Conjecture 5.3 in a special case.\nTheorem 6.4.2. Let B be an equality constraint language. Then exactly one of\nthe following cases applies.\n• B has a polymorphism f and an automorphism α such that\nf(x, y) = αf(y, x)\nfor all elements x and y of B. In this case, for every ﬁnite reduct B′ of B\nthe problem CSP(B′) can be solved in polynomial time.\n• There is a primitive positive interpretation of ({0, 1}; 1IN3) in B. In this\ncase, there is a ﬁnite reduct B′ of B such that CSP(B′) is NP-complete.\nProof. By Proposition 5.6.10, the two cases are disjoint. If B has a constant\npolymorphism, then clearly there are f and α such that f(x, y) = αf(y, x) for all\nx, y ∈B. The claim for ﬁnite reducts of B follows from Proposition 1.1.11.\nNow suppose that B has a binary injective polymorphism f. Such an operation\nis an isomorphism between (N; =)2 and (N; =), and we can ﬁnd a permutation α of\nB such that f(x, y) = αf(y, x) for all x, y ∈N.\nSince every relation of B has a\nquantiﬁer-free deﬁnition over (N; =), Theorem 6.3.3 shows that every relation of B\neven has a quantiﬁer-free Horn deﬁnition over B. By Theorem 6.3.4, the CSP for every\nﬁnite signature reduct of B can be reduced to CSP((N; =, ̸=)) in polynomial time.\n\n128\n6. EQUALITY CONSTRAINT SATISFACTION PROBLEMS\nTractability of CSP((N; =, ̸=)) has been shown in Section 1.1. By Corollary 6.4.1, the\nonly remaining case is that over B all ﬁrst-order formulas are equivalent to primitive\npositive formulas. In this case the claim follows from Corollary 5.5.10.\n□\n\nCHAPTER 7\nTopology\nSeveral important properties of ω-categorical structures only depend on their\nautomorphism group considered as a topological group, that is, on their automorphism\ngroup viewed as an abstract group, with the topology of pointwise convergence on\nthe group elements. This is in particular the case for certain Ramsey properties that\nbecome important in the next chapter. We therefore give a self-contained introduction\nto basic topological background, with a focus on the topics that become relevant for\nour applications to automorphism groups of ω-categorical structures.\n7.1. Topological Spaces\nA topological space is a set S together with a collection of subsets of S, called the\nopen sets of S, such that\n(1) the empty set and S are open;\n(2) arbitrary unions of open sets are open;\n(3) the intersection of two open sets is open.\nComplements of open sets are called closed. For E ⊆S, the closure of E is the set of\nall points x such that every open set in S that contains x also contains a point from\n129\n\n130\n7. TOPOLOGY\nE. Clearly, the closure of E is a closed set. A subset E of S is called dense (in S)\nif its closure is the full space S. The subspace of S induced on E is the topological\nspace on E where the open sets are exactly the intersections of E with the open sets\nof S.\nDefinition 7.1.1. A mapping between two topological spaces is called continuous\nif the pre-images of open sets are open, and open if images of open sets are open. A\nbijective open and continuous map is called a homeomorphism.\nA basis of S is a collection of open subsets of S such that every open set in S\nis the union of sets from the collection. For s ∈S, a collection of open subsets of\nS is called a basis at s if each set from the collection contains s, and every open set\ncontaining s also contains an open set from the collection. For a sequence (sn)n≥1 of\nelements of S, we write limn→∞sn = s, and say that sn converges (against the limit\ns) if for every open set U of S that contains s there exists an n0 such that sn ∈U for\nall n ≥n0. A topological space S is called\n• discrete if every subset of S is open (and hence also closed);\n• compact if for an arbitrary collection {Ui}i∈A of open subsets of S with\nS = S\ni∈A Ui there is a ﬁnite subset B of A such that S = S\ni∈B Ui;\n• Hausdorﬀif for any two distinct points u, v of S there are disjoint open sets\nU and V that contain u and v, respectively;\n• ﬁrst-countable if for all s ∈S there exists a countable basis at s.\n• separable if there is a countable dense set;\nThe following equivalent characterization of continuity of maps from a ﬁrst-\ncountable space S to a topological space T is often easier to work with. For x ∈S,\nwe say that f is continuous at x if for every open V ⊆T containing f(x) there is an\nopen U ⊆S containing x whose image f(U) is contained in V .\nProposition 7.1.2. Let S be a ﬁrst-countable and T an arbitrary topological\nspace. Then for every f : S →T the following are equivalent.\n(1) f is continuous.\n(2) For all sn, if limn→∞sn = s then limn→∞f(sn) = f(s).\n(3) f is continuous at every x ∈S.\nProof. The implication from (1) to (2) is true even without the assumption that\nS is ﬁrst-countable. Let (sn)n≥1 be such that limn→∞sn = s, and let V be open so\nthat f(s) ∈V . Then U := f −1(V ) is open, and s ∈U. So there exists an n with\nsn ∈U. For this n, f(sn) ∈V . So limn→∞f(sn) = f(s).\nFor the implication from (2) to (3), we show the contraposition. Suppose that f is\nnot continuous at some s ∈S. That is, there exists an open set V containing f(s) such\nthat all open sets U that contain x have an image that is not contained in V . Since S is\nﬁrst-countable, there exists a countable collection Un of open sets containing x so that\nany open V that contains x also contains some Un. Replacing Un by ∩n\nk=1Uk where\nnecessary, we may assume that U1 ⊃U2 ⊃· · · . If Un ⊆f −1(V ), then f(Un) ⊆V , in\ncontradiction to our assumption; so we can pick an xn ∈Un \\ f −1(V ) for all n, and\nobtain a sequence that converges to x. But sn /∈f −1(V ) for all n, and so f(sn) does\nnot converge to f(s) ∈V .\nFinally, the implication from (3) to (1) again holds in arbitrary topological spaces.\nLet V ⊆T be open. We want to show that U := f −1(V ) is empty. When s is a point\nfrom U, then because f is continuous at s, and V contains f(s) and is open, there\nis an open set Us ⊆S containing s whose image f(Us) is contained in V .\nThen\nS\ns∈U Us = U is open as a union of open sets.\n□\n\n7.2. TOPOLOGICAL GROUPS\n131\nImportant examples of topologies come from metric spaces. A sequence (sn)n∈N\nof elements of a metric space (S; d) is called a Cauchy sequence if for every ϵ > 0 there\nis an n0 ∈N such that for all n, m > n0 we have that d(sn, sm) < ϵ. A topological\nspace S is called\n• metrizable if there exists a metric d on S which is compatible, i.e., the open\nsets are unions of sets of the form {y ∈S | d(c, y) ≤r}, for x ∈S, 0 ≤r ∈R;\n• completely metrizable if it has a compatible complete metric d, i.e., a metric\nd on S where every Cauchy sequence converges against an element of S;\n• Polish if S is separable and completely metrizable.\nThe product Q\ni∈I Si of a family of topological spaces (Si)i∈I is the topological\nspace on the cartesian product ×i∈ISi where the open sets are unions of sets of the\nform ×i∈IUi where Ui is open in Si for all i ∈I, and Ui = Si for all but ﬁnitely\nmany i ∈I. When I has just two elements, say 1 and 2, we also write S1 × S2 for the\nproduct (this operation is clearly associative and commutative). We denote by Sk for\nthe k-th power S × · · · × S of S, equipped with the product topology as described\nabove.\nWe also write SI to a |I|-th power of S, where the factors are indexed by the\nelements of I. In this case, we can view each element of T := SI as a function from\nI to S in the obvious way. The product topology on T is also called the topology of\npointwise convergence, due to the following.\nProposition 7.1.3. Let S be a topological space, and I be a set. Let (fn)n∈N be\na sequence of elements of the product space T := SI. Then limn→∞fn = f if and\nonly if limn→∞fn(j) = f(j) in S for all j ∈I.\nProof. Suppose ﬁrst that limn→∞fn = f in T. Let j ∈I be arbitrary and let V\nbe an open set that contains f(j). Then the set U := Q\ni∈I Ti where Ti = V if i = j,\nand Ti = S otherwise, is open in T and contains f. So there is an n0 such that fn ∈U\nfor all n ≥n0. But then fn(j) ∈V for all n ≥n0, and so limn→∞fn(j) = f(j).\nNow suppose that limn→∞fn(j) = f(j) in S for all j ∈I, and let V be an open\nset of T that contains f. Then there exists a ﬁnite J ⊆I and open subsets (Vj)j∈J\nof S such that f ∈Q\ni∈I Ti where Ti = Vi if i ∈J and Ti = S otherwise. For each\nj ≤J there exists an nj so that fn(j) ∈Vj for all n ≥nj. Then fn ∈V for all\nn ≥max j∈Jnj, and hence limn→∞fn = f.\n□\nExample 7.1.4. When we equip the natural numbers N with the discrete topol-\nogy, then NN with the topology of pointwise convergence is called the Baire space.\nThe open sets are exactly the unions of sets of the form {g ∈N →N | g(¯a) = ¯b} for\nsome ¯a,¯b ∈Nk, k ∈N.\n□\nTheorem 7.1.5 (Tychonoﬀ; see e.g. [124]). Products of compact spaces are com-\npact.\n7.2. Topological Groups\nA topological group is an (abstract) group G together with a topology on the\nelements G of G such that (x, y) 7→xy−1 is continuous from G2 to G. In other words,\nwe require that the binary group operation and the inverse function are continuous.\nTwo topological groups are said to be isomorphic if the groups are isomorphic, and\nthe isomorphism is a homeomorphism between the respective topologies.\nExample 7.2.1. The elements of the group Sym(N) form a (non-closed) subset\nof the Baire space NN (Example 7.1.4), and the topology induced by the Baire space\non Sym(N) is also called the topology of pointwise convergence. The open sets are the\n\n132\n7. TOPOLOGY\nunions of sets of the form {g ∈Sym(N) | g(¯a) = ¯b} for some ﬁnite tuples ¯a,¯b over\nN.\n□\nAn action of a topological group G on a topological space S is continuous if it\nis continuous as a function from G × S into S. A continuous action of G on S gives\nrise to a homomorphism from G into the group of all homeomorphisms of S. An\naction is faithful if this homomorphism is injective. If G is a subgroup of Sym(N) and\nthe space S is countable and equipped with the discrete topology, it makes sense to\ncall a such a homomorphism topologically faithful if additionally the homomorphism\nis a homeomorphism whose image is closed in Sym(S) (equipped with the product\ntopology).\nAn important example of a continuous action of topological groups is the follow-\ning. A left coset of a subgroup V of G is a set of the form {hg | g ∈V } for h ∈G,\nalso written hV . Clearly, the set of all left cosets of G partitions G, and is denoted by\nG/V. The cardinality of G/V is the index of V in G. The set G/V can be viewed\na topological space where a set of left-cosets is open if their union is open in G. We\ncan deﬁne a continuous action of G on G/V by setting g · hV = ghV . This action\nis also called the action of G on G/V by left translation. Analogously we deﬁne the\nspace G\\V of all right-cosets V h, and the action of G on G\\V by right translation.\nEvery open subgroup H of G is closed, since the complement of H in G is the\nopen set given by the union of open sets gH for g ∈G \\ H. A topological group G is\n• Hausdorﬀ(metrizable, Polish) if the topology of G is Hausdorﬀ(metrizable,\nPolish, respectively);\n• ﬁrst-countable if it has a countable basis at the identity.\n• non-archimedian if it has a basis at the identity consisting of open subgroups.\nWe also recall the following.\nProposition 7.2.2 (Proposition 13 and Proposition 14 in [58]). Let G be a\ntopological group, and let H be a subgroup of G. Then\n• G/H is discrete if and only if H is open in G;\n• G/H is Hausdorﬀif and only if H is closed in G.\nThe following is sometimes useful to verify that an action is topologically faithful.\nProposition 7.2.3 (Proposition 2.2.1 in [100]). Let G be a Polish group and H\na subgroup of G with the subspace topology. Then H is Polish if and only if H is\nclosed in G.\nThe topological automorphism group of a structure B with domain B is a topolog-\nical group obtained from the abstract automorphism group G of B (see Section 3.3.4)\nby equiping the elements G of G with the topology of pointwise convergence, that is,\nthe topology induced on G by the one on Sym(B) as given in Example 7.2.1.\nProposition 7.2.4. A set B of permutations of a set B is a closed subset of\nSym(B) if and only if it is locally closed as deﬁned in Deﬁnition 3.3.1.\nProof. The set of operations B is not closed in the topology of pointwise con-\nvergence if and only if there exists a permutation g ∈Sym(B) \\ B such that every\nopen set containing g also contains an element of B. This is the case if and only that\nfor every tuple ¯a, B contains an operation h such that the restriction of g to the ele-\nments of ¯a equals the restriction of h to those elements. According to Deﬁnition 3.3.1,\nthis is exactly the case when g is in the local closure by B.\n□\nIn the following, let G be a topological group that is the automorphism group\nof a relational structure B, and let G be its domain (equipped with the topology\n\n7.2. TOPOLOGICAL GROUPS\n133\nof pointwise convergence). Note that if G is compact then all orbits of G must be\nﬁnite. Hence, when B is ω-categorical, G cannot be compact. It is clear that G is\nnon-archimedian. The topology on G has the following compatible metric d. When\nb1, b2, . . . is an enumeration of the domain B of B, then for elements f, g ∈G we\ndeﬁne d(f, g) = 1/2n+1 where n is the least natural number such that f(bn) ̸= g(bn).\nIn fact, d is an ultrametric, that is, it satisﬁes d(x, z) ≤max(d(x, y), d(y, z)) for all\nx, y, z. Moreover, d is left-invariant, i.e., d(gx, gy) = d(x, y) for all g, x, y ∈G. This\nmetric is not complete: to see this, let f be an arbitrary injective non-surjective\nmapping from B →B. For each n, there exists a permutation hn of B such that\nhn(bi) = f(bi) for all i ≤n. Hence, the sequence (hn)n≥1 is Cauchy, but it does not\nconverge to a permutation.\nThe topology on G is also completely metrizable. To see this, we deﬁne a com-\npatible complete metric d′ by setting d′(f, g) = 1/2n+1 for elements f, g ∈G where\nn is the least natural number such that f(bn) ̸= g(bn) or f −1(bn) ̸= g−1(bn). Al-\nternatively, and more generally, when d is a compatible left-invariant metric, then\nd(x, y) + d(x−1, y−1) deﬁnes a compatible complete metric (see [19]).\nFinally, G is separable: for all ﬁnite tuples ¯a, ¯b that lie in the same orbit we ﬁx\nan element of G that maps ¯a to ¯b; the (countable) set of all the selected elements of\nG is clearly dense in G.\nIn this thesis, we will be exclusively interested in topological groups that arise as\nautomorphism groups of countable structures. Those groups can be characterised in\ntopological terms, as demonstrated in Proposition 7.2.5 below.\nProposition 7.2.5 (Section 1.5 in [19]; also see Theorem 2.4.1 and Theorem\n2.4.4 in [100]). Let G be a topological group. Then the following are equivalent.\n(1) G is isomorphic to the topological automorphism group of a countable rela-\ntional structure.\n(2) G is isomorphic to a closed subgroup of Sym(N).\n(3) G is Polish and admits a compatible left-invariant ultrametric.\n(4) G is Polish and non-archimedian.\n(5) G is Polish and has an at most countable basis closed under left multiplica-\ntion, that is, an at most countable basis B of G so that for any U ∈B and\ng ∈G we have gU ∈B.\nProof. The equivalence of (1) and (2) has been shown in Proposition 3.3.2.\nThe implication from (1) to (3) has been explained in the paragraphs preceding the\nstatement of the proposition. So it suﬃces to show (3) ⇒(4) ⇒(5) ⇒(2).\nFor the implication from (3) to (4), let d be a left-invariant ultrametric on G.\nLet Un = {x ∈G | d(x, 1) < 2−n}, for n ∈N. We claim that the set of all those Un\nforms a basis at the identity consisting of open subgroups. Since d is a left-invariant\nultra-metric, for x, y ∈G we have\nd(x−1y, 1) = d(y, x) ≤max(d(y, 1), d(1, x))\nand thus Un is a indeed a subgroup.\nFor the implication from (4) to (5), assume (4). Let {U1, U2, . . . } be an at most\ncountable basis at the identity (which exists since G is metrizable). Each Ui has an\nopen subset Vi which is a subgroup, since G has a basis at the identity consisting of\nopen subgroups. Then {V1, V2, . . . } is a countable basis of the identity consisting of\nopen subgroups. Each Vi has at most countably many cosets since G is separable. So\nthe set of all cosets of those groups gives an at most countable basis that is closed\nunder left multiplication.\nFinally, we show that (5) implies (2).\nLet B = {U1, U2, . . . } be an at most\ncountable basis closed under left multiplication. If B is inﬁnite, we deﬁne the map\n\n134\n7. TOPOLOGY\nξ : G →Sym(N) by setting\nξ(g)(n) = m ⇔gUn = Um .\nIf |B| = n0 is ﬁnite, we deﬁne the map ξ : G →Sym(N) similarly, but set ξ(g)(n) = n\nfor all n > n0. It is straightforward to verify that ξ(fg) = ξ(f)ξ(g). The mapping\nξ is injective: when f and g are distinct, then there are disjoint open subsets U and\nV with f ∈U and g ∈V , because the topology is Hausdorﬀ; since B is a basis,\nwe can assume that U = Un1 and V = Un2, for some n1, n2 ≥1. If fUn1 = gUn1,\nthen g ∈Un1 = U since f ∈Un1, contradicting the assumption that U and V\nare disjoint. Hence, ξ(f)(n1) ̸= ξ(g)(n1), and so ξ(f) ̸= ξ(g). Since bijective algebra\nhomomorphisms are isomorphisms, ξ is an isomorphism between G and a subgroup of\nSym(N). To verify that ξ is continuous, let g ∈G be arbitrary, and let V ⊆Sym(N)\nbe an open set containing ξ(g). Then V is a union of basic open sets of the form\nV¯a,¯b := {f ∈Sym(N) | f(¯a) = ¯b} for some ¯a,¯b ∈Nn. The preimage of V¯a,¯b under ξ\nis {g ∈G | gUa1 = Ub1 ∧· · · ∧gUan = Ubn}. Since multiplication in G is continuous,\nthis set is open. Hence the preimage of V is a union of open sets and therefore open\nas well, which concludes the proof that ξ is continuous.\nIt can also be veriﬁed that ξ is open; for the details of this last step, we refer\nto [100] (Theorem 2.4.4). Therefore, ξ is a homeomorphism between G and its image\nξ(G), which is therefore also Polish, and a subgroup of the Polish group Sym(N). By\nProposition 7.2.3, ξ(G) is a closed subgroup of Sym(N).\n□\nA subgroup N of G with domain N is called normal if gN = Ng for all elements\ng of G. Recall the following equivalent characterizations of normality of subgroups,\nwhich can be seen as a reﬁnement of Proposition 5.5.2 for the case of groups.\nProposition 7.2.6. Let G be a group, and N be a subgroup of G. Then the\nfollowing are equivalent.\n(1) N is normal.\n(2) G has the congruence E = {(a, b) | ab−1 ∈N}.\n(3) There is a homomorphism h from G to some group such that N = h−1(0).\n(4) For every g ∈G and every v ∈N we have gvg−1 ∈N.\nProof. (1) ⇒(2): to verify that E is a congruence, we have to show that for\nall (a1, b1), (a2, b2) ∈E, (a1a2, b1b2) ∈E. Indeed, (a1a2)(b1b2)−1 = a1(a2b−1\n2 )b−1\n1\n∈\na1Nb−1\n1\n= Na1b−1\n1\n⊆NN = N.\n(2) ⇒(3): follows from Proposition 5.5.2: g 7→gN is a group homomorphism\nfrom G to G/N.\n(3) ⇒(4): For g ∈G and v ∈h−1(0), we must show that gvg−1 ∈h−1(0).\nIndeed, h(gvg−1) = h(g)h(v)h(g)−1 = h(g)0h(g)−1 = 0.\n(4) ⇒(1): assume that gNg−1 ⊆N for all g ∈G. Let a ∈G be arbitrary.\nApplying the assumption for g = a we ﬁnd that aN ⊆Na. Applying the assumption\nfor g = a−1 we ﬁnd that a−1N(a−1)−1 = a−1Na ⊆N, and hence Na ⊆aN. We\nconclude that aN = Na.\n□\nWhen G is an automorphism group, then closed normal subgroups of G typically\narise as the subgroups consisting of those elements of G that ﬁx the equivalence classes\nof a congruence relation on the elements of G. This can be made precise as follows1.\nProposition 7.2.7. Let G be the automorphism group of a relational structure\nB with domain B. If E is a G-invariant equivalence relation on Bn, for some n, then\nthe subgroup of G that preserves each equivalence class of E is closed and normal.\n1I thank Todor Tsankov for pointing this out to me.\n\n7.3. OLIGOMORPHIC GROUPS\n135\nConversely, every closed normal subgroup of G is the intersection of closed normal\nsubgroups that arise in this way.\nProof. Let C be the expansion of B by a unary relation for each equivalence\nclass of E. Then Aut(C) is closed by Proposition 3.3.2, and it is a normal subgroup\nof Aut(B): when g ∈Aut(B) and h ∈Aut(C), then g ◦h ◦g−1 preserves each\nequivalence class of E, and thus is an automorphism of C.\nNormality of Aut(C)\nfollows from Proposition 7.2.6.\nFor the second part, suppose that G has a closed normal subgroup N. Consider\nthe relation\nRn := {(x, y) | x, y ∈Bn and there is h ∈N such that h(x) = y} .\nThis relation is obviously an equivalence relation, and it is preserved by all the au-\ntomorphisms of B. For this, we have to show that for all g ∈G and all (x, y) ∈Rn\nwe have that (g(x), g(y)) ∈Rn. So suppose that x, y ∈Bn such that h(x) = y for\nsome h ∈N. Then g(y) = g(h(x)) ∈(gN)(x) = (Ng)(x) = N(g(x)) by normality\nof N. Hence there exists an h′ ∈N such that h′(g(x)) = g(y), which shows that\n(g(x), g(y)) ∈Rn.\nLet C be the structure that contains for all n the n-ary relations given by the\nequivalence classes of the relations Rn for all n ≥0. We claim that N is precisely\nthe automorphism group of C. As in the ﬁrst part we can verify that every h ∈N is\nan automorphism of C. The converse follows by local closure as follows. Let g be an\nautomorphism of C, and let x, y be from Bn so that g(x) = y. Since g preserves the\nequivalence classes of Rn, there exists an h ∈N such that h(x) = y. Hence, g lies in\nthe closure of N, which implies that g is from N since N is closed.\n□\nExample 7.2.8. The automorphism group G of the structure B = (Q; Betw),\nwhere Betw =\n\b\n(x, y, z) | (x < y < z) ∨(z < y < x)\n\t\n, is 2-transitive and therefore\nprimitive. However, the relation\n\b\n((x1, x2), (y1, y2)) | (x1 < x2 ∧y1 < y2) ∨(x1 >\nx2 ∧y1 > y2) ∨(x1 = x2 ∧y1 = y2)\n\t\nis a G-invariant equivalence relation on Q2. And\nindeed, G has a closed normal subgroup N that is isomorphic to the automorphism\ngroup of (Q; <), and G/N has two elements, corresponding to the automorphisms\nthat reverse the order <, and the automorphisms that preserve the order.\n□\n7.3. Oligomorphic Groups\nIn the last section we have seen conditions that describe when a topological group\nis the automorphism group of a countable structure. In this section, we see conditions\nthat describe when a topological group is the automorphism group of a countable ω-\ncategorical structure. As a permutation group, we have seen that these groups are\nprecisely the closed oligomorphic permutation groups (as we have seen in Section 3.3);\nwe therefore call a topological group oligomorphic if it is isomorphic to an oligomor-\nphic subgroup of Sym(N). In fact, Theorem 7.3.1 below shows that the information\nwhether a topological group G is oligomorphic can be expressed quite naturally in\nterms of the open subgroups of G without referring to any particular oligomorphic\naction of G.\nA topological group G is called Roelcke precompact if for every open set U ⊆G\nthat contains the identity there exists a ﬁnite set F ⊆G such that G = UFU.\nThe following theorem is essentially from Tsankov [195]; there, the focus has been a\ncharacterization of Roelcke precompact groups in terms of oligomorphic groups. Here,\non the other hand, the focus will be the characterization of oligomorphic groups in\n\n136\n7. TOPOLOGY\nterms of Roelcke precompact ones, and this motivates the following formulation of\nTsankov’s theorem2.\nTheorem 7.3.1 (of Tsankov [195]). Let G be isomorphic to a closed subgroup of\nSym(N). Then the following are equivalent.\n(1) G is the automorphism group of a countably inﬁnite ω-categorical structure.\n(2) G is Roelcke precompact, and G has an open subgroup V of countably inﬁnite\nindex such that for all open subgroups U of G there are g1, . . . , gn ∈G such\nthat T\ni≤n giV g−1\ni\n⊆U.\n(3) For every open subgroup U of G the set {UfU | f ∈G} is ﬁnite, and G\nhas an open subgroup V of countably inﬁnite index such that for all open\nsubgroups U of G there are g1, . . . , gn ∈G such that T\ni≤n giV g−1\ni\n⊆U.\n(4) G has a topologically faithful transitive action on a countably inﬁnite set\nwith the discrete topology, and every such action of G is oligomorphic.\n(5) G is the automorphism group of a countably inﬁnite ω-categorical structure\nwith only one orbit.\nProof. The implication from (5) to (1) is trivial, and we prove (1) ⇒(2) ⇒\n(3) ⇒(4) ⇒(5). For the implication from (1) to (2), suppose that G is the automor-\nphism group of an ω-categorical structure B, and let G be the domain of G, which is\na set of permutations of the domain B of B. Since B is ω-categorical, it has a ﬁnite\nnumber k of orbits by Theorem 3.1.4; choose orbit representatives b1, . . . , bk ∈B,\nand write ¯b for (b1, . . . , bk). Then the stabilizer V := G¯b is an open subgroup of G\nof countably inﬁnite index. Let U be an arbitrary open subgroup of G. Then U\ncontains G¯a for some ¯a ∈Bn. For j ≤n, let gj ∈G be such that gj(aj) = b where\nb ∈{b1, . . . , bk} is from the same orbit as aj. We claim that K := T\nj≤n g−1\nj V gj ⊆U.\nTo see this, let h ∈K be arbitrary. Since h ∈g−1\nj V gj we ﬁnd that h(aj) = aj. Hence,\nh ∈G¯a ⊆U.\nTo show that G is Roelcke precompact, let U ⊆G be open with 1 ∈U. Then\nthere exists an n such that U contains the stabilizer G¯a for an n-tuple ¯a of elements of\nB. It suﬃces to show the existence of a ﬁnite number of elements g1, . . . , gk of G such\nthat G = S\ni≤k G¯agiG¯a. By Theorem 3.1.4, G has ﬁnitely many orbits of 2n-tuples;\nso let (¯a, g1 · ¯a), . . . , (¯a, gk · ¯a) be a complete list of representatives for those orbits of\n2n-tuples that are contained in G·¯a×G·¯a. We claim that G¯ag1G¯a∪· · ·∪G¯agkG¯a = G.\nLet f ∈G be arbitrary. Let i ≤k be such that (¯a, f · ¯a) and (¯a, gi · ¯a) lie in the same\norbit of n-tuples in G¯a. So there exists an h ∈G¯a such that f · ¯a = hgi · ¯a. Then\nf −1 ◦h ◦gi lies in G¯a, so f ∈G¯agiG¯a as required.\nFor the implication (2) implies (3), let U be an open subgroup of G. Since G is\nRoelcke precompact there exists a ﬁnite set F ⊆G such that G = UFU. Then |F|\nbounds the sets of the form {UfU | f ∈G} because those sets partition G.\n(3) implies (4). Since V is open, G/V has the discrete topology, and the action of\nG on the countably inﬁnite set G/V by left translation is continuous and transitive.\nWe show that this action, as a map ξ from G to Sym(G/V), is open. Let U ⊂G\nbe open. By assumption, there are g1, . . . , gn ∈G such that K := T\ni≤n giV g−1\ni\n⊆U.\nNote that every h ∈K ﬁxes giV for all i ≤n. Hence, ξ(U) contains the stabilizer of\nﬁnitely many elements, and hence is open. It also follows that the action is faithful: to\nsee this, let f, g ∈G be distinct. We have to show that φ(fg−1) ̸= 1. Since fg−1 ̸= 1\nthere is an open subgroup U that contains 1 but not fg−1. Since ξ(U) is open, there\nare ﬁnitely many h1, . . . , hm such that\nU ′ := {h ∈U | hh1V = h1V ∧· · · ∧hhmV = hmV } ⊆U .\n2I am grateful to Todor Tsankov for his help with the presented reformulation of his result.\n\n7.4. BI-INTERPRETATIONS\n137\nThen U ′ still contains 1 and not fg−1, so assume in the following that U ′ = U.\nSince the sets of the form gV g−1 are precisely the point stabilizers of G/V, we\nhave that the kernel φ−1(1) of ξ can be expressed as φ−1 = T\ng∈G gV g−1.\nSince\nfg−1 /∈U = T\ng∈{h1,...,hm} hV h−1, it follows in particular that fg−1 /∈φ−1(1), which\nis what we wanted to show.\nNow ξ is a homeomorphism between the Polish group G and its image H := ξ(U)\nand hence H is Polish as well. We can apply Proposition 7.2.3 to the subgroup H of\nthe Polish group Sym(G/V), and conclude that H is closed in Sym(G/V). Hence,\nthe action is topologically faithful.\nWe show by induction on n that this action has only ﬁnitely many orbits of n-\ntuples, for all n. Since the action is transitive, this is true for n = 1. For the induction\nstep, ﬁx ¯a = (a1, . . . , an) ∈Dn, and let c be an arbitrary element from D\\{a1, . . . , an}.\nBy Roelcke precompactness of G, there exists a ﬁnite set {f1, . . . , fk} ⊆G such that\nG = G¯acf1G¯ac ∪· · · ∪G¯acfkG¯ac. Let B(¯a) be {f1 · c, . . . , fk · c}.\nClaim 1. For every d ∈D \\ {a1, . . . , an} there is an h ∈G¯a and b ∈B(¯a) such\nthat d = h · b. By transitivity of G, there is a g ∈G so that d = g · c, for arbitrary\nd ∈D \\ {a1, . . . , an}. Let i, h1, h2 be such that h1, h2 ∈G¯ac and g = h1fih2. Then\nd = gc = h1fih2 · c = h1fi · c, proving Claim 1.\nClaim 2. When {¯a1, . . . , ¯as} is a complete set of representatives for the orbits of\nn-tuples of the permutation group G, then\n{(¯ai, b) | i ≤s, b ∈B(¯ai)}\nis a complete set of representatives for the orbits of (n + 1)-tuples. Let (¯c, d) ∈Dn+1.\nBy assumption there exists g ∈G such that g · ¯ai = ¯c. Find h ∈G¯ai and b ∈B(¯ai)\nsuch that g−1 · d = h · b. Then one has\ngh · (¯ai, b) = g · (¯ai, h · b) = (¯c, d) .\nThis shows that G has ﬁnitely many orbits of (n + 1)-tuples, and concludes the\ninduction step.\nThe implication from (4) to (5) follows from Corollary 3.3.9: let D be the count-\nably inﬁnite set on which G acts continuously, transitively, and topologically faithfully.\nThen the set of permutations of D induced by this action is a closed oligomorphic\npermutation group, and hence the automorphism group of an ω-categorical relational\nstructure with domain D. Since the action is transitive, the structure has only one\norbit.\n□\nNote that the groups from Theorem 7.3.1 must always have continuum cardinality;\nthis follows from the following and the remarks after Lemma 3.1.10.\nTheorem 7.3.2 (Corollary 4.1.5 in [120]). Let B be a countable structure. Then\nthe following are equivalent.\n(1) | Aut(B)| ≤ω\n(2) | Aut(B)| < 2ω\n(3) There is a ﬁnite tuple ¯a in B such that | Aut((B, ¯a))| = 1\n7.4. Bi-interpretations\nWhen two ω-categorical structures share the same topological automorphism\ngroup, then the relationship between the two structures can be described model-\ntheoretically.\nTheorem 7.4.1 (Ahlbrandt and Ziegler [3]). Two ω-categorical structures B and\nC are bi-interpretable if and only if Aut(B) and Aut(C) are isomorphic as topological\ngroups.\n\n138\n7. TOPOLOGY\nThe subgroup of G consisting of the identity element only is called trivial, and\nsubgroups of G that are distinct from G are called proper.\nExample 7.4.2. The structures C := (N2; {(x, y), (u, v) | x = u}) and D := (N; =)\nare mutually primitive positive interpretable, but not bi-interpretable. To see this,\nobserve that Aut(C) has a proper non-trivial closed normal subgroup N such that\nAut(C)/N is isomorphic to Aut(D) (see Proposition 7.2.7), whereas Aut(D), the sym-\nmetric permutation group of a countably inﬁnite set, has no proper non-trivial closed\nnormal subgroups (it has exactly three proper non-trivial normal subgroups [184],\nnone of which is closed).\n□\nTheorem 7.4.1 has many consequences. For instance, it shows in combination\nwith Theorem 7.3.1 that every ω-categorical structure is bi-interpretable with an ω-\ncategorical structure that has only one orbit. Ahlbrandt and Ziegler also showed the\nfollowing.\nTheorem 7.4.3 (From [3]; also see Theorem 5.3.5 and 7.3.7 in [119]). Let C\nbe an ω-categorical structure with at least two elements. Then a structure B has a\nﬁrst-order interpretation in C if and only if B is the reduct of a structure B′ such\nthat there is a surjective continuous group homomorphism f : Aut(C) →Aut(B′).\nSeveral fundamental properties of ω-categorical structures B are preserved by\nbi-interpretability, and therefore, by Theorem 7.4.1, only depend on the topological\nautomorphism group of B. As we will see in Chapter 8, this is for instance the case\nfor the property whether an ordered homogeneous structure has the Ramsey property.\nWe give another property of this type.\nDefinition 7.4.4. Let B be an ω-categorical structure. Then B has essentially\ninﬁnite signature if every relational structure C that is interdeﬁnable with B (equiva-\nlently, has the same set of automorphisms as B, by Proposition 3.3.8) has an inﬁnite\nsignature.\nWe show that the property to have essentially inﬁnite language is preserved by\nbi-interpretability.\nProposition 7.4.5. Let B and C be ω-categorical structures that are ﬁrst-order\nbi-interpretable. Then B has essentially inﬁnite signature if and only if C has.\nProof. Let τ be the signature of B.\nWe have to show that if C has ﬁnite\nsignature, then B is interdeﬁnable with a structure B′ with a ﬁnite signature. Let σ ⊆\nτ be the set of all relation symbols that appear in all the formulas of the interpretation\nof C in B. Since the signature of C is ﬁnite, the cardinality of σ is ﬁnite as well.\nWe will show that there is a ﬁrst-order deﬁnition of B in the σ-reduct B′ of\nB. Suppose that the interpretation I1 of C in B is d1-dimensional, and that the\ninterpretation I2 of B in C is d2-dimensional. Let θ(x, y1,1, . . . , yd1,d2) be the formula\nthat shows that I2 ◦I1 is homotopic to the identity interpretation. That is, θ deﬁnes\nin B the (d1d2 + 1)-ary relation that contains a tuple (a, b1,1, . . . , bd1,d2) iﬀ\na = h2(h1(b1,1, . . . , b1,d2), . . . , h1(bd1,1, . . . , bd1,d2)) .\nLet φ be an atomic τ-formula with k free variables x1, . . . , xk. We will specify a\nσ-formula that is equivalent to φ over B′.\n∃y1\n1,1, . . . , yk\nd1,d2\n\u0000 ^\ni≤k\nθ(xi, yi\n1,1, . . . , yi\nd1,d2)\n∧φI1I2(y1\n1,1, . . . , yk\n1,d2, y1\n2,d2, . . . , yk\n2,d2, . . . , yk\nd1,d2)\n\u0001\n\n7.4. BI-INTERPRETATIONS\n139\nis equivalent to φ(x1, . . . , xk) over B. Indeed, by surjectivity of h2, for every element\nai of B there are elements ci\n1, . . . , ci\nd2 of C such that h2(ci\n1, . . . , ci\nd2) = ai, and by\nsurjectivity of h1, for every element ci\nj of C there are elements bi\n1,j, . . . , bi\nd1,j of B such\nthat h1(bi\n1,j, . . . , bi\nd1,j) = ci\nj. Then\nB |= R(a1, . . . , ak) ⇔C |= φI2(c1\n1, . . . , c1\nd2, . . . , ck\n1, . . . , ck\nd2)\n⇔B′ |= φI1I2(b1\n1,1, . . . , bk\n1,d2, b1\n2,d2, . . . , bk\n2,d2, . . . , bk\nd1,d2)\n□\nNote that if B and C are ω-categorical structures that are even primitive posi-\ntive bi-interpretable, then the above proof even shows that B is primitively positive\ninterdeﬁnable with a structure with a ﬁnite domain if and only if C is.\nProposition 7.4.5 shows via Theorem 7.4.1 that having essentially inﬁnite sig-\nnature only depends on the topological automorphism group of B. But unlike the\nproperty of ω-categoricity and Theorem 7.3.1, we are not aware of any elegant char-\nacterization of those properties that is directly stated in terms of the topological\ngroup.\n\n\nCHAPTER 8\nRamsey Theory\nThe application of Ramsey theory to study the expressive power of constraint\nlanguages via polymorphisms is one of the central contributions of this thesis. The\nidea is that polymorphisms must behave in a regular way on large parts of their\ndomain. This also leads us to decidability results for several meta-questions about\nthe expressive power of constraint languages. The same idea can be used to show\nstatements of the type ‘every polymorphism that violates R must locally generate g’,\nfor certain ﬁxed operations g with good properties. Such statements will be crucial\nin the classiﬁcation projects in Chapters 9 and 10.\nIn this chapter we ﬁrst revisit classical concepts and results from structural Ram-\nsey theory in Section 8.1. In order to apply Ramsey theory to analyze polymorphism\nclones, we need the product Ramsey theorem, but also other fundamental facts from\nRamsey theory, some of which appear to be new (such as Corollary 8.2.13). Those\nfacts will be derived from a recently discovered fundamental connection between Ram-\nsey theory and topological dynamics due to Kechris, Pestov, and Todorcevic [132].\nThis connection allows a more systematic understanding of Ramsey-theoretic princi-\nples, and we present it in Section 8.2. The way in which we apply Ramsey theory to\npolymorphisms is described in Section 8.3. We close with an application of our tech-\nnique in Section 8.4, and prove the decidability of various meta-problems concerning\nconstraint satisfaction problems, that is, problems where the input is a description\nof a template B, and the question is whether the corresponding CSP has certain\nproperties (for instance, whether certain relations are primitive positive deﬁnable).\nSome of the results presented here have been published in [54]; there is also a\nsurvey article [50] that additionally covers the applications of our technique for the\nclassiﬁcation of ‘the ﬁrst-order reducts’ of a given homogeneous structure C, that is,\nthe structures that are ﬁrst-order deﬁnable in C.\n141\n\n142\n8. RAMSEY THEORY\n8.1. Ramsey Classes\nThis section is about classes C of ﬁnite structures that satisfy the following\nRamsey-type property: for all A, B ∈C there exists a C ∈C such that B embeds\ninto C, and when we assign ﬁnitely many ‘colors’ to the substructures of C that are\nisomorphic to A, then we can ﬁnd a ‘monochromatic’ copy of B in C, i.e., an induced\nsubstructure of C that is isomorphic to B and in which all copies of A in this sub-\nstructure have the same color. Before we formalize this in detail, we give the classical\nresult of Ramsey, which provides a prototype of a class with the Ramsey property.\nFrom now on, we denote the set {1, . . . , n} also by [n]. Subsets of a set of car-\ndinality m will be called m-subsets in the following. Let\n\u0000S\nm\n\u0001\ndenote the set of all\nm-subsets of S. We also refer to mappings f :\n\u0000S\nm\n\u0001\n→[r] as a coloring of S (with the\ncolors [r]).\nTheorem 8.1.1 (Ramsey’s theorem). Let B be a countably inﬁnite set, and let\nm, r be ﬁnite integers. For every χ:\n\u0000B\nm\n\u0001\n→[r] there exists an inﬁnite P ⊆B such\nthat χ is constant on all m-element subsets of P.\nA proof of Theorem 8.1.1 can be found in [120] (Theorem 5.6.1); for a broader\nintroduction to Ramsey theory see [105].\nIt is easy to derive the following ﬁnite\nversion of Ramsey’s theorem from Theorem 8.1.1 via a compactness argument.\nTheorem 8.1.2 (Finite version of Ramsey’s theorem). For all positive integers\nr, m, k there is a positive integer l such that for every χ:\n\u0000[l]\nm\n\u0001\n→[r] there exists a\nk-subset S of [l] such that χ is constant on\n\u0000S\nm\n\u0001\n.\nProof. A proof by contradiction: suppose that there are positive integers r, m, k\nsuch that for all positive integers l there is a χ:\n\u0000[l]\nm\n\u0001\n→[r] such that for all k-subsets S\nof [l] the mapping χ is not constant on\n\u0000S\nm\n\u0001\n. Since the property that for all k-subsets S\nof [l] the mapping χ is not constant on\n\u0000S\nm\n\u0001\nis universal ﬁrst-order, and since the image\nof χ is ﬁnite, we can apply Lemma 3.1.8 and get the existence of a mapping χ with\nthe same property but deﬁned on all integers. This contradicts Theorem 8.1.1.\n□\nWe write R(r, m, k) for the smallest number l whose existence is asserted by\nTheorem 8.1.2.\nMore generally, when A and B are τ-structures, we write\n\u0000B\nA\n\u0001\nfor the set of all\ninduced substructures of B that are isomorphic to A. When A, B, C are τ-structures,\nand r ≥1 is ﬁnite, we write\nC →(B)A\nr\nif for all χ:\n\u0000C\nA\n\u0001\n→[r] there exists B′ ∈\n\u0000C\nB\n\u0001\nsuch that χ is constant on\n\u0000B′\nA\n\u0001\n.\nDefinition 8.1.3. A class of relational structures that is closed under isomor-\nphisms and induced substructures is called Ramsey if for every A, B ∈C and for every\nﬁnite k ≥1 there exists a C ∈C such that B embeds into C, and C →(B)A\nk .\nOur ﬁrst example of a Ramsey class is the class of all ﬁnite structures over the\nempty signature; this is an immediate consequence of Theorem 8.1.2. We also observe\nthe following.\nRecall that the age of a τ-structure B is the class of all ﬁnite τ-\nstructures that embed into B.\nCorollary 8.1.4. The age of (Q; <) is Ramsey.\nProof. This is again a direct consequence of Theorem 8.1.2, since whether or\nnot an m-element substructure is isomorphic to an n-element substructure of (Q; <)\nonly depends on n and m.\n□\n\n8.1. RAMSEY CLASSES\n143\nWe will now present further examples of Ramsey classes; the proofs are non-trivial\nand fall out of the scope of this thesis, but we provide references.\nExample 8.1.5. The class of all ﬁnite Boolean algebras B = (B; ⊔, ⊓, c, 0, 1) has\nthe Ramsey property. This is explicitly stated in [132], page 147, line 3ﬀ(see also\npage 112, line 9ﬀ), where it is observed that this follows from a result by Graham\nand Rothschild [104].\n□\nIt might be instructive to also see an example of a class of structures that is not\nRamsey. Typical examples come from classes that contain structures with non-trivial\nautomorphism groups, as in the following.\nExample 8.1.6. The class of all ﬁnite graphs is not a Ramsey class. To see this,\nlet A be the (undirected) graph\n\u0000{0, 1, 2}; {{0, 1}, {1, 2}}\n\u0001\n(since the edge relation is\nsymmetric we write edges as 2-element subsets of the vertices) with three vertices and\ntwo edges, and let B be C4, that is, the undirected four-cycle\n\u0000{0, 1, 2, 3}; {{0, 1}, {1, 2}, {2, 3}, {3, 0}}\n\u0001\n.\nLet C be an arbitrary graph. We want to show that there is a way to color the copies\nof A in C without producing a monochromatic copy of B. For that, ﬁx an arbitrary\nlinear order < on the vertices of C. We deﬁne a coloring χ:\n\u0000C\nA\n\u0001\n→{0, 1} as follows.\nIf there is an embedding h of A into C such that h(0) < h(1) < h(2), then we color\nthe corresponding copy of A in C with 0; all other copies of A in C are colored by 1.\nWe claim that any copy of B in C contains a copy of A that is colored by 1, and one\nthat is colored by 0. The reason is that for any ordering of the vertices of B there is\nan embedding h′ of A into B such that h′(0) < h′(1) < h′(2), and an embedding h′′\nof A into B such that not h′′(0) < h′′(1) < h′′(2). Hence, C ̸→(B)A\n2 .\n□\nFrequently, a class without the Ramsey property can be made Ramsey by expand-\ning its members appropriately with a linear ordering. We will see several examples.\nExample 8.1.7. Neˇsetˇril and R¨odl [168] and independently Abramson and Har-\nrington [1] showed that for any relational signature τ, the class C of all ﬁnite or-\ndered τ-structures is a Ramsey class. That is, the members of C are ﬁnite structures\nA = (A; <, R1, R2, . . . ) for some ﬁxed signature τ = {<, R1, R2, . . . }, where < is a\ntotal linear order of A.\nA shorter and simpler proof of this substantial result can be found in [169] and\n[166]; the proof there uses the partite method, which uses amalgamation to reduce\nthe statement to proving the so-called partite lemma; the proof of the partite lemma\nrelies on the Hales-Jewett theorem from Ramsey theory (see [105]).\n□\nExample 8.1.8. Recall the homogeneous structure B = (B; |) carrying a C-\nrelation, introduced in Section 4.1. We consider the expansion of B by a linear order,\ndeﬁned as follows. It is easy to see that for every ﬁnite tree T there is an ordering\n< on the leaves L of T such that for all u, v, w ∈L with u < v < w we have either\nu|vw or uv|w (recall Deﬁnition 4.1.3). This can be seen from the obvious existence\nof an embedding of T on the plane so that all leaves lie on a line and none of the\nedges cross, and take the linear order induced by the line. We call such an ordering\nof L compatible with T. The class of all ﬁnite substructures C of B expanded by a\ncompatible ordering of the underlying tree of C is a Ramsey class; this follows from\nmore general results by Milliken (Theorem 4.3 in [163], building on work in [83]),\nand has been shown explicitly in [49].\n□\nExample 8.1.9. The Ramsey classes from Example 8.1.7 have been further gen-\neralized by Neˇsetˇril and R¨odl as follows [168]. Suppose that N is a (not necessarily\n\n144\n8. RAMSEY THEORY\nﬁnite) class of structures with ﬁnite relational signature τ whose Gaifman graph (Def-\ninition 2.1.2) is a clique – such structures have been called irreducible in the Ramsey\ntheory literature. It can be readily veriﬁed that C := Forb(N) is an amalgamation\nclass. Then the class of all expansions of the structures in C by a linear order is a\nRamsey class; again, this can been shown by the partite method [169]. This example\nis indeed a generalization of Example 8.1.7 since we obtain the previous result by\ntaking N = ∅.\n□\nThe fact that all the above Ramsey classes could be described as the age of a\nhomogeneous structure is not a coincidence.\nWe have the following (the proof is\nfrom [167], and presented here for the convenience of the reader).\nTheorem 8.1.10 (of [167]). Let τ be a relational signature, and let C be a class\nof ordered ﬁnite τ-structures that is closed under induced substructures, isomorphism,\nand has the joint embedding property (see Section 3.2). If C is Ramsey, then it has\nthe amalgamation property.\nProof. Let A, B1, B2 be members of C such that A is an induced substructure\nof both B1 and B2. Since C has the joint embedding property, there exists a structure\nC ∈C with embeddings e1, e2 of B1 and B2 into C. If e1, e2 have the same restriction\nto A, then we are done, so assume otherwise.\nLet D ∈C be such that D →(C)A\n2 . Deﬁne a coloring χ:\n\u0000D\nA\n\u0001\n→{1, 2} as follows.\nWhen A′ ∈\n\u0000D\nA\n\u0001\n, and f : A →A′ is an isomorphism, then χ(A′) = 1 if and only if\nthere is an embedding h of C into D such that f = h ◦e1.\nSince D →(C)A\n2 , there exists C′ ∈\n\u0000D\nC\n\u0001\n, witnessed by an embedding h′ of C into\nD such that χ is constant on\n\u0000C′\nA\n\u0001\n. Now any copy of C in D contains a copy A′ of A\nwith χ(A′) = 1. Thus χ is constant 1 on\n\u0000C′\nA\n\u0001\n.\nConsider the embedding h′ ◦e2 of A into D; as we have seen above, the corre-\nsponding copy of A in D is colored 1. Thus there exists an embedding h′′ of C into\nD such that f = h′′ ◦e1 = h′ ◦e2 (here we use the assumption that the structure A\nis ordered). This shows that D together with the embeddings h′′ ◦e1 : B1 →D and\nh′ ◦e2 : B2 →D is the amalgam of B1 and B2 over A.\n□\nIt is often convenient to work with the Fra¨ıss´e-limit of a Ramsey class rather than\nthe class itself. Indeed, we have the following.\nProposition 8.1.11. Let C be an amalgamation class, and let C be the Fra¨ıss´e-\nlimit of C. Then C has the Ramsey property if and only if C →(B)A\nk for all A, B ∈C,\nand k ≥2.\nProof. Let A, B ∈C, and k ≥2 an integer. When k is the cardinality of\n\u0000B\nA\n\u0001\n,\nthen for any structure D the fact that D →(B)A\nr can equivalently be expressed in\nterms of r-colorability of a certain k-uniform hypergraph, deﬁned as follows.\nLet\nG = (V ; E) be the structure whose vertex set V is\n\u0000D\nA\n\u0001\n, and where (A1, . . . , Ak) ∈E\nif there exists a B′ ∈\n\u0000D\nB\n\u0001\nsuch that\n\u0000B′\nA\n\u0001\n= {A1, . . . , Ak}. Let H = ([r]; E) be the\nstructure where E contains all tuples except the tuples (1, . . . , 1), . . . , (r, . . . , r). Then\nD →(B)A\nr if and only if G homomorphically maps to H. By Lemma 3.1.5, this is\nthe case if and only if all ﬁnite substructures of G homomorphically map to H. Thus,\nC →(B)A\nr if and only if C′ →(B)A\nr for all ﬁnite substructure C′ of C.\n□\nWhen B is a homogeneous structure with a ﬁnite relational signature whose age\nis a Ramsey class, then this fact is useful for studying which relations are primitive\npositive deﬁnable in B, as we will see for instance in Section 8.4. In fact, for those\napplications of Ramsey theory it suﬃces that B can be expanded to a structure C\n\n8.2. EXTREMELY AMENABLE GROUPS\n145\nthat is homogeneous, Ramsey, and has a ﬁnite relational signature. The following\nquestion has been asked.\nQuestion 8.1. Let B be a homogeneous structure with a ﬁnite relational signa-\nture. Then there is a homogeneous expansion C of B with ﬁnite relational signature\nwhose age has the Ramsey property.\n8.2. Extremely Amenable Groups\nThis section presents a link between Ramsey classes and Polish groups that are\nextremely amenable. The link rests on the theorem of Kechris, Pestov, and Todorcevic\nthat characterizes those ordered homogeneous structures that are Ramsey in terms\nof their topological automorphism group, and will be presented in Section 8.2.1. In\nSection 8.2.2, 3.3.4, and 8.2.4, we use this result to obtain a more systematic under-\nstanding of Ramsey classes.\n8.2.1. Extreme Amenability. The Ramsey property for ordered homogeneous\nstructures B has an elegant characterization in terms of the topological automorphism\ngroup of B: the age of B is Ramsey if and only if the topological automorphism group\nof B is extremely amenable. Extreme amenability is a concept from group theory\nstudied since the 60s [106].\nDefinition 8.2.1. A topological group is extremely amenable iﬀevery continuous\naction of the group on a compact Hausdorﬀspace has a ﬁxed point.\nThe following is the combination of Proposition 4.2, Proposition 4.3, Theorem 4.5,\nand Theorem 4.7 from [132].\nTheorem 8.2.2 (Kechris, Pestov, Todorcevic [132]). Let B be a homogeneous\nrelational structure, and let G be the topological automorphism group of B. Then the\nfollowing are equivalent.\n(1) The age of B has the Ramsey property, and G preserves a linear order <\non B.\n(2) The age of B only contains rigid structures, and has the Ramsey property.\n(3) (a) For any ﬁnite subset F of B, the substructure induced by F in B is rigid,\nand (b) for all orbits O1, O2 of ﬁnite subsets in B, and for every χ: O1 →[r]\nthere is an i ≤r and an F ∈O2 such that χ(F ′) = i for all F ′ ⊆F where\nF ′ ∈O1.\n(4) For any open subgroup V of G, every χ: G/V →[r], and every ﬁnite\nA ⊆G/V there is g ∈G and 1 ≤i ≤r such that χ(ga) = i for all a ∈A.\n(5) G is extremely amenable.\nFor structures B that are not homogeneous but ω-categorical, the equivalence\nbetween (3), (4), and (5) remains valid, since every ω-categorical structure has a\nhomogeneous expansion by ﬁrst-order deﬁnable relations – and such an expansion\nhas the same automorphism group as B; we can then apply Theorem 8.2.2 to the\nexpansion. It therefore makes sense to call an ω-categorical structure B Ramsey if\nthe age of the expansion of B by all ﬁrst-order deﬁnable relations is Ramsey. There are\nalso interesting applications of Theorem 8.2.2 when B is not ω-categorical, see [132].\nWe point out a remarkable consequence of Theorem 8.2.2 in combination with\nProposition 3.3.8.\nCorollary 8.2.3. Suppose that B is an ω-categorical Ramsey structure where\nall ﬁnite induced substructures are rigid. Then a linear order is ﬁrst-order deﬁnable\nin B.\n\n146\n8. RAMSEY THEORY\nWhen a Ramsey structure B has substructures with non-trivial automorphisms,\nTheorem 8.2.2 is therefore not directly applicable. For the applications of Ramsey\ntheory we have in mind, though, it is suﬃcient to know that B has a ﬁrst-order\ndeﬁnition in an ordered Ramsey structure that is homogeneous in a ﬁnite relational\nsignature (see Section 8.3 and 8.4).\nThe choice of the order is not arbitrary, but plays an important role when we\nwant to preserve the Ramsey property.\nTo give another example, consider again\nthe countable atomless Boolean algebra, which is an example of an ω-categorical\nstructure that is not homogeneous in a ﬁnite relational signature (Corollary 4.5.8).\nIn this case an order expansion with an extremely amenable automorphism group has\nbeen speciﬁed in [132], and can be found below.\nExample 8.2.4. Let B = (B; ⊔, ⊓, c, 0, 1) be a ﬁnite Boolean algebra and A its\nset of atoms (see Example 8.1.5 in Section 4.3). Then every ordering a1 < · · · < an\nof A gives an ordering of B as follows (we follow [132]). For x, y ∈B, we set x < y\nif there exists an i0 ∈{1, . . . , n} such that\n• for all i ∈{1, . . . , i0 −1} we have that ai ⊓x = ai ⊓y, and\n• x ⊓ai0 = 0 and y ∩ai0 ̸= 0.\nSuch an ordering of the elements of B is called a natural ordering. It can be shown that\nthe class C of all naturally ordered ﬁnite atomless Boolean algebras has the Ramsey\nproperty (see the comments preceding Theorem 6.14 in [132], and Proposition 5.6\nin [132]). By Theorem 8.1.10, C is an amalgamation class. The reduct of the Fra¨ıss´e-\nlimit of C with signature {⊔, ⊓, c, 0, 1} is the atomless Boolean algebra (Propositions\n5.2 and 6.13 in [132]), so we indeed found an extremely amenable order expansion of\nthe atomless Boolean algebra.\n□\nThe main focus of the article by Kechris, Pestov, and Todorcevic [132] is the\napplication of Theorem 8.2.2 to prove that certain groups are extremely amenable,\nusing known and deep Ramsey results. Here we are rather interested in the opposite\ndirection: we are applying Theorem 8.2.2 in the following sections to obtain a more\nsystematic understanding of which classes of structures have the Ramsey property.\n8.2.2. Continuous Homomorphisms. Interestingly, whether an ω-categorical\nstructure B is Ramsey only depends on the automorphism group of B viewed as a\ntopological group. For this observation we do not need the full power of Theorem 8.2.2:\nthe equivalence of (1) and (3) suﬃces. More generally, we have the following.\nProposition 8.2.5. Let G be an extremely amenable group, and let H be a Polish\ngroup. If there is a continuous homomorphism ξ : G →H such that ξ(G) is dense in\nH, then H is also extremely amenable.\nProof. Let a: H × S →S be a continuous action of H on a compact Hausdorﬀ\nspace S. Then b: G × S →S given by (g, s) 7→a(ξ(g), s) is a continuous action of\nG on S. Since G is extremely amenable, b has a ﬁxed point s0. Now let h ∈H be\narbitrary. Since ξ(G) is dense in H, there exists a sequence (gi)i≥1 of elements of G\nsuch that limi ξ(gi) converges against h in H. Therefore there exists an i0 such that\nfor all j ≥i0 we have that\na(h, s0) = a(ξ(gj), s0) = b(gj, s0) = s0\nand hence s0 is also a ﬁxed point under a.\n□\nExample 8.2.6. Recall Example 3.1.11, where we introduced an ω-categorical\nstructure A with binary relations and a two-dimensional ﬁrst-order interpretation\n\n8.2. EXTREMELY AMENABLE GROUPS\n147\nover (Q; <) – the corresponding relation algebra is also called Allen’s Interval Algebra\n(see Section 1.5.1).\nIt follows from the proof of Theorem 5.5.23 that A is ﬁrst-order bi-interpretable\nwith (Q; <). Since the automorphism group of (Q; <) is extremely amenable, Theo-\nrem 8.2.2 therefore shows that the automorphism group of A is extremely amenable,\nand that A is Ramsey. Since A is homogeneous, we also have the Ramsey property\nfor the age of A.\n□\nUnfortunately, Theorem 8.2.2 leaves Question 8.1 unresolved. An important vari-\nant of Question 8.1 with a reformulation in terms of topological groups turned out to\nbe false.\nTheorem 8.2.7 (Evans [93]). There exists a closed oligomorphic permutation\ngroup without a closed oligomorphic extremely amenable subgroup. Equivalently, there\nexists an ω-categorical structure without an ordered ω-categorical Ramsey expansion.\n8.2.3. Products. In this section we present an important tool to build new\nextremely amenable groups, Theorem 8.2.8 below.\nRecall the deﬁnition of direct\nproducts of two groups from Section 3.3.4.\nThe direct product of two topological\ngroups G1 and G2 is the direct product of the respective abstract groups, together\nwith the product topology on the group elements.\nTheorem 8.2.8 (Proposition 6.7 in [132]). Let G be a topological group.\n(1) Let N a normal subgroup of G. If both N and G/N are extremely amenable,\nthen so is G.\n(2) When G is a ﬁnite direct product of extremely amenable groups, then G is\nextremely amenable.\nItem (1) has been stated in [132] under the additional assumption that N is\nclosed; however, as we see in the proof, this assumption is not necessary. Item (2)\ncan be generalized to inﬁnite products of groups, but we do not need this here, and\nrefer to [132] instead.\nProof. We ﬁrst show (1). Suppose G acts continuously on a compact Hausdorﬀ\nspace S. Let SN be the subspace of S induced on {x ∈S | h · x = x for all h ∈N},\nwhich is clearly also Hausdorﬀ. Moreover, it is closed. To see this, let x ∈S and\nf ∈N be such that f ·x ̸= x. Then there exists an open set V (x, f) ⊆S that contains\nx such that f · y ̸= y for all y ∈V (x, f). Otherwise, there exists a sequence (xn)n≥1\nwith xn →x such that f(xn) = xn for all n ≥1. But f · x = f · lim xn = lim f · xn =\nlim xn = x, a contradiction. Then S\nf∈N,x∈S V (f, x) deﬁnes the complement of SN\nand is open. So SN is closed, and also compact since S is compact and closed subsets\nof compact spaces are compact.\nAs N is extremely amenable, SN is non-empty. The set SN is preserved by the\naction of G on S: when x ∈SN and g ∈G, then for any h ∈N\nh · (g · x) = hg · x = g · (g−1hg) · x = g · x\n(where the last equality is by normality of N and Proposition 7.2.6), and so g·x ∈SN.\nNow, consider the action of G/N on SN deﬁned by (gN) · x = g · x, which is\nclearly well-deﬁned. To verify continuity of this action with Proposition 7.1.2, let\n(gnN, sn) →(gN, s). Then (gnN) · sn = gn · sn →g · s = (gN)s since the action of G\non S is continuous.\nBy extreme amenability of G/N there is a point p ∈SN such that f · p = p\nfor all f ∈G/N. But then, p is also a ﬁxed point for the action of G on S, since\ng · p = (gN) · p = p for any g ∈G.\n\n148\n8. RAMSEY THEORY\n(2) follows from (1): suppose that G = H1 × H2, and that H1 and H2 are\nextremely amenable. Then H1 is a normal subgroup of G, and G/H1 is isomorphic\nto H2, so G is extremely amenable by (1). The statement for H1 × · · · × Hn follows\nby induction on n.\n□\nWhen we later apply Ramsey theory to analyze polymorphism clones in Sec-\ntion 8.3 of this chapter, and when the polymorphisms are higher-ary, it will be crucial\nto apply the so-called product Ramsey theorem. For every ordered Ramsey class there\nis a corresponding product Ramsey theorem (which usually has various slightly dif-\nferent formulations). This can be shown either directly, or by applying the general\nresults from topological dynamics.\nFor illustration, we give a direct proof for the class of all ﬁnite linear orders\n(Theorem 8.2.9, which will be used extensively for d = m = 2 in Chapter 10). For\nconcreteness, we give specialized terminology in this case. If S1, . . . , Sd are sets, we\ncall a set of the form S1 × · · · × Sd a grid, and also write Sd for a product of the\nform S × · · · × S with d factors. A [k]d-subgrid of a grid S1 × · · · × Sd is a subset of\nS1 × · · · × Sd of the form S′\n1 × · · · × S′\nd, where S′\ni is a k-element subset of Si.\nTheorem 8.2.9 (Product Ramsey Theorem). For all positive integers d, r, m,\nand k ≥m, there is a positive integer L = R(d, r, m, k) such that for every coloring\nof the [m]d subgrids of [L]d with r colors there exists a monochromatic [k]d subgrid G\nof [L]d, i.e., G is such that all its [m]d subgrids have the same color.\nProof. Let d, r, m, and k ≥m be positive integers. We claim that we can\nchoose L = R(d, r, m, k) to be R(r, dm, dk). To verify this, let χ be a coloring of the\n[m]d subgrids of [L]d with r colors. We have to ﬁnd a monochromatic subgrid of [L]d.\nWe use χ to deﬁne an r-coloring ξ of the dm-subsets of [L] as follows.\nLet\nS = {s1, s2, . . . , sdm} be a dm-subset of [L], with s1 < s2 < · · · < sdm. Then deﬁne\nξ(S) = χ({s1, . . . , sm} × · · · × {sm(d−1)+1, . . . , sdm}) .\nBy Theorem 8.1.2, there is a dk-subset {t1, t2, . . . , tdk} of [L] such that ξ is constant\non the dm-element subsets of {t1, . . . , tdk}. Suppose that t1 < t2 < · · · < tdk. Then\nG = {t1, . . . , tk}×· · ·×{tk(d−1)+1, . . . , tdk} is a subgrid of [L]d that is monochromatic\nwith respect to χ.\n□\nWe next present a formulation of the product Ramsey theorem for arbitrary\nordered Ramsey structures. The proof uses Theorem 8.2.2 and Theorem 8.2.8.\nTheorem 8.2.10. Let B1, . . . , Bd be ω-categorical ordered Ramsey structures.\nThen P := B1 ⊠· · · ⊠Bd is Ramsey.\nProof. By Theorem 8.2.2, the automorphism groups G1, . . . , Gd of B1, . . . , Bd\nare extremely amenable, and it suﬃces to show that the automorphism group G of P\nis extremely amenable. The group G is given by the product action of G1 × · · · × Gd\non B1, . . . , Bd (see Section 3.3.4.3). Hence, extreme amenability of G follows from\nTheorem 8.2.8.\n□\nTheorem 8.2.10 indeed generalizes Theorem 8.2.9, which can be seen as follows.\nLet r, d, m, k be positive integers.\nWe consider the ω-categorical ordered Ramsey\nstructure (Q; <), and apply Theorem 8.2.10 where d in Theorem 8.2.10 equals the\nd given above. Let A be the structure induced in P := (Q; <)[d] by some (equiva-\nlently, every) [m]d subgrid of Qd, and let B be the structure induced in P by some\n(equivalently, every) [k]d subgrid of Qd. Since C is Ramsey, there exists an induced\nsubstructure C of P such that C →(B)A\nr . If C is not induced by an [L]d subgrid of\nQd, for some large enough L, we can clearly choose a larger substructure C with this\n\n8.2. EXTREMELY AMENABLE GROUPS\n149\nproperty, such that still C →(B)A\nr . The occurrences of A in C correspond precisely\nto the [m]d-subgrids of [L]d, which proves the claim.\n8.2.4. Open Subgroups. In this section we show that open subgoups of ex-\ntremely amenable groups are again extremely amenable. This fact will be important\nin Section 8.3.4 and 8.4 when it comes to the applications for analyzing polymorphism\nclones. We ﬁrst show the following basic fact.\nProposition 8.2.11. Let X be a topological space, and Y be any set. Let G be a\ntopological group that acts on XY . Then the action is continuous if for every y ∈Y ,\nthe map fy : G × XY →X given by fy(g, ξ) := (g · ξ)(y) is continuous.\nProof. Suppose that limn→∞(gn, ξn) = (g, ξ). Then by Proposition 7.1.3 we\nhave limn→∞gn = g and limn→∞ξn(y) = ξ(y) for all y ∈Y . Since fy is continuous\nand by Proposition 7.1.2\nlim\nn→∞(gn · ξn)(y) = lim\nn→∞fy(gn, ξn) = fy(g, ξ) = (g · ξ)(y)\nfor all y ∈Y . We again apply Proposition 7.1.3 and obtain that limn→∞(gn·xn) = g·ξ,\nwhich implies continuity of the action of G, again using Proposition 7.1.2.\n□\nProposition 8.2.12 (from [54]). Let G be an extremely amenable group, and let\nH be an open subgroup of G. Then H is also extremely amenable.\nIn the proof, it is not essential but technically more convenient to use right cosets\ninstead of left cosets.\nProof. Let H act continuously on a compact space X; we will show that this\naction has a ﬁxed point. Denote by π: G →H\\G the quotient map and let s: H\\G →\nG be a section for π (i.e., a mapping satisfying π ◦s = id) such that s(H) = 1. Let\nα be the map from H\\G × G →H deﬁned by\nα(w, g) = s(w)gs(wg)−1 .\nFor w ∈H\\G and g ∈G, note that s(w)g and s(wg) lie in the same right coset of\nH, namely wg, and hence the image of α is H. The map α satisﬁes\nα(w, g1g2) = s(w)g1g2(s(wg1g2))−1\n= s(w)g1s(wg1)s(wg1)−1g2(s(wg1g2))−1\n= α(w, g1)α(wg1, g2) .\nAs H is open, H\\G is discrete. Hence, s is continuous, and therefore α is contin-\nuous as a composition of continuous maps.\nNow consider the product space XH\\G which is Hausdorﬀand compact by The-\norem 7.1.5. The co-induced action of G on XH\\G is deﬁned by\n(g · ξ)(w) = α(w, g) · ξ(wg).\nWe claim that this action is continuous. By Proposition 8.2.11, it suﬃces to verify\nthat the map (g, ξ) 7→(g · ξ)(w) is a continuous map from G × XH\\G →X for\nevery ﬁxed w ∈H\\G. We already know that α is continuous and that the action\nof H on X is continuous. To see that (g, ξ) 7→ξ(wg) is continuous, suppose that\nlimn→∞(gn, ξn) = (g, ξ). Let w = Hk. As limn→∞gn = g and k−1Hk is open, we\nwill have that eventually gng−1 ∈k−1Hk, giving that kgn(kg)−1 ∈H, or, which is\nthe same, Hkgn = Hkg. We obtain that for suﬃciently large n, wgn = wg. Therefore\nlimn→∞ξn(wgn) = ξ(wg).\n\n150\n8. RAMSEY THEORY\nBy the extreme amenability of G, the co-induced action has a ﬁxed point ξ0.\nNow we check that ξ0(H) ∈X is a ﬁxed point of the action H ↷X. Indeed, for any\nh ∈H, h · ξ0 = ξ0 and we have\nξ0(H) =(h · ξ0)(H)\n=α(H, h) · ξ0(Hh)\n=s(H)hs(Hh)−1ξ0(H)\n=h · ξ0(H),\nﬁnishing the proof.\n□\nProposition 8.2.12 can be applied to provide a short and elegant proof of the\nfollowing.\nCorollary 8.2.13 (from [54]). Let B be ordered homogeneous Ramsey, and let\nc1, . . . , cn be elements of B. Then (B, c1, . . . , cn) is ordered homogeneous Ramsey\nas well.\nProof. It is easy to see that the expansion of any homogeneous structure B by\nﬁnitely many constants is again homogeneous. When B is additionally ordered Ram-\nsey, then Aut(B) is extremely amenable. The automorphism group of (B, c1, . . . , cn)\nis an open subgroup of Aut(B). The statement thus follows directly from Proposi-\ntion 8.2.12 and Theorem 8.2.2.\n□\nNote that in order to preserve homogeneity, we have to add constants c as unary\nfunction symbols, and not as unary singleton relations {c}. Consider for example the\nhomogeneous structure (V; E), and let u ∈V (see Example 3.2.6). Then (V; E, {u})\nis not homogeneous, since there are no automorphisms that map neighbours of u to\nnon-neighbours.\n8.3. Canonization\nIn this section we apply Ramsey theory to analyse endomorphism monoids and\npolymorphism clones of Ramsey structures B. The central idea is that for arbitrary\nﬁnite substructures C of B, any mapping from Bk →B must ‘behave canonically’ on\na copy of C in B. We ﬁrst consider the more general case of functions between two\npossibly distinct structures, and introduce a reﬁnement of the notion of canonicity\nfrom Section 5.6.2.\nDefinition 8.3.1. Let C be a structure with domain C, and S a subset of C. Let\nB be a structure with domain B, and let f : C →B be a function. We say that f\nis canonical on S as a map from C to B if for all n and every n-tuple t over S the\nn-type of f(t) in B only depends on the n-type of t in C.\nThe basic lemma to apply Ramsey theory in the analysis of functions is the\nfollowing.\nLemma 8.3.2. Let C be an ω-categorical ordered Ramsey structure with domain\nC and ﬁnite relational signature τ, let B be an ω-categorical structure with domain\nB, and let f : C →B be an operation. Then for all ﬁnite subsets S of C there is an\nautomorphism α of C so that the operation x 7→f(αx) is canonical on S as a map\nfrom C to B.\nProof. Let m be the maximal arity of the relations in τ, and < be the linear\norder in the signature of C. Let C′ be the homogeneous ω-categorical expansion of C\nby all relations that are ﬁrst-order deﬁnable in C. Then the age of C′ is a Ramsey\nclass. Let S be the substructure induced by S in C′, and n := |S|.\n\n8.3. CANONIZATION\n151\nWhen A is a substructure of C′ of size m, then aA is the tuple (a1, . . . , am) such\nthat {a1, . . . , am} are the elements of A and t1 < · · · < tm.\nLet A1, . . . , Ak be a list all non-isomorphic substructures of S of cardinality m.\nSince C′ is Ramsey, there is a substructure C1 of C′ such that C1 →(S)A1\nr . Further,\nthere is a substructure C2 of C′ such that C2 →(C1)A2\nr . We iterate this k times,\narriving at a structure Ck. For each i ≤k, the operation f deﬁnes a coloring χi of\n\u0000Ck\nAi\n\u0001\nwith ﬁnitely many colors as follows: the color of a copy A of Ai is just the type\nof f(aA) in B; since B is ω-categorical, the number r of m-types in B is ﬁnite.\nNow going back the argument, we ﬁnd that Ck contains a copy of S on which all\ncolorings χ1, . . . , χk are constant. Since C′ is homogeneous, there exists an automor-\nphism α of C′ that sends S to this copy. Then x 7→f(αx) is canonical on S as a map\nfrom C to B.\n□\nNote that the assumption that B is ordered is necessary in Lemma 8.3.2: for\ninstance, if f is an injective function from X →(Q; <), then f is not canonical as a\nmap from (X; =) to (Q; <) on any two-element subset of X.\n8.3.1. Multivariate functions. The appropriate generalisation of canonicity\nfor multivariate functions is the following.\nDefinition 8.3.3. Let B be a structure with domain B, and C a structure with\ndomain C. When f : Cd →B is a function, and S is a subset of Cd we say that f\nis canonical on S if for all n and all n-tuples t1, . . . , td where (t1\ni , . . . , td\ni ) ∈S for all\ni ≤n the n-type of f(t1, . . . , td) in B only depends on the n-types of t1, . . . , td in C.\nWe say that f is canonical (as a d-ary map from C to B) if f is canonical on Bd.\nWhen B = C in the deﬁnition above, we say that f is canonical on B when it is\ncanonical as a d-ary map from B to B.\nExample 8.3.4. Let lex be a binary operation on Q such that lex(a, b) < lex(a′, b′)\nif either a < a′, or a = a′ and b < b′. Clearly, such an operation exists. Note that lex\nis injective, that it preserves <, and that it is canonical as a binary polymorphism of\n(Q; <).\nIn the proof of the following we use the product Ramsey theorem, Theorem 8.2.10.\nTheorem 8.3.5. Let B be an ω-categorical ordered Ramsey structure with ﬁnite\nrelational signature and domain B, and let f : Bd →B be any operation. Then for\nall ﬁnite subsets S1, . . . , Sd of B there are automorphisms α1, . . . , αd of B so that the\noperation (x1, . . . , xd) 7→f(α1x1, . . . , αdxd) is canonical on S1 × · · · × Sd.\nProof. By Theorem 8.2.10, the structure B[d] is Ramsey. Hence, Lemma 8.3.2\nshows the existence of an automorphism α of B[d] such that x 7→f(αx) is canonical\non S1 × · · · × Sd as a map from B[d] to B.\nLet G be the topological automorphism group of B. Since the automorphism\ngroup of B[d] is induced by the product action of Gk on Bk, there are group elements\na1, . . . , ad of G so that α(x1, . . . , xd)) = (α1x1, . . . , αdxd). Now clearly the function\n(x1, . . . , xd) 7→f(α1x1, . . . , αdxd) is canonical on S1 × · · · × Sd as a multivariate\nfunction on B.\n□\n8.3.2. Interpolation modulo automorphisms. One of the central questions\nwhen analysing a polymorphism of a structure B is to ﬁnd out what functions it\ngenerates (since those functions will also be polymorphisms of B, see Section 5.2).\nTheorem 8.3.5 can be used for this purpose; to illustrate this, we present the following.\n\n152\n8. RAMSEY THEORY\nCorollary 8.3.6. Let B be an ω-categorical ordered Ramsey structure with ﬁnite\nrelational signature. Then every injective operation f : Bk →B together with the\nautomorphisms of B locally generates a canonical injective operation g.\nThis corollary follows in a straightforward way from Theorem 8.3.5 and a com-\npactness argument, which we do not present here since we will present a proper\ngeneralisation of it in full detail, Theorem 8.3.8.\nNote that when we drop the injectivity assumption for f in the statement of\nCorollary 8.3.6 then the statement of the corollary becomes trivially true, since every\noperation locally generates the projections, which are canonical on the entire domain.\nWe therefore need a concept that is weaker than local closure, but stronger than\ninterpolation, to turn the idea of Corollary 8.3.6 into a meaningful statement for all\nfunctions from Bk to B.\nDefinition 8.3.7. Let B be an ω-categorical structure with domain B, and\nf, g: Bd →B be functions.\nThen f interpolates g modulo automorphisms of B\nif for every ﬁnite S ⊆B there are automorphisms α0, α1, . . . , αd of B such that\ng(x1, . . . , xd) = α0(f(α1x1, . . . , αdxd)).\nTheorem 8.3.8. Let B be an ordered ω-categorical Ramsey structure with ﬁnite\nrelational signature and domain B, and f : Bd →B any operation. Then there is a\ncanonical operation g: Bd →B that is interpolated by f modulo automorphisms.\nTheorem 8.3.8 is still not in its most general and most useful form. For this, we\nneed a further generalisation of the notion of interpolation modulo automorphisms to\nthe situation where f is a function from a structure C to a diﬀerent structure B.\nDefinition 8.3.9. Let B, C be structures with domains B and C, and let f, g: C →\nB be functions. Then f interpolates g modulo automorphisms of C if for every ﬁnite\nS ⊆C there is an α ∈Aut(C) and a β ∈Aut(B) such that g(x) = β(f(αx)).\nThe following is the central statement about Ramsey structures and interpolation\nmodulo automorphisms.\nTheorem 8.3.10. Let C be ω-categorical ordered Ramsey with ﬁnite relational\nsignature and domain C, and let B be ω-categorical with domain B.\nThen every\nf : C →B interpolates a canonical operation g: C →B modulo automorphisms of C.\nProof. By Lemma 3.1.8, it suﬃces to show that for every ﬁnite subset C′ of C\nthere is a function from C →B that is canonical on C′ and interpolated by f modulo\nautomorphisms of C, since the property to be canonical on C′ is a universal ﬁrst-order\nstatement about f. This follows from Lemma 8.3.2.\n□\nProof of Theorem 8.3.8. We apply Theorem 8.3.10 to the structure C :=\nB[d], expanded by the ﬁrst-order deﬁnable lexicogrpahic ordering on B[d], which is\nRamsey when B is Ramsey, by Theorem 8.2.10. As in the proof of Theorem 8.3.5,\ncanonicity of a function g from B[d] to B translate into canonicity of g as a d-ary\nfunction on B, and interpolation operations modulo automorphisms of B[d] and B\ncorresponds to interpolation of d-ary functions modulo automorphisms of B.\n□\nNote that Theorem 8.3.8 is indeed a generalization of Corollary 8.3.6, since clearly\noperations that are interpolated by injective operations modulo automorphisms are\nagain injective.\n‘Canonization’ of operations as exhibited in Theorem 8.3.10 becomes particularly\npowerful when we combine it with expansions by constants. The following theorem\nhas numerous applications.\n\n8.3. CANONIZATION\n153\nTheorem 8.3.11 (fom [54]). Let B be an ω-categorical ordered Ramsey structure\nwith domain B and ﬁnite relational signature. Let c1, . . . , cm ∈B, and let f : Bk →B\nbe any function. Then {f} ∪Aut(B) locally generates a function which is canonical\nas a function from (B, c1, . . . , cm)k to B, and which equals f on all tuples containing\nonly values ci.\nProof. By Corollary 8.2.13, also the structure (B, c1, . . . , cm) is ordered Ram-\nsey. By Theorem 8.2.10, the structure C := (B, c1, . . . , cm)[k] is ordered Ramsey (and\nstill ω-categorical). Let d1, . . . , dn be an enumeration of the image of the restriction\nof f to {c1, . . . , cm}. The structure (B, d1, . . . , dn) is still ω-categorical. Then Theo-\nrem 8.3.10 shows that f interpolates modulo automorphisms of C and (B, d1, . . . , dn)\nan operation which is canonical as a function to (B, d1, . . . , dn) and therefore also\nas a function to B. In particular, g is locally generated by {f} ∪Aut(B), and the\nrestrictions of f and g to {c1, . . . , cm} are equal.\n□\n8.3.3. Behavior of Operations. It is sometimes important to work with op-\nerations that exhibit a ‘behavior’ that is only partially canonical.\nThe following\ndeﬁnition from [50] gives us some ﬂexibility in specifying such functions.\nDefinition 8.3.12. Let C and B be structures with domains C and B, and let\nk ≥1. An (n-)type condition between C and B is a k + 1-tuple (t1, . . . , td, s), where\neach ti is an n-type in C, and s is an n-type in B. A d-ary function f : Cd →B\nsatisﬁes an n-type condition (t1, . . . , td, s) on S ⊆Cd if for all n-tuples ai of type ti\nin C with (ai\n1, . . . , ai\nd) ∈S for all i ≤d, the n-tuple (f(a1\n1, . . . , ad\n1), . . . , f(a1\nn, . . . , ad\nn))\nis of type s in B.\nA behavior between two structures C and B is a set Λ of type conditions.\nA\nfunction f : Cd →B has behavior Λ on S ⊆Cd if it satisﬁes all the type conditions\nof Λ on S. We say that f has behavior Λ if it has behavior Λ on all of Cd.\nNote that a d-ary operation f : Cd →B is canonical if for all n ≥1 and all\nd-tuples (t1, . . . , td) of types of n-tuples in C there exists a type s of an n-tuple in\nB such that f satisﬁes the type condition (t1, . . . , td, s). When B is homogeneous\nin a relational signature with maximal arity n, then already the n-type conditions\ndetermine the behavior of functions over B.\nWhen B is ω-categorical then the clone generated by Aut(B) and a canonical\nd-ary function f over B is completely described by the behavior of f. In fact, when\nf, g: Bd →B are functions with the same behavior, then {f} ∪Aut(B) generates g,\nand {g} ∪Aut(B) generates f, by local closure.\nLemma 8.3.13. Let B be ordered ω-categorical with domain B. Let Λ be a be-\nhaviour for functions from Bk to B, and let g: Bk →B be arbitrary. If for every\nﬁnite substructure A of B there are copies A1, . . . , Ak of A in B such that g has\nbehavior Λ on A1 × · · · × Ak then {g} ∪Aut(B) locally generates a function f of\nbehaviour Λ.\nProof. A direct consequence of Lemma 3.1.8.\n□\nAn orbit of (B, c1, . . . , cm) is called full if it contains copies of all ﬁnite substruc-\ntures of B. The following follows from Lemma 8.3.13. As we will see in Chapter 9\nand Chapter 10, it becomes important in the context of canonization after expansions\nby constants (Theorem 8.3.11).\nLemma 8.3.14. Let B be ω-categorical, and let c1, . . . , cm be elements from B.\nWhen A is the substructure induced in B by a full orbit O of (B, c1, . . . , cm), and f\nis a function from (B, c1, . . . , cm)k to B with behaviour Λ on O, then {f} ∪Aut(B)\nlocally generates a function from Bk to B with behaviour Λ.\n\n154\n8. RAMSEY THEORY\n2\n3\n1\n4\n2\n3\n1\n4\n2\n3\n1\n4\n2\n3\n1\n4\n2\n3\n1\n4\n2\n3\n1\n4\n2\n3\n1\n4\n2\n3\n1\n4\nFigure 8.1. Canonical behavior on [2]2 grids.\n2\n3\n1\n4\n2\n3\n1\n4\n2\n3\n1\n4\n2\n3\n1\n4\nFigure 8.2. When f is a canonical binary injective polymorphism\nof (Q; <), then there is one linear order of a [2]2 grid as depicted here\nsuch that all [2]2 subgrids of Q2 are linearly ordered in this way.\nNot every behavior Λ between C and B is realized by a function in the sense\nthat there exists a function from C →B that has behavior Λ. We give an example.\nThere are eight distinct candidates for canonical behavior of injective maps from\n(Q; <)2 to (Q; <); they are illustrated in Figure 8.1. However, only four of those\ncanonical behaviors are realized by binary injective polymorphisms of (Q; <); those\nare illustrated in Figure 8.2. The others would imply the existence of three points\nx, y, z in the image such that x < y and y < z and z < x, which is impossible over\n(Q; <). The not necessarily injective case can be analyzed similarly, and we get the\nfollowing.\nLemma 8.3.15. Let f be a canonical binary polymorphism of (Q; <). Then f has\nthe same behavior as one out of the following seven operations.\n• lex(x, y) or lex(y, x);\n• lex(x, −y) or lex(y, −x).\n• (x, y) 7→x or (x, y) 7→y.\n• a constant operation\nTogether with Corollary 8.3.6, we ﬁnd that every binary injective polymorphism\nof (Q; <) locally generates lex(x, y), lex(y, x), lex(x, −y), or lex(y, −x).\n8.3.4. Canonical Violation. Let C be an ω-categorical ordered Ramsey struc-\nture, and let B be a structure with a ﬁrst-order deﬁnition in C.\nSuppose that a\nrelation R does not have a primitive positive deﬁnition in B. We wish to show that\nthen there exists a polymorphism of B that violates R and is canonical as a func-\ntion over C.\nBoldly stated like this, this cannot hold true.\nHowever, the results\nfrom Section 8.2.4 show us how to ﬁx the statement. To illustrate the basic idea, we\nﬁrst discuss the unary case, with existential positive deﬁnability instead of primitive\npositive deﬁnability.\n\n8.3. CANONIZATION\n155\nTheorem 8.3.16. Let C be an ω-categorical ordered Ramsey structure, and let B\nbe a structure with a ﬁrst-order deﬁnition in C. Suppose that the k-ary relation R does\nnot have an existential positive deﬁnition in B. Then there exists an endomorphism\ne of B and a k-tuple t = (t1, . . . , tk) ∈R such that\n• e(t) /∈R\n• e is canonical as a map from (C, t1, . . . , tk) to C.\nProof. The structure B is ω-categorical.\nIf R does not have an existential\ndeﬁnition, then by Theorem 3.4.7 there is an endomorphism e′ of B which violates R,\nthat is, there is a k-tuple t = (t1, . . . , tk) ∈R such that e′(t) /∈R. By Theorem 8.3.11,\n{e′} ∪Aut(B) locally generates an operation e that is canonical as a function from\n(B, t1, . . . , tk) to B that has the same restriction to {t1, . . . , tk} as e′, and e has the\nrequired properties from the statement of the theorem.\n□\nHere comes the multivariate analog of Theorem 8.3.16, whose proof is analogous\nto the proof of the previous theorem.\nTheorem 8.3.17. Let C be an ω-categorical ordered Ramsey structure, let B be a\nstructure with a ﬁrst-order deﬁnition in C, and suppose that the k-ary relation R does\nnot have a primitive positive deﬁnition in B. Then there exists a ﬁnite d, a d-ary\npolymorphism f of B, and k-tuples t1, . . . , td ∈R such that\n• f(t1, . . . , td) /∈R\n• f is canonical as a map from (C, t1) ⊠· · · ⊠(C, td) to C.\nProof. If R does not have a primitive positive deﬁnition in B, then since B\nis ω-categorical, by Theorem 5.2.3 there is a polymorphism f ′ of B which violates\nR.\nBy Lemma 5.3.5, we can assume that the arity of f ′ equals the number d of\norbits of k-tuples contained in R, which is bounded by oB(k). So there are k-tuples\nt1, . . . , td ∈R such that f ′(t1, . . . , tm) /∈R. By Corollary 8.2.13, for all i ≤d the\nstructure (C, ti) is Ramsey, and by Theorem 8.2.10 the structure (C, t1) ⊠· · · ⊠(C, td)\nis Ramsey. Then Theorem 8.3.10 shows that f ′ interpolates modulo automorphisms\nof (C, t1) ⊠· · · ⊠(C, td) a canonical operation f, and f(t1, . . . , td) = f ′(t1, . . . , td) /∈\nR. Since f is in particular locally generated by polymorphisms of B, it is itself an\npolymorphism of B.\n□\nWe are now in the situation to prove the following, which has been announced\nalready in Section 5.3.5.\nTheorem 8.3.18 (from [54]). Let B be a structure with ﬁnite relational signature,\nand with a ﬁrst-order deﬁnition in an ordered homogeneous Ramsey structure C with a\nrelational signature of maximal arity k. Then there are ﬁnitely many minimal closed\nclones above Pol(B).\nProof. Every minimal closed clone above Pol(B) is locally generated by a mini-\nmal operation f (Proposition 5.3.14), and by Theorem 5.2.4 there must be a relation R\nin B that is violated by f, that is, there are t1, . . . , td ∈R such that f(t1, . . . , td) /∈R.\nSince f is a minimal operation, Theorem 8.3.17 implies that f must be canonical as a\nmap from (C, t1) ⊠· · · ⊠(C, td) →C. But since C is homogeneous is a ﬁnite relational\nsignature, and B has ﬁnite relational signature, there are only ﬁnitely many canonical\nbehaviors of such operations; since two minimal operations with the same behavior\nlocally generate the same closed clone above Pol(B), we are done.\n□\n\n156\n8. RAMSEY THEORY\n8.4. Decidability Results for Meta-Problems\nWe turn to another application of the ideas of the previous sections. For a ﬁxed\nstructure C with a ﬁnite relational signature τ and domain C, consider the following\ncomputational problem.\nExpr-fo(C)\nINSTANCE: Quantiﬁer-free ﬁrst-order τ-formulas φ0, . . . , φn deﬁning the relations\nR0, . . . , Rn over C.\nQUESTION: Is there a ﬁrst-order deﬁnition of R0 in (C; R1, . . . , Rn)?\nWe are also interested in the variants of this problem where we replace ﬁrst-order\ndeﬁnability by other syntactically restricted versions of deﬁnability, in particular by\nprimitive positive deﬁnability. The corresponding computational problem for prim-\nitive positive deﬁnability is denoted by Expr-pp(C) (and the problem for existential\nand existential positive deﬁnability by Expr-ex(C) and Expr-ep(C), respectively).\nFor ﬁnite structures C the problem Expr-pp(C) is in co-NEXPTIME (and in\nparticular decidable).\nFor the variant where the ﬁnite structure Γ is part of the\ninput, the problem has recently shown to be also co-NEXPTIME-hard [196]. An\nalgorithm for Expr-pp(C) has theoretical and practical consequences in the study of\nthe computational complexity of CSPs for structures that are ﬁrst-order deﬁnable in\nC, as illustrated in the following examples.\nExample 8.4.1. We can use an algorithm for Expr-pp(C) to decide whether all\npolymorphisms of a structure (C; R1, . . . , Rn), given by τ-formulas φ1, . . . , φn that de-\nﬁne R1, . . . , Rn over C, are essentially unary. For that, we simply apply the algorithm\nto x ̸= y ∨y ̸= z, φ1, . . . , φn, for each i; here we use Proposition 5.3.3.\nExample 8.4.2. To decide whether a structure (C; R1, . . . , Rn), again given by\nτ-formulas φ1, . . . , φn that deﬁne R1, . . . , Rn over C, is a core, we apply the algorithm\nfor Expr-pp(C) to ¬φi, φ1, . . . , φn, for each i. Additionally, we apply the algorithm to\nx ̸= y, φ1, . . . , φn. The structure (C; R1, . . . , Rn) is a core if and only if none of those\ncalls reports false, that is, all the relations deﬁned by ¬φi or by x ̸= y are primitive\npositive deﬁnable in (C; R1, . . . , Rn).\nExample 8.4.3. We can use an algorithm for Expr-pp(C) to eﬀectively test the\nhardness condition for CSP(B) given in Proposition 5.5.9 for structures B with a\nﬁrst-order deﬁnition in C and a ﬁnite relational signature.\nThe main result of this section is the decidability of Expr-pp(C) for a certain class\nof structures C. Even for the simplest of countable structures, namely the structure\n(X; =) having no relations but equality, the decidability of Expr-pp(Γ) is not obvious\n(see [30]). Recall the concept of ﬁnitely bounded structures C (Deﬁnition 3.2.8): we\nrequire that the age of C is given by a ﬁnite set of ﬁnite forbidden induced substruc-\ntures.\nTheorem 8.4.4 (from [54]). Let C be of ﬁnite relational signature, and ﬁrst-order\ndeﬁnable over a structure D which is homogeneous, ordered, Ramsey, ﬁnitely bounded,\nand with ﬁnite relational signature. Then Expr-pp(C) is decidable.\nProof. Let D be the domain of D and C.\nThe input consists of formulas\nφ0, φ1, . . . , φk in the signature of C. Those formulas deﬁne the relations R0, R1, . . . , Rk\nover C. Set B to be the structure (D; R1, . . . , Rk). We will decide whether there is\na primitive positive deﬁnition of R0 in B. We can without loss of generality assume\nthat in each formula φ0, . . . , φk, the variables are called x1, . . . , xp, for some p.\n\n8.4. DECIDABILITY RESULTS FOR META-PROBLEMS\n157\nBy Theorem 8.3.17, if R0 is m-ary and does not have a primitive positive def-\ninition in B, then there exists a ﬁnite d, a d-ary polymorphism f of B, and m-\ntuples t1, . . . , td ∈R0 such that f(t1, . . . , td) /∈R0, and f is canonical as a map from\n(D, t1) ⊠· · · ⊠(D, td) to D. Such a polymorphism of B will be called a witness at\nt1, . . . , td (for the fact that R0 is not primitive positive deﬁnable in B). The question\nwhether such a witness exists for a speciﬁc choice of tuples t1, . . . , td does of course\nonly depend on the orbits of t1, . . . , td in D, and by ω-categoricity of D there are only\nﬁnitely many such orbits. Moreover, by homogeneity of D, the orbits of n-tuples are\nin one-to-one correspondence to the n-element induced substructures of D, which can\nbe eﬀectively stored and enumerated on a computer. So it suﬃces in the following\nto consider the case where t1, . . . , td are ﬁxed, and to show how to decide whether a\nwitness exists at this choice of t1, . . . , td.\nSince expansions of homogeneous structures by ﬁnitely many constants are homo-\ngeneous, the one-to-one correspondence between orbits of l-tuples, maximal l-types,\nand induced l-element substructures of D extends to the structures (D, ti). In the\nfollowing, let n be max(3, n′ + 1) where n′ is the maximal arity of the relations in D.\nThen by homogeneity of D the behavior of f is determined by the n-type conditions\nthat are satisﬁed by f (for this property we only need that n ≥n′; the requirement\nn ≥3 is motivated by the way how we treat equality in our approach, as we will see\nlater). When f is canonical, then the set Λ of n-type conditions can be viewed as\na function from S(D,t1)\nn\n× · · · × S(D,td)\nn\nto SD\nn . By ω-categoricity of D and of (D, ti)\nthere are only ﬁnitely many such functions Λ.\nWe decide the existence of a witness by reduction to a ﬁnite-domain constraint\nsatisfaction problem. The domain of the CSP is the set of all n-types of D. The\ninstance of the CSP has a variable for every d-tuple (S1, . . . , Sd) where Si is an n-\ntype of (D, ti); in fact, we identify the variables of the instance and those d-tuples of\nn-types. The constraints are described below. The idea is that the solutions to this\nCSP are exactly the functions Λ for witnesses as described above.\nTo implement this in detail, it will be convenient to make the assumption that\nN is minimal in the sense that it does not contain structures A1, A2 such that A1\nis an induced substructure of A2; this assumption is without loss of generality since\notherwise we remove A2 from N, and ﬁnd that the resulting set of structures still\nbounds D.\n• (Compatibility.) Note that every behavior of a witness must have an ex-\ntension to a function from S(D,t1)\nl\n× · · · × S(D,td)\nl\nto SD\nl , for all 1 ≤l ≤n.\nHence, when (S1, . . . , Sd), (T1, . . . , Td) ∈S(D,t1)\nn\n× · · · × S(D,td)\nn\n, and I ⊂[n],\nand if for all i ≤d the subtype of Si induced by I and the subtype of Ti\ninduced by I coincide, then we impose the binary constraint that I induces\nthe same subtype in Λ(S1, . . . , Sd) ∈SD\nn and in Λ(T1, . . . , Td) ∈SD\nn .\n• (Realizability.)\nWe also want to make sure that the behavior Λ can be\nrealized by an operation (recall the example given in Section 8.3.3). The idea\nis that when D is ﬁnitely bounded, then Λ should not force the existence of\none of the forbidden substructures in the image, since in this case it would\nbe impossible to ﬁnd an operation with image in D whose behavior is Λ. As\nwe will see, it suﬃces here to consider structures A ∈N whose number of\nelements s exceeds n.\nFor each structure A ∈N with s > n elements and each sequence\nS1, . . . , Sd with Si ∈S(D;ti)\ns\nfor all i ≤d we have a constraint of arity\nr :=\n\u0000s\nn\n\u0001\n.\nLet a1, . . . , as be the elements of A.\nObserve that for every\nsubset I ⊆[s] with |I| = n the structure induced by {ai | i ∈I} in A is an\n\n158\n8. RAMSEY THEORY\ninduced substructure of D, by the minimality assumption on N. Let φA[I]\nbe the formula with variables x1, . . . , xn that contains for i1, . . . , im ∈I\nthe conjunct R(xi1, . . . , xim) if and only if (ai1, . . . , aim) ∈RA.\nBy the\nobservation we just made, φA[I] is contained in a unique n-type of D.\nThe constraint of arity r requires that for some I ⊆[s] with |I| = n the\nsubtype of Λ(S1, . . . , Sd) induced by I does not contain φA[I].\n• (Violation.) We want that Λ is the behavior of an operation that violates the\nm-ary relation R0. For simplicity of presentation, we assume that m ≥n;\nthis is without loss of generality, since we can otherwise add dummy variables\nto φ0.\nFor t = (t1, . . . , tm) and i1, . . . , in ∈[m] with i1 < · · · < in, denote by\nt[{i1, . . . , in}] the tuple (ti1, . . . , tin). When I ⊆[m] we denote by φ0[I] the\nsubtype of {φ0} induced by I; here, {φ0} is viewed as a type over the empty\ntheory. We add the\n\u0000m\nn\n\u0001\n-ary constraint that for some I ⊂[m] of cardinality\nn the type Λ(tp(D,t1)(ti[I]), . . . , tp(D,td)(ti[I])) does not contain φ0[I].\n• (Preservation.) We also want that Λ is the behavior of an operation that\npreserves B. Let j ≤k, and suppose that the relation Rj of B deﬁned by φj\nis p-ary. For simplicity of presentation, we assume that p ≥n, otherwise we\nadd dummy arguments to Rj. For every list S1, . . . , Sd such that Si ∈S(D,ti)\np\ncontains φj for all i ≤d, we impose the following constraint of arity q =\n\u0000p\nn\n\u0001\n.\nFor all I ⊆[p] with |I| = n, let SI\ni be the subtype of Si induced by I, and\nlet SI\n0 be the subtype of {φj} (of the empty theory) induced by I. We add\nthe constraint that Λ(SI\n1, . . . , SI\nd) contains SI\n0 for all I ⊆[p].\nWe now prove that there is a witness f at t1, . . . , td for the fact that R0 is not\nprimitive positive deﬁnable in B if and only if the described CSP instance has a\nsatisfying assignment, which concludes the proof. For the easy direction, suppose\nthat there exists such a witness, and let Λ be its behavior. Then Λ clearly satisﬁes\ncompatibility, realizability, violation, and preservation constraints.\nFor the opposite direction, suppose that α is a solution to the described CSP, i.e.,\na mapping from S(D,t1)\nn\n× · · · × S(D,td)\nn\nto SD\nn that satisﬁes compatibility, realizability,\nviolation and preservation constraints.\nWe show the existence of a witness f at\nt1, . . . , td in three steps.\nWe ﬁrst construct an inﬁnite structure E with domain Dd of the same signature τ\nas D as follows. When a1, . . . , ad ∈Dn are such that ai ∈S(D,ti)\nn\n, then for R ∈σ the\nrelation R((a1\n1, . . . , ad\n1), . . . , (a1\nn, . . . , ad\nn)) holds in E if and only if R(x1, . . . , xn) is con-\ntained in Λ\n\u0000tp(D,t1)(a1)×· · ·×tp(D,td)(ad)\n\u0001\n. This is well-deﬁned by the compatibility\nconstraints.\nNext, we consider the relation ∼on the domain of E such that a1 ∼a2 for\na1, a2 ∈Dd if and only if there exist a3, . . . , an ∈Dd such that the subtype of\nΛ(\n\u0000tp(D,t1)((a1\n1, . . . , a1\nn)) × · · · × tp(D,td)(ad\n1, . . . , ad\nn)\n\u0001\ninduced by {1, 2} contains x1 =\nx2. Note that since n ≥3, the relation ∼must be an equivalence relation (since the\nproperties of an equivalence relation can be formulated with a universal formula with\nthree variables). Then the quotient structure E/∼is deﬁned to be the τ-structure\nwhose elements are the equivalence classes E/∼of ∼, and where R(E1, . . . , Ep) holds\nfor a p-ary R ∈τ and E1, . . . , Ep ∈E/∼if and only if there are b1 ∈E1, . . . , bp ∈Ep\nsuch that R(b1, . . . , bp) holds in E.\nThe ﬁnal step is to show that there exists an embedding f of E/∼into D. By\nω-categoricity of D and Lemma 3.1.5, it suﬃces to show every ﬁnite substructure A of\nE/∼embeds into D. Since D is ﬁnitely bounded by N, we thus have to show that no\nstructure in N embeds into A. Suppose to the contrary that there is an embedding\n\n8.4. DECIDABILITY RESULTS FOR META-PROBLEMS\n159\ne of F ∈N into A. Let u1, . . . , us be the elements of F. Pick any elements v1, . . . , vs\nfrom the equivalence classes e(u1), . . . , e(us), respectively. The rest of the paragraph\nis devoted to the argument that the mapping e′ that maps ui to vi is an embedding\nof F into E, which contradicts the realizability constraints. It is obvious that e′ is\ninjective. To see that it is a strong homomorphism, let R be an (n −1)-ary symbol\nfrom τ; the case that R has a smaller arity can be dealt with by adding dummy\nvariables. Note that in the following we use the assumption that n is strictly larger\nthan the maximal arity of D; intuitively, we implement Leibniz’ law for equality. We\nhave R(e(ui1), . . . , e(uip)) if and only if there are v′\ni1 ∈e(ui1), . . . , v′\nip ∈e(uip) so that\nR(v′\ni1, . . . , v′\nip) holds in E. Since the formula R(x1, . . . , xp) ∧xp = xp+1 is contained\nin\nΛ\n\u0000tp(D,t1)(v′\ni1[1], . . . , v′\nip[1], vn[1]), . . . , tp(D,td)(v′\ni1[d]), . . . , v′\nip[d], vin[d])\n\u0001\n,\nthis type of D must also contain R(x1, . . . , xp−1, xp+1). In this way we argue suc-\ncessively for all arguments of R, and ﬁnally obtain that R(vi1, . . . , vip) holds in E.\nThe argument can be reverted, and we have that e′ is a strong homomorphism. We\nconclude that e′ is an embedding.\nObserve that the mapping g from Dd to D that maps ¯u to f(¯u/∼) is a polymor-\nphism of B, by the preservation constraints, and it is canonical by construction. By\nthe violation constraints, g violates R0, and hence is the desired witness.\n□\nAnalogously to the proof of this theorem, one can show the following.\nTheorem 8.4.5 (from [54]). Let C be with ﬁnite relational signature, and ﬁrst-\norder deﬁnable over a structure D which is ordered, homogeneous, Ramsey, ﬁnitely\nbounded, and with ﬁnite relational signature. Then Expr-ex(C) and Expr-ep(C) are\ndecidable.\nAn important open problem is whether the method can be extended to show\ndecidability of Expr-fo(C), under the same assumptions on C as in Theorems 8.4.4\nand 8.4.5. By the theorem of Ryll-Nardzewski, ﬁrst-order deﬁnability is character-\nized by preservation under automorphisms, i.e., surjective self-embeddings. But the\nrequirement of surjectivity is diﬃcult to deal with in our approach.\nQuestion 8.2. Let B be with ﬁnite relational signature, and deﬁnable in a struc-\nture C which is ordered, homogeneous, Ramsey, ﬁnitely bounded, and with ﬁnite rela-\ntional signature. Is Expr-fo(B) decidable?\nWhile the conditions of Theorem 8.4.4 might appear rather restrictive at ﬁrst\nsight, they actually are quite general: we want to point out that we only require that\nC is ﬁrst-order deﬁnable over an ordered, homogeneous, Ramsey, and ﬁnitely bounded\nstructure, rather than requiring that C itself to have these properties. We do not know\nof a single homogeneous structure C with ﬁnite relational signature which does not\nsatisfy the conditions of Theorems 8.4.4 and 8.4.5. Examples of structures C that do\nsatisfy the assumptions, and the corresponding references, see Section 8.1.\nWe ﬁnally show that the assumption in Theorem 8.4.4 of C being ﬁnitely bounded\nis necessary.\nProposition 8.4.6. There exists a homogeneous ordered Ramsey structure C\nwith ﬁnite relational signature such that Expr-fo(C), Expr-pp(C), Expr-ep(C), and\nExpr-ex(C) is undecidable.\nProof. Recall the deﬁnition of Henson digraphs from Example 3.2.7. When C′\nis the age of a Henson digraph C′, then the class C consisting of all structures obtained\nfrom the digraphs in C′ by adding an arbitrary linear order on the vertices, is again\n\n160\n8. RAMSEY THEORY\nan amalgamation class. In fact, it is even a Ramsey class by the results described in\nExample 8.1.9. Let C denote its Fra¨ıss´e-limit.\nWe ﬁrst show that non-isomorphic Henson digraphs C1 and C2 have distinct\nExpr-pp problems. In fact, we show the existence of a ﬁrst-order formula φ1 over di-\ngraphs such that the input with φ0 := E(x, y) and φ1 is a yes-instance of Expr-pp(C1)\nand a no-instance of Expr-pp(C2), or vice versa. Since there are uncountably many\nHenson digraphs, but only countably many algorithms, this clearly shows the existence\nof Henson digraphs C′ such that Expr-pp(C′) is undecidable. It follows that for the\nordered Ramsey structure C described above the problem Expr-pp(C) is undecidable\nas well.\nSince C1 and C2 are non-isomorphic, there must be a structure A that embeds to\nC1 but not to C2, or that embeds to C2 but not to C1. Assume the former is the case;\nin the latter, simply exchange C1 and C2. Let s be the number of elements of A, and\ndenote the elements by a1, . . . , as. Let ψ be the formula with variables x1, . . . , xs that\nhas for distinct i, j ≤s a conjunct E(xi, xj) if E(ai, aj) holds in A, and a conjunct\n¬E(xi, xj) ∧xi ̸= xj otherwise. Let φ be the formula ψ ⇒E(xs+1, xs+2).\nLet C1 be the domain of C1, and consider the relation R1 ⊆(C1)s+2 deﬁned by\nφ in C1. Let R be a relation symbol of arity s + 2, and B be the structures with\nsignature {R}, domain C1, and where R denotes the relation R1. It is clear that\n∃x1, . . . , xs. R(x1, . . . , xs, x, y) is a primitive positive deﬁnition of E(x, y) in B.\nNow consider the relation R2 deﬁned by φ in C2 over the domain C2. Since A\ndoes not embed into C2, the precondition of φ is never satisﬁed, and the relation R2\nis empty. Hence, the structure (C2; R2) is preserved by all permutations. But the\nrelation E(x, y) is certainly not ﬁrst-order deﬁnable over a structure that is preserved\nby all permutations.\n□\n\nCHAPTER 9\nSchaefer’s Theorem for Graphs\nJaroslav Neˇsetˇril, 2004\nThis chapter is based on results from [51,52,193].\n9.1. Motivation and the Result\nIn an inﬂuential paper in 1978, Schaefer [182] classiﬁed the computational com-\nplexity of CSP(B) for all structures B over a two-element universe; the result and a\nsimple proof have been presented in Section 5.4. Schaefer’s theorem can be viewed as\na complexity classiﬁcation for systematic syntactic restrictions of the Boolean satisﬁ-\nability problem, as reﬂected in the following formulation of the result.\nLet Ψ = {ψ1, . . . , ψn} be a ﬁnite set of propositional (Boolean) formulas.\nBoolean-SAT(Ψ)\nINSTANCE: Given a ﬁnite set of variables W and a propositional formula of the form\nΦ = φ1 ∧· · · ∧φl where each φi for 1 ≤i ≤l is obtained from one of the formulas ψ\nin Ψ by substituting the variables of ψ by variables from W.\nQUESTION: Is there a satisfying Boolean assignment to the variables of W (equiva-\nlently, those of Φ)?\nSchaefer’s theorem (Theorem 5.4.3) states that Boolean-SAT(Ψ) can be solved\nin polynomial time if and only if Ψ is a subset of one of six sets of Boolean formulas\n161\n\n162\n9. SCHAEFER’S THEOREM FOR GRAPHS\n(called 0-valid, 1-valid, Horn, dual-Horn, aﬃne, and bijunctive), and is NP-complete\notherwise.\nWe prove a similar classiﬁcation result, but for the ﬁrst-order logic of graphs\ninstead for propositional logic.\nMore precisely, let E be a relation symbol which\ndenotes an antireﬂexive and symmetric binary relation and hence stands for the edge\nrelation of a (simple, undirected) graph. We consider formulas that are constructed\nfrom atomic formulas of the form E(x, y) and x = y by the usual boolean connectives\n(negation, conjunction, disjunction), and call formulas of this form graph formulas.\nA graph formula Φ(x1, . . . , xm) is satisﬁable if there exists a graph H and an m-tuple\na of elements in H such that Φ(a) holds in H.\nThe problem to decide whether a given graph formula is satisﬁable can be very\ndiﬃcult.\nFor example the question whether the Ramsey number R(5, 5) is larger\nthan 43 (which is an open question, see e.g. [94]) can be easily formulated in terms\nof satisﬁability of a single graph formula. Recall that R(5, 5) is the least number\nk such that every graph with at least k vertices either contains a clique of size 5\nor an independent set of size 5. So the question whether R(5, 5) is greater than 43\ncan be formulated using 43 variables x1, . . . , x43 by imposing the constraints that all\nvariables denote a diﬀerent vertex in the graph, and by imposing for every subset of\nthe variables of cardinality ﬁve a constraint that forbids that the corresponding ﬁve\nvariables form a clique or an independent set. If there is a solution to this instance,\nthen this implies that R(5, 5) > 43, and otherwise R(5, 5) ≤43.\nSimilarly as in Schaefer’s theorem, we systematically investigate restrictions of\nthe satisﬁability problem for graph formulas that can be solved in polynomial time.\nLet Ψ = {ψ1, . . . , ψn} be a ﬁnite set of graph formulas. Then Ψ gives rise to the\nfollowing computational problem.\nGraph-SAT(Ψ)\nINSTANCE: Given a set of variables W and a graph formula of the form Φ =\nφ1 ∧· · · ∧φl where each φi for 1 ≤i ≤l is obtained from one of the formulas ψ\nin Ψ by substituting the variables from ψ by variables from W.\nQUESTION: Is Φ satisﬁable?\nExample 9.1.1. Let Ψ be the set that just contains the formula\n(E(x, y) ∧¬E(y, z) ∧¬E(x, z))\n∨(¬E(x, y) ∧E(y, z) ∧¬E(x, z))\n∨(¬E(x, y) ∧¬E(y, z) ∧E(x, z)) .\nThen Graph-SAT(Ψ) is the problem of deciding whether there exists a graph such\nthat certain prescribed subsets of its vertex set of cardinality at most three induce\nsubgraphs with exactly one edge. The problem Graph-SAT(Ψ) is NP-complete.\nExample 9.1.2. There are also many interesting tractable Graph-SAT problems,\nfor instance when Ψ consists of the formula\n(E(x, y) ∧¬E(y, z) ∧¬E(x, z))\n∨(¬E(x, y) ∧E(y, z) ∧¬E(x, z))\n∨(¬E(x, y) ∧¬E(y, z) ∧E(x, z))\n∨(E(x, y) ∧E(y, z) ∧E(x, z)) .\nIt is obvious that the problem Graph-SAT(Ψ) is for all Ψ contained in NP. The\ngoal of this chapter is to prove the following dichotomy result.\n\n9.2. ENDOMORPHISMS\n163\nTheorem 9.1.3. For all Ψ, the problem Graph-SAT(Ψ) is NP-complete or in P.\nMoreover, the problem to decide for given Ψ whether Graph-SAT(Ψ) is NP-complete\nor in P is decidable.\nWe establish our result by translating Graph-SAT problems into CSPs. More\nspeciﬁcally, for every set of formulas Ψ we present a relational structure BΨ such that\nGraph-SAT(Ψ) is equivalent to CSP(BΨ). The relational structure BΨ has a ﬁrst-\norder deﬁnition in the random graph (V; E) introduced in Chapter 3. This perspective\nallows us to use polymorphisms to classify the computational complexity of Graph-\nSAT problems as outlined in Chapter 5. Our proof also relies crucially on strong\nresults from structural Ramsey theory. Following the technique from Chapter 8, we\nuse such results to ﬁnd regular patterns in the behavior of polymorphisms of structures\non (V; E), which in turn allows us to ﬁnd analogies with polymorphisms of structures\non Boolean domains. Our dichotomy result can be stated as follows.\nTheorem 9.1.4. Let B be a relational structure with a ﬁrst-order deﬁnition in\n(V; E). Then exactly one of the following two statements applies.\n(1) there is a primitive positive interpretation of all ﬁnite structures in the\nmodel-complete core of B.\nIn this case, B has a ﬁnite-signature reduct\nwith an NP-hard CSP, by Corollary 5.5.7.\n(2) B has a cyclic polymorphism f modulo an endomorphism, i.e., there are\nf ∈Pol(B) and e ∈End(B) satisfying\nf(x1, . . . , xn) = e(f(x2, . . . , xn, x1))\nfor all x, y ∈V.\nIn this case, every ﬁnite-signature reduct of B has a\npolynomial-time tractable CSP.\nThe proof of this theorem can be found at the end of Section 9.8. The algorithmic\npart of Theorem 9.1.4 is obtained by combinations of ideas from Section 6.3 and\nreductions to the tractable cases of Schaefer’s theorem (Theorem 5.4.3).\nIn the remainder of this chapter, B denotes a relational structure with a ﬁrst-\norder deﬁnition in the random graph (V; E). Since all the polymorphism clones of\nthis chapter contain the automorphism group Aut(V; E) of the random graph, we\nalso make the following convention, which exclusively holds for this chapter. For a\nset of functions F and a function g on the domain V, we say that F generates g\nwhen F ∪Aut(V; E) locally generates g; also, we say that a function f generates g if\n{f} generates g. That is, in this paper we consider the automorphisms of (V; E) be\npresent in all sets of functions when speaking about the local generating process.\n9.2. Endomorphisms\nThe goal of this section is the proof of Proposition 9.2.2, which allows us to\nreduce the classiﬁcation task for B to the classiﬁcation of those structures B where\nthe Aut(B) is dense in End(B); moreover, we give a description of the ﬁve possible\nautomorphism groups that can appear, due to Thomas [193].\nWe write N for the relation {(x, y) ∈V2 | x ̸= y ∧¬E(x, y)}. Note that (V; N)\nis the complement of the graph (V; E), and that (V; N) is isomorphic to (V; E) (it\nis straightforward to verify the extension property). Let −be such an isomorphism.\nFor any ﬁnite subset S of V, if we ﬂip edges and non-edges between S and V \\ S\nin (V; E), then the resulting graph is isomorphic to (V; E) (it is straightforward to\nverify the extension property). For any non-empty set S, we write iS for such an\nisomorphism. Note that when S and T are two ﬁnite non-empty subsets of V, then\niS and iT generate one another. We also write sw for i{0}, where 0 ∈V is any ﬁxed\nelement of V.\n\n164\n9. SCHAEFER’S THEOREM FOR GRAPHS\nDefinition 9.2.1 (R(k) and S(k)). Let R(k) (S(k)) be the k-ary relation that holds\non x1, . . . , xk ∈V if x1, . . . , xk are pairwise distinct, and the number of edges between\nthese k vertices is odd (even).\nObserve that R(3) and R(4) are preserved by sw, that R(4) and R(4) are pre-\nserved by −, and that R(5) and S(5) are preserved by −and by sw, but not by all\npermutations of V.\nProposition 9.2.2. Let B be ﬁrst-order deﬁnable in (V; E). Then at least one\nof the following holds.\n(a) The endomorphisms of B are generated by Aut(V; E).\n(b) B has a constant endomorphism. In this case CSP(B) is trivial.\n(c) B is homomorphically equivalent to a countably inﬁnite structure that is pre-\nserved by all permutations of its domain. Such structures have been classiﬁed\nin Chapter 6.\n(d) The endomorphisms of B are precisely the functions generated by sw; equiv-\nalently, End(B) = End(V; R(3), S(3)).\n(e) The endomorphisms of B are precisely the functions generated by −; equiv-\nalently, End(B) = End(V; R(4), S(4)).\n(f) The endomorphisms of B are precisely the functions generated by {−, sw};\nequivalently, End(B) = End(V; R(5), S(5)).\nTo prove the proposition, we ﬁrst cite a result about structures deﬁnable over\nthe random graph due to Thomas [194]; the formulation of the result presented here\nﬁrst appeared in [51]. The graph (V; E) contains all countable graphs as induced\nsubgraphs. In particular, it contains an inﬁnite complete subgraph, denoted by Kω.\nIt is clear that any two injective operations from V →V whose images induce Kω in\n(V; E) generate one another. Let eE be one such operation. Similarly, (V; E) contains\nan inﬁnite independent set, denoted by Iω. Let eN be an injective operation from\nV →V whose image induces Iω in (V; E).\nTheorem 9.2.3 (of [51,194]). Let B be ﬁrst-order deﬁnable in (V; E). Then one\nof the following cases applies.\n(1) B has a constant endomorphism.\n(2) B has the endomorphism eE.\n(3) B has the endomorphism eN.\n(4) The endomorphisms of B are locally generated by the automorphisms of B.\nCorollary 9.2.4 (from [51]). All relational structures B with a ﬁrst-order def-\ninition in (V; E) are model-complete.\nProof. By Theorem 3.6.7, an ω-categorical structure B is model-complete if\nand only if Aut(B) is dense in the monoid M of self-embeddings of B. We apply\nTheorem 9.2.3 to M , which, as a closed monoid containing Aut((V; E)), is also an\nendomorphism monoid of a structure B′ with a ﬁrst-order deﬁnition in (V; E). Clearly,\nB′ and B have the same automorphisms, namely those permutations in M whose\ninverse is also in M . Therefore we are done if the last case of Theorem 9.2.3 holds.\nNote that M cannot contain a constant operation as all its operations are injective.\nSo suppose that M contains eN – the argument for eE is analogous. Let R be any\nrelation of B, and φR be its deﬁning quantiﬁer-free formula; φR exists since (V; E) has\nquantiﬁer-elimination. Let ψR be the formula obtained by replacing all occurrences\nof E by false; so ψR is a formula over the empty language. Then a tuple a satisﬁes\nφR in (V; E) iﬀeN(a) satisﬁes φR in (V; E) (because eN is an embedding) if and\nonly if eN(a) satisﬁes ψR in (V; E) (as there are no edges on eN(a)) if and only if\n\n9.3. FIRST-ORDER EXPANSIONS OF (V; E, N)\n165\neN(a) satisﬁes ψR in the substructure induced by eN[V] (since ψR does not contain\nany quantiﬁers).\nThus, B is isomorphic to the structure on eN[V] which has the\nrelations deﬁned by the formulas ψR. Therefore, B is isomorphic to a structure with\na ﬁrst-order deﬁnition over the empty signature. This structure has, of course, all\ninjections as self-embeddings, and all permutations as automorphisms, and hence is\nmodel-complete; the same is true for B.\n□\nThe last case in Theorem 9.2.3 splits into ﬁve sub-cases, corresponding to the ﬁve\nlocally closed permutation groups that contain Aut((V; E)) exhibited by Thomas [193].\nDefinition 9.2.5. For all k ≥3, let P (k) denote the k-ary relation that holds on\nx1, . . . , xk ∈V if x1, . . . , xk are pairwise distinct, and the graph induced by {x1, . . . , xk}\nin (V; E) is neither an independent set nor a clique.\nTheorem 9.2.6 (of [193]). Let B be a relational structure with a ﬁrst-order\ndeﬁnition in (V; E). Then exactly one of the following is true.\n(1) B is ﬁrst-order interdeﬁnable with (V; E); equivalently, Aut(B) = Aut((V; E)).\n(2) B is ﬁrst-order interdeﬁnable with (V; R(4)); equivalently, B is preserved by\n−, but not by sw.\n(3) B is ﬁrst-order interdeﬁnable with (V; R(3)); equivalently, B is preserved by\nsw, but not by −.\n(4) B is ﬁrst-order interdeﬁnable with (V; R(5)); equivalently, B is preserved by\n−and by sw, but not by all permutations of V.\n(5) B is ﬁrst-order interdeﬁnable with (V; =); equivalently, B is preserved by\nall permutations of V.\nWe are now ready to prove Proposition 9.2.2.\nProof of Proposition 9.2.2. Theorem 9.2.3 states that B has a constant en-\ndomorphism, or the endomorphism eE, or the endomorphism eN, or all endomor-\nphisms of B are generated by its automorphisms. If B has a constant endomorphism\nwe are in Case (b) and done. If B has the endomorphisms eE or eN, then we are in\nCase (c) since eE[V] and eN[V] induce structures in (V; E) which are invariant under\nall permutations of their domain. So assume in the following that B has neither eE,\nnor eN, nor a constant as an endomorphism, and that all endomorphisms of B are\ngenerated by Aut(B). The statement now follow from Theorem 9.2.6.\n□\nProposition 9.2.2 allows us to focus in the following on the situation where Aut(B)\nis dense in End(B). Moreover, there are only ﬁve possibilities for Aut(B), and the\ncase Aut(B) = Aut(V; =) has already been solved.\n9.3. First-order Expansions of (V; E, N)\nWe remark that since (V; E) has only binary relations, a function f : Vk →V is\ncanonical if and only if it is 2-canonical (Section 5.6.2). The polymorphisms that\nimply tractability of CSP(B) will be canonical with respect to (V; E).\nWe now\ndeﬁne diﬀerent behaviors that some of these canonical functions might have.\nFor\nQ1, . . . , Qk ∈{E, N, =, ̸=}, we will in the following write Q1 · · · Qk for the binary\nrelation on Vk that holds between two k-tuples x, y ∈Vk iﬀQi(xi, yi) holds for all\n1 ≤i ≤k.\nDefinition 9.3.1. We say that a binary injective operation f : V2 →V is\n• balanced in the ﬁrst argument if for all u, v ∈V2 we have that E=(u, v)\nimplies E(f(u), f(v)) and N=(u, v) implies N(f(u), f(v));\n\n166\n9. SCHAEFER’S THEOREM FOR GRAPHS\n• balanced in the second argument if (x, y) 7→f(y, x) is balanced in the ﬁrst\nargument;\n• balanced if f is balanced in both arguments, and unbalanced otherwise;\n• E-dominated (N-dominated) in the ﬁrst argument if for all u, v ∈V2 with\n̸==(u, v) we have that E(f(u), f(v)) (N(f(u), f(v)));\n• E-dominated (N-dominated) in the second argument if (x, y) 7→f(y, x) is\nE-dominated (N-dominated) in the ﬁrst argument;\n• E-dominated (N-dominated) if it is E-dominated (N-dominated) in both\narguments;\n• of type min if for all u, v ∈V2 with ̸≠=(u, v) we have E(f(u), f(v)) if and\nonly if EE(u, v);\n• of type max if for all u, v ∈V2 with ̸≠=(u, v) we have N(f(u), f(v)) if and\nonly if NN(u, v);\n• of type p1 if for all u, v ∈V2 with ̸≠=(u, v) we have E(f(u), f(v)) if and\nonly if E(u1, v1);\n• of type p2 if (x, y) 7→f(y, x) is of type p1;\n• of type projection if it is of type p1 or p2.\nNote that, for example, being of type max is a behavior of binary functions that\ndoes not force a function to be canonical, since the condition only talks about certain\ntypes of pairs in V2, but not all such types; however, being of type max and balanced\ndoes mean that a function is canonical. The next deﬁnition contains some important\nbehaviors of ternary functions.\nDefinition 9.3.2. An injective ternary function f : V3 →V is of type\n• majority if for all u, v ∈V3 we have that E(f(u), f(v)) if and only if\nEEE(u, v), EEN(u, v), ENE(u, v), or NEE(u, v);\n• minority if for all x, y ∈V3 we have E(f(x), f(y)) if and only if EEE(u, v),\nNNE(u, v), NEN(u, v), or ENN(u, v).\nWhile the polynomial-time tractability results of this section will be shown by\nmeans of a number of diﬀerent canonical functions, all hardness cases will be estab-\nlished by the following single relation.\nDefinition 9.3.3. We deﬁne the 6-ary relation H1(x1, y1, x2, y2, x3, y3) on V by\n^\ni,j∈{1,2,3},i̸=j,u∈{xi,yi},v∈{xj,yj}\nN(u, v)\n∧\n\u0000(E(x1, y1) ∧N(x2, y2) ∧N(x3, y3))\n∨(N(x1, y1) ∧E(x2, y2) ∧N(x3, y3))\n(9)\n∨(N(x1, y1) ∧N(x2, y2) ∧E(x3, y3))\n\u0001\n.\nThe goal of this section is to prove the following proposition.\nProposition 9.3.4. Let B = (V; E, N, ̸=, . . . ) be ﬁrst-order deﬁnable in (V; E).\nThen at least one of the following holds:\n(a) There is a primitive positive deﬁnition of H1 in B. In this case, CSP(B) is\nNP-complete.\n(b) B has a canonical polymorphism of type minority, as well as a canonical\nbinary injection which of type p1 and E-dominated or N-dominated in the\nsecond argument. In this case, CSP(B) is polynomial-time tractable.\n(c) B has a canonical polymorphism of type majority, as well as a canonical\nbinary injection which of type p1 and E-dominated or N-dominated in the\nsecond argument. In this case, CSP(B) is polynomial-time tractable.\n\n9.3. FIRST-ORDER EXPANSIONS OF (V; E, N)\n167\n(d) B has a canonical polymorphism of type minority, as well as a canonical bi-\nnary injection which is balanced and of type projection. In this case, CSP(B)\nis polynomial-time tractable.\n(e) B has a canonical polymorphism of type majority, as well as a canonical bi-\nnary injection which is balanced and of type projection. In this case, CSP(B)\nis polynomial-time tractable.\n(f) B has a canonical polymorphism of type max or min. In this case, CSP(B)\nis polynomial-time tractable.\nThe remainder of this section contains the proof of Proposition 9.3.4, except for\nthe polynomial-time tractability proofs, which will be given in Section 9.7. For the\nother statements of Proposition 9.3.4, we proceed as follows. In Section 9.3.1, we\nshow that the relation H1 is hard. In particular, a structure B = (V; E, N, ̸=, . . .)\nwith a ﬁrst-order deﬁnition in (V; E) must have an essential polymorphism, or has a\nﬁnite reduct with an NP-hard CSP. In Section 9.3.2 we show when B has an essential\npolymorphism, it must also have a binary injective polymorphism. We ﬁnally prove\nin Section 9.3.4 that B has one of the polymorphisms listed in cases (b) to (f) of the\nproposition.\n9.3.1. Hardness of H1. This section is devoted to case (a) of Proposition 9.3.4.\nProposition 9.3.5. There is a primitive positive interpretation of ({0, 1}; 1IN3)\nin (V; H1), and CSP(V; H1) is NP-hard.\nProof. We give a 2-dimensional interpretation I of ({0, 1}; 1IN3) in B. The\ndomain formula is true. The formula =I (x1, x2, y1, y2) is\n∃z1, z2, u1, u2, v1, v2\n\u0000H1(x1, x2, u1, u2, z1, z2) ∧N(u1, u2)\n∧H1(z1, z2, v1, v2, y1, y2) ∧N(v1, v2)\n\u0001\nThis formula is equivalent to a primitive positive formula over B since N(x, y) is\nprimitive positive deﬁnable by H1. The formula 1IN3I(x1, x2, y1, y2, z1, z2) is\n∃x′\n1, x′\n2, y′\n1, y′\n2, z′\n1, z′\n2\n\u0000H1(x′\n1, x′\n2, y′\n1, y′\n2, z′\n1, z′\n2)\n∧=I (x1, x2, x′\n1, x′\n2)∧=I (y1, y2, y′\n1, y′\n2)∧=I (z1, z2, z′\n1, z′\n2)\n\u0001\nThe coordinate map sends a tuple (x1, x2) to 1 if E(x1, x2) and to 0 otherwise. The\nsecond part of the statement follows from Corollary 5.5.7.\n□\n9.3.2. Producing binary injections. We now show that if a structure B =\n(V; E, N, ̸=, . . .) with a ﬁrst-order deﬁnition in (V; E) has an essential polymorphism,\nthen B must also have a binary injective polymorphism. This is in particular the case\nwhen the relation H1 from the previous section is not primitive positive deﬁnable in\nB: since E and N are among the relations of B, and since any essentially unary\npolymorphism preserving both E and N preserves all relations with a ﬁrst-order\ndeﬁnition in (V; E), we have that the polymorphism violating H1 must be essential.\nTheorem 9.3.6 (from [51]). Let B = (V; E, N, ̸=, . . . ) be ﬁrst-order deﬁnable in\n(V; E), and suppose that B has an essential polymorphism. Then B also has a binary\ninjective polymorphism.\nProof. Let f : Vk →V be an essential polymorphism of B of minimal arity. By\nLemma 5.3.10, f must be binary. Hence, we may apply Lemma 6.1.3 to B, and in\norder to show that B is preserved by a binary injection, it suﬃces to show that if φ\nis a primitive positive formula over B such that both φ ∧x ̸= y and φ ∧s ̸= t are\nsatisﬁable over B, then φ ∧x ̸= y ∧s ̸= t is satisﬁable over B as well. The proof\nfollows the idea of the proof of Theorem 6.2.1.\n\n168\n9. SCHAEFER’S THEOREM FOR GRAPHS\nLet φ be a primitive positive formula over the signature of B such that\n• there is a tuple t1 that satisﬁes φ ∧x ̸= y\n• there is a tuple t2 that satisﬁes φ ∧s ̸= t.\nLet a1, a2, a3, a4 and b1, b2, b3, b4 be the values for x, y, s, t in t1 and t2, respectively.\nWe have a1 ̸= a2 and b3 ̸= b4. We want to show that φ ∧x ̸= y ∧s ̸= t is satisﬁable\nover B. Thus, if a3 ̸= a4 or b1 ̸= b2, there is nothing to show, and so we assume that\na3 = a4 and b1 = b2.\nWe claim that there are automorphisms α, β of (V; E) such that in the tuple\nt3 := f(α(t1), β(t2)) the value of x is diﬀerent from the value of y, and the value of\ns is diﬀerent from the value of t. Then, since f preserves B, the tuple t3 shows that\nφ ∧x ̸= y ∧s ̸= t is satisﬁable over B, and concludes the proof.\nTo prove the claim, we will ﬁnd tuples c := (c1, c2, c3, c4) and d := (d1, d2, d3, d4)\nof the same type as (a1, a2, a3, a4) and (b1, b2, b3, b4), respectively, such that the tuple\ne := f(c, d) satisﬁes e1 ̸= e2 and e3 ̸= e4. Then, by the homogeneity of (V; E), we\ncan ﬁnd automorphisms α and β of (V; E) sending a to c and b to d, which suﬃces\nfor the proof of our claim.\nIn the sequel, we will assume that X(a1, a2) and Y (b3, b4), where X, Y ∈{E, N}.\nCase 1. Suppose ﬁrst that a3 = a4 ∈{a1, a2} and b1 = b2 ∈{b3, b4}; without\nloss of generality, a3 = a2 and b1 = b3.\nCase 1.1 There exists u ∈V such that for all p, v ∈V with (u, v) ∈Y we\nhave f(p, u) = f(p, v). Then, because f preserves ̸=, we have f(p, u) ̸= f(q, u) for\nall p ̸= q. If for all p, v ∈V we have that f(p, u) = f(p, v), then this implies that\nfor all p, v, v′ ∈V we have that f(p, v′) = f(p, v), contradicting our assumption\nthat f is essential. So there are p, v ∈V such that f(p, u) ̸= f(p, v). Pick w ∈V\nsuch that (w, u), (w, v) ∈Y . Pick moreover q ∈V such that (p, q) ∈X. We have\nf(p, v) ̸= f(p, u) = f(p, w). Moreover, f(p, w) = f(p, u) ̸= f(q, u) = f(q, w). Hence,\nthe tuples c := (q, p, p, p) and d := (w, w, w, v) prove the claim.\nCase 1.2 For all u ∈V there exist p, v ∈V with (u, v) ∈Y such that f(p, u) ̸=\nf(p, v). Pick m, n, u ∈V with (m, n) ∈X and f(m, u) ̸= f(n, u). Pick p, v ∈V\nsuch that (u, v) ∈Y and f(p, u) ̸= f(p, v).\nIf we can pick p in such a way that\n(p, m), (p, n) ∈X, then since either f(m, u) ̸= f(p, u) or f(n, u) ̸= f(p, u) we have\nthat either (m, p, p, p) or (n, p, p, p) proves the claim together with the tuple (u, u, u, v).\nSo suppose that this is impossible. Then for any q ∈V with (q, m), (q, n) ∈X we have\nf(q, u) = f(q, v) ̸= f(p, u), so we have that (q, p, p, p) and (u, u, u, v) satisfy the claim.\nCase 2. Now suppose that a3 = a4 ∈{a1, a2} and b1 = b2 /∈{b3, b4}; wlog\na3 = a2. Write (b1, b3) ∈Q3 and (b1, b4) ∈Q4, where Q3, Q4 ∈{E, N}.\nCase 2.1 There exists u ∈V such that for all p, v, r with (v, r) ∈Y , (u, v) ∈Q3\nand (u, r) ∈Q4 we have f(p, v) = f(p, r). Then one easily concludes that for all\np ∈V and all v, v′ ∈V with v, v′ ̸= u we have f(p, v) = f(p, v′). This implies that\nf(p, v) ̸= f(q, v) whenever p ̸= q and v ̸= u. Since f is essential, there exist p, v ∈V\nwith (u, v) ∈Y such that f(p, u) ̸= f(p, v). Now pick w, q ∈V such that (w, u) ∈Q3,\n(w, v) ∈Q4, and (q, p) ∈X. Then f(p, w) ̸= f(q, w), and so the tuples (q, p, p, p) and\n(w, w, u, v) prove the claim.\nCase 2.2 For all u there exist p, v, r with (v, r) ∈Y , (u, v) ∈Q3, (u, r) ∈Q4 and\nf(p, v) ̸= f(p, r). Pick m, n, u with (m, n) ∈X and f(m, u) ̸= f(n, u). Pick p, v, r ∈V\nsuch that (v, r) ∈Y , (u, v) ∈Q3, (u, r) ∈Q4 and f(p, v) ̸= f(p, r). If we can pick p in\nsuch a way that (p, m), (p, n) ∈X, then either (m, p, p, p) and (u, u, v, r) or (n, p, p, p)\nand (u, u, v, r) prove the claim. So suppose that this is impossible. Then for any q\nwith (q, m), (q, n) ∈X and all v, r ∈V with (v, r) ∈Y , (u, v) ∈Q3, (u, r) ∈Q4\n\n9.3. FIRST-ORDER EXPANSIONS OF (V; E, N)\n169\nwe have f(q, v) = f(q, r). This implies that for all such q and all v, v′ ̸= u we have\nf(q, v) = f(q, v′).\nPick w such that (w, v) ∈Q3, (w, r) ∈Q4.\nPick q such that\n(q, p) ∈X. We have f(q, w) ̸= f(p, w), and so (q, p, p, p) and (w, w, v, r) prove the\nclaim.\nCase 3. To ﬁnish the proof, suppose that a3 = a4 /∈{a1, a2} and b1 = b2 /∈\n{b3, b4}. Write (a3, a1) ∈P1, (a3, a2) ∈P2, (b1, b3) ∈Q3 and (b1, b4) ∈Q4, where\nPi, Qi ∈{E, N}.\nCase 3.1 There exists u such that for all p, v, r with (v, r) ∈Y , (u, v) ∈Q3\nand (u, r) ∈Q4 we have f(p, v) = f(p, r). Then one easily concludes that for all\np ∈V and all v, v′ ∈V with v, v′ ̸= u we have f(p, v) = f(p, v′). This implies that\nf(p, v) ̸= f(q, v) whenever p ̸= q and v ̸= u. We claim that there exist p, v with\n(u, v) ∈Y such that f(p, u) ̸= f(p, v). Otherwise, if f(p, u) = f(p, v) for all p, V, then\nf(p, v) = f(p, v′) for all p, v, v′, and f depends only on its ﬁrst variable, contradicting\nthe assumption that f is essential. Now pick w, m, n such that (w, u) ∈Q3, (w, v) ∈\nQ4, (m, n) ∈X, (m, p) ∈P1, and (n, p) ∈P2.\nThen the tuples (m, n, p, p) and\n(w, w, u, v) prove the claim.\nCase 3.2 For all u there exist p, v, r with (v, r) ∈Y , (u, v) ∈Q3, (u, r) ∈Q4\nand f(p, v) ̸= f(p, r). Pick m, n, u with (m, n) ∈X and f(m, u) ̸= f(n, u). Pick\np, v, r such that (v, r) ∈Y , (u, v) ∈Q3, (u, r) ∈Q4 and f(p, v) ̸= f(p, r). If we\ncan pick p in such a way that (p, m) ∈P1 and (p, n) ∈P2, then (m, n, p, p) and\n(u, u, v, r) prove the claim, so suppose that this is impossible. Then for any q with\n(q, m) ∈P1 and (q, n) ∈P2 and all v, r with (v, r) ∈Y , (u, v) ∈Q3, (u, r) ∈Q4 we\nhave f(q, v) = f(q, r). This is easily seen to imply that for all such q and all v, v′ ̸= u\nwe have f(q, v) = f(q, v′). Pick w such that (w, v) ∈Q3, (w, r) ∈Q4, and w ̸= u. Pick\nq, q′ such that (q, q′) ∈X, (q, p) ∈P1 and (q′, p) ∈P2. We have f(q, w) ̸= f(q′, w),\nand thus (q, q′, p, p) and (w, w, v, r) prove the claim.\n□\n9.3.3. Minimal Binary Functions. Let C be the clone generated by Aut(V; E).\nWe know from Theorem 9.2.3 and Theorem 9.3.6 that all essential functions that are\nminimal above C are binary, injective, and preserve both E and N. It is the goal of\nthis section to determine these binary minimal functions. To state the main result,\nwe deﬁne the dual of an operation f on (V; E), which can be imagined as the function\nobtained from f by exchanging the roles of E and N.\nDefinition 9.3.7. The dual of a function f(x1, . . . , xn) on (V; E) is the function\n−f(−x1, . . . , −xn).\nTheorem 9.3.8 (from [51]). If B = (V; E, N, ̸=, . . .) is ﬁrst-order deﬁnable in\n(V; E) and has an essential polymorphism, it must also have at least one of the fol-\nlowing binary injective canonical polymorphisms.\n• a balanced operation of type p1;\n• a balanced operation of type max;\n• an E-dominated operation of type max;\n• an E-dominated operation of type p1;\n• a binary operation of type p1 that is balanced in the ﬁrst and E-dominated\nin the second argument;\nor one of the duals of the last four operations (the ﬁrst operation is self-dual).\nOur proof of Theorem 9.3.8 makes essential use of the Ramsey techniques from\nChapter 8. As we have seen in Example 8.1.6, the class of all ﬁnite graphs is not\na Ramsey class. However, the class of all ﬁnite ordered graphs is a Ramsey class\n(see Example 8.1.7 for a more general result). This class is clearly an amalgamation\n\n170\n9. SCHAEFER’S THEOREM FOR GRAPHS\nclass, and we denote its Fra¨ıss´e-limit by (V; E, <).\nNote that the reduct of this\nstructure without the order has the extension property, and hence is isomorphic to\nthe random graph. It therefore makes sense to use the same symbol V for the elements\nof (V; E, <) and the elements of the random graph. Also note that the reduct (V; <)\nis isomorphic to (Q; <). By the argument above, the following is a direct consequence\nof Corollary 8.3.6.\nCorollary 9.3.9. Every essential function that is minimal above the clone gener-\nated by Aut(V; E) is a binary injection that is canonical as a function from (V; E, <)2\nto (V; E, <).\nIn the rest of this section, canonical means canonical as a function from (V; E, <)2\nto (V; E, <), and minimal means minimal as an operation above C . The following\nbehavior of functions from (V; E, <)2 →(V; E, <) is useful to describe canonical\nfunctions.\nDefinition 9.3.10. Let f : V2 →V, and let {R1, R2} = {E, N}.\nIf for all\n(x1, x2), (y1, y2) ∈V2 with x1 < y1, x2 < y2, R1(x1, y1), and R2(x2, y2) we have\n• N(f(x1, x2), f(y1, y2)), then we say that f behaves like min on input (<, <).\n• E(f(x1, x2), f(y1, y2)), then we say that f behaves like max on input (<, <).\n• R1(f(x1, x2), f(y1, y2)), then we say that f behaves like p1 on input (<, <).\n• R2(f(x1, x2), f(y1, y2)), then we say that f behaves like p2 on input (<, <).\nAnalogously, we deﬁne behavior on input (<, >) using pairs (x1, x2), (y1, y2) ∈V2\nwith x1 < y1 and x2 > y2.\nOf course, we could also have deﬁned “behavior on input (>, >)” and “behavior on\ninput (>, <)”; however, behavior on input (>, >) equals behavior on input (<, <), and\nbehavior on input (>, <) equals behavior on input (<, >) since graphs are symmetric.\nThus, there are only two kinds of inputs to be considered, namely “straight input”\n(<, <) and “twisted input” (<, >).\nProposition 9.3.11. Let f : V2 →V be injective and canonical, and suppose\nit preserves E and N. Then it behaves like min, max, p1 or p2 on input (<, <).\nMoreover, it behaves like on min, max, p1 or p2 on input (<, >).\nProof. By canonicity it suﬃces to check the statement for all possible types of\npairs x, y ∈V2.\n□\nWe remark that the four possibilities correspond to the four binary operations g on\nthe two-element domain {E, N} that are idempotent, i.e., that satisfy that g(E, E) =\nE and g(N, N) = N.\nDefinition 9.3.12. If f : V2 →V behaves like X on input (<, <) and like Y on\ninput (<, >), where X, Y ∈{max, min, p1, p2}, then we say that f is of type X/Y .\nFix an automorphism ↔of the graph (V; E) that reverses the order on V;\nsuch an automorphism clearly exists since (V; E, <) and (V; E, >) are isomorphic.\nLemma 8.3.15 shows that any canonical binary injective polymorphism of (V; <) has\nthe same behavior as lex(x, y), lex(x, ↔y), lex(y, x), or lex(y, ↔x). If f is any function\nthat is canonical as a map from (V; <; E)2 to (V; <), and does not preserve <, then\n(x, y) 7→↔f(x, y) preserves <. Moreover, by passing from f to (x, y) 7→f(↔x, y) or\n(x, y) 7→f(↔x, y) we can assume that f behaves either like lex(x, y) or lex(y, x).\nWe will now prove that minimal binary canonical injections are never of mixed\ntype, i.e., they have to behave the same way on straight and twisted inputs.\nLemma 9.3.13. Suppose that f : V2 →V is injective and canonical, and suppose\nthat it is of type max/pi or of type pi/max, where i ∈{1, 2}. Then f is not minimal.\n\n9.3. FIRST-ORDER EXPANSIONS OF (V; E, N)\n171\nProof. We prove that f generates a binary injective canonical function g which\nis of type max/max. Clearly, all binary injective canonical functions generated by g\nthen are also of type max/max, so g cannot generate f, proving the lemma.\nAssume without loss of generality that f is of type max/pi, and note that we\nassume that f behaves like lex(x, y). Set h(u, v) := f(u, ↔v). Then h behaves like\npi on input (<, <) and like max on input (<, >); moreover, f(x1, x2) < f(y1, y2) iﬀ\nh(x1, x2) < h(y1, y2), for all x1 ̸= y1 and x2 ̸= y2. We then have that g(u, v) :=\nf(f(u, v), h(u, v)) is of type max/max, ﬁnishing the proof.\n□\nLemma 9.3.14. Suppose that f : V2 →V is injective and canonical, and suppose\nthat it is of type min/pi or of type pi/min, where i ∈{1, 2}. Then f is not minimal.\nProof. The dual proof works.\n□\nLemma 9.3.15. Suppose that f : V2 →V is injective and canonical, and suppose\nthat it is of type max/min or of type min/max. Then f is not minimal.\nProof. Assume without loss of generality that f is of type max/min, and recall\nthat we assume that f behaves like lex(x, y).\nConsider h(u, v) := f(f(u, v), ↔v).\nThen h is of type p2/p2, so it cannot reproduce f.\n□\nLemma 9.3.16. Suppose that f : V2 →V is injective and canonical, and suppose\nthat it is of type p1/p2 or of type p2/p1. Then f is not minimal.\nProof. If f is of type p1/p2, then h(u, v) := f(f(u, v), ↔v) is of type p2/p2 and\ncannot reproduce f. If f is of type p2/p1, then g(u, v) := f(u, ↔v) is of type p1/p2\nand still behaves like lex(x, y); hence, we are back in the ﬁrst case.\n□\nWe have seen that actually no “mixed” types appear for minimal functions. In\nother words, minimal functions that are canonical as functions from (V; E, <)2 →\n(V; E, <) are also canonical as functions from (V; E)2 →(V; E). This motivates the\nfollowing deﬁnition.\nDefinition 9.3.17. Let f : V2 →V. We say that f behaves like min (max, p1,\np2) on input (̸=, ̸=) iﬀit behaves like min (max, p1, p2) both on input (<, <) and on\ninput (<, >). We also say that f is of type min (max, p1, p2). If f is of type p1 or\np2 then we also say that f is of type projection.\nOur observations so far can be summarized as follows.\nProposition 9.3.18. Let f : V2 →V be essential and minimal. Then it is injec-\ntive, canonical as a function from (V; E)2 →(V; E), and behaves like min, max, p1\nor p2 on input (̸=, ̸=).\nIn the following, we consider further types of tuples x, y ∈V2. So far, we did not\nconsider the case where x1 = y1 or x2 = y2.\nDefinition 9.3.19. Let f : V2 →V. We say that f behaves like eE (eN, id, −)\non input (̸=, =) iﬀfor every ﬁxed c ∈V, the function g(x) := f(x, c) behaves like eE\n(eN, id, −). Similarly we deﬁne behavior on input (=, ̸=).\nIf f is canonical and injective, then it behaves like one of the mentioned functions\non input (̸=, =) and (=, ̸=), respectively. This motivates the following.\nDefinition 9.3.20. We say that f : V2 →V is of type E/N iﬀf behaves like\neE on input (̸=, =) and like eN on input (=, ̸=). Similarly we deﬁne the types E/E,\nN/E, E/ id, E/−, etc. Moreover, we say that f is balanced iﬀit is of type id / id,\nwe say it is E-dominated iﬀit is of type E/E, and we say it is N-dominated iﬀit is\nof type N/N.\n\n172\n9. SCHAEFER’S THEOREM FOR GRAPHS\nIn the following theorem, we ﬁnally characterize those canonical behaviors that\nyield minimal functions.\nTheorem 9.3.21. The minimal polymorphisms of (V; E, N) are precisely the bi-\nnary injective canonical operations of the following types:\n(1) Projection and balanced.\n(2) max and balanced.\n(3) min and balanced.\n(4) max and E-dominated.\n(5) min and N-dominated.\n(6) Projection and E-dominated.\n(7) Projection and N-dominated.\n(8) p2 and E/ id, or p1 and id /E.\n(9) p2 and N/ id, or p1 and id /N.\nMoreover, these 9 diﬀerent kinds of minimal functions do not generate one another,\nand any two functions in the same group do generate one another.\nIf e is essential, then it must be binary and injective by Theorem 9.3.6. The\nrest of the theorem follows from Proposition 9.3.18 and the following lemmas. By\nthe homogeneity of (V; E) and local closure, it is easy to see that a binary canonical\ninjection in one of the classes of Theorem 9.3.21 generates all other functions in the\nsame class. The veriﬁcation of Lemmas 9.3.22 to 9.3.25 is left to the reader; the proof\nalways uses induction over terms.\nLemma 9.3.22. Any binary essential function generated by a binary canonical\ninjection of type min, max, or projection, respectively, is of the same type.\nLemma 9.3.23. Any binary essential function generated by a binary canonical\ninjection that is balanced and preserves E and N is balanced.\nWe thus have that the ﬁrst three classes of functions of Proposition 9.3.21 are\nindeed minimal. The following lemma proves minimality for items (4) and (5).\nLemma 9.3.24. Any binary essential function generated by an E-dominated bi-\nnary canonical injection of type max is E-dominated. Dually, any binary essential\nfunction generated by an N-dominated binary canonical injection of type min is N-\ndominated.\nThe following lemma proves minimality for items (6) and (7).\nLemma 9.3.25. Any binary essential function generated by an E-dominated bi-\nnary canonical injection of type projection is E-dominated. Dually, any binary essen-\ntial function generated by an N-dominated binary canonical injection of type projec-\ntion is N-dominated.\nIt remains to prove minimality for items (8) and (9), which is achieved in the\nfollowing lemma.\nLemma 9.3.26. Any binary essential function generated by a binary canonical\ninjection of type E/ id and p2 is either of the same type or of type id /E and p1.\nDually, any binary essential function generated by a binary canonical injection of\ntype N/ id and p2 generates is either of the same type or of type id /N and p1.\nProof. Let f(u, v) be of type E/ id and p2. f(v, u) is of type id /E and p1.\nBoth f(u, f(u, v)) and f(v, f(u, v)) are of type E/ id and p2. So is f(f(u, v), v). The\nfunction f(f(u, v), u) is of type id /E and p1. Finally, f(f(u, v), f(v, u)) also is of\ntype id /E and p1, so f cannot generate any new behaviors.\n□\n\n9.3. FIRST-ORDER EXPANSIONS OF (V; E, N)\n173\nNext we claim that no other functions except for those listed in Theorem 9.3.21\nare minimal. This will be achieved in the following lemmas.\nLemma 9.3.27. Let f be a binary canonical injection of type max. If f is not\nbalanced or E-dominated, then f is not minimal.\nProof. If f is of type E/ id, then g(x, y) := f(f(x, y), x) is E-dominated. By\nLemma 9.3.24, g cannot reproduce f. If f is of type E/N, then g is E-dominated as\nwell. So it is if f is of type E/−.\nIf f is of type N/ id, then g(x, y) := f(x, f(x, y)) is balanced, so f is not minimal\nby Lemma 9.3.23. If f is of type N/−, then g is balanced as well.\nIf f is of type id /−or of type −/−, then g(x, y) := f(x, f(x, y)) is of type E/ id,\nwhich we have already shown not to be minimal.\nBy symmetry, if we switch the arguments in a type of f, e.g., if f is of type id /E,\nthen f is not minimal either. We have thus covered all possible types.\n□\nAnalogously, we ﬁnd that every minimal binary injection of type min is balanced\nor N-dominated.\nLemma 9.3.28. Let f be a binary canonical injection of type p1.\nIf f is not\nbalanced, E-dominated, N-dominated, of type id /E, or of type id /N, then f is not\nminimal.\nProof. If f is of type E/ id, E/−, −/ id, or −/−, then g(x, y) := f(x, f(x, y))\nis balanced and cannot reproduce f. If it is of type E/N or id /−, then g is of type\nE/ id, and we are back in the preceding case. Dually, if f is of type N/ id or N/−,\nthen g is balanced. If it is of type N/E, then g is of type N/ id, bringing us back to the\npreceding case. If it is of type −/E, then g is of type id /E and p1, and hence cannot\nreproduce f by Lemma 9.3.26. The dual argument works if f is of type −/N.\n□\nAnalogously, we ﬁnd that every minimal binary injection of type p2 is balanced,\nE-dominated, N-dominated, or of type E/ id.\n9.3.4. Producing functions that are not of type projection. Theorem 9.3.8\nand the following proposition together imply that indeed, if case (a) of Proposi-\ntion 9.3.4 does not apply, then one of the other cases does.\nProposition 9.3.29. Suppose that f is an operation on V that preserves the\nrelations E and N and violates the relation H1. Then f generates a binary injective\ncanonical operation of type min or max, or a ternary injective canonical operation of\ntype minority or majority.\nWe ﬁrst prove the following.\nLemma 9.3.30. Let f be an operation on (V; E) which preserves E and N and\nviolates H1. Then f generates a binary or ternary injection which shares the same\nproperties.\nProof. Since the relation H1 consists of three orbits of 6-tuples, by Lemma 5.3.5\nf generates an at most ternary function that violates H1, and hence we can assume\nwithout loss of generality that f itself is at most ternary.\nThe operation f must\ncertainly be essential, since essentially unary operations that preserve E and N also\npreserve H1. Applying Theorem 9.3.8, we get that f generates a binary injective\ncanonical function of type min, max, or p1. In the ﬁrst two cases we are done, since\nbinary injections of type min and max violate H1. So consider the last case and\n\n174\n9. SCHAEFER’S THEOREM FOR GRAPHS\ndenote the function of type p1 by g. By adding a dummy variable, we may assume\nthat f is ternary. Now consider\nh(x, y, z) := g(g(g(f(x, y, z), x), y), z) .\nThen h is clearly injective, and still violates H1 – the latter can easily be veriﬁed\ncombining the facts that f violates H1, g is of type p1, and all tuples in H1 have\npairwise distinct entries.\n□\nIt will turn out that just as in the proof of Lemma 9.3.30, there are two cases for\nf in the proof of Proposition 9.3.29: either all binary canonical injections generated\nby f are of type projection, and f generates an edge majority or an edge minority, or\nf generates a binary canonical injection of type min or max. We start by considering\nthe ﬁrst case, which is combinatorially less involved.\nProposition 9.3.31. Let f be an operation on (V; E) which preserves E and N\nand violates H. Suppose moreover that all binary injections generated by f are of\ntype p1 or p2. Then f generates a canonical ternary injection of type majority or\nminority.\nProof. By Lemma 9.3.30, we can assume that f is a binary or ternary injection;\nif it was binary, it would be of type projection and thus preserve H1, so it must be\nternary. Because f violates H1, there are x1, x2, x3 ∈H such that (f(x1), . . . , f(x6)) /∈\nH, where xi := (x1\ni , x2\ni , x3\ni ) for 1 ≤i ≤6.\nIf there was an automorphism α such that αxi = xj for i ̸= j ≤3, then f generates\na binary injection that still violates H1, which contradicts the assumption that all\nbinary injections generated by f are of type projection. By permuting arguments of\nf if necessary, we can therefore assume without loss of generality that\nE(x1\n1, x1\n2), N(x1\n3, x1\n4), N(x1\n5, x1\n6),\nN(x2\n1, x2\n2), E(x1\n3, x1\n4), N(x1\n5, x1\n6),\nN(x3\n1, x3\n2), N(x1\n3, x1\n4), E(x1\n5, x1\n6).\nWe set\nS := {y ∈V3 | NNN(xi, y) for all i ≤6} .\nConsider the binary relations Q1Q2Q3 on V3, where Qi ∈{E, N} for 1 ≤i ≤3;\neach of these relations deﬁnes a 2-type in (V; E)[3]. We claim that for every 2-type\ns deﬁned by one of those relations there is a 2-type s′ of (V; E) such that f satisﬁes\nthe type condition (s, s′) on S. To prove the claim, ﬁx a relation Q1Q2Q3 and let\nu, v ∈S be such that Q1Q2Q3(u, v) holds; we must show that whether E(f(u), f(v))\nor N(f(u), f(v)) depends only on Q1Q2Q3 (and not on u, v).\nWe go through all\npossibilities of Q1Q2Q3.\n(1) Q1Q2Q3 = ENN.\nLet α ∈Aut(V; E) be such that α(x2\n1, x2\n2, u2, v2) =\n(x3\n1, x3\n2, u3, v3); such an automorphism exists since NNN(x1, u), NNN(x1, u),\nNNN(x2, u), NNN(x2, v) and since (x2\n1, x2\n2) has the same type as (x3\n1, x3\n2),\nand (u2, v2) has the same type as (u3, v3). By assumption, the operation\ng deﬁned by g(x, y) := f(x, y, αy) must be of type projection.\nHence,\nE(g(u1, u2), g(v1, v2)) iﬀE(g(x1\n1, x2\n1), g(x1\n2, x2\n2)).\nCombining this with the\nequations (f(u), f(v)) = (g(u1, u2), g(v1, v2)) and (g(x1\n1, x2\n1), g(x1\n2, x2\n2)) =\n(f(x1), f(x2)), we get that E(f(u), f(v)) iﬀE(f(x1), f(x2)), and so we are\ndone.\n(2) Q1Q2Q3 = NEN or Q1Q2Q3 = NNE. These cases are analogous to the\nprevious case.\n\n9.3. FIRST-ORDER EXPANSIONS OF (V; E, N)\n175\n(3) Q1Q2Q3 = NEE. Let α be deﬁned as in the ﬁrst case. By assumption, the\noperation deﬁned by f(x, y, αy) must be of type projection. Reasoning as\nabove, one gets that E(f(u), f(v)) iﬀN(f(x1), f(x2)).\n(4) Q1Q2Q3 = ENE or Q1Q2Q3 = EEN. These cases are analogous to the\nprevious case.\n(5) Q1Q2Q3 = EEE or Q1Q2Q3 = NNN.\nThese cases are trivial since f\npreserves E and N.\nTo show that f generates an operation of type majority or minority, it suﬃces\nto prove that f generates a function of type majority or minority on S (that is, has\non S the same behavior as a function of type majority), since S contains copies of\narbitrary ﬁnite products of substructures of (V; E), and by Lemma 8.3.13. We prove\nthis by another case distinction, based on the fact that (f(x1), . . . , f(x6)) /∈H.\n(1) Suppose that E(f(x1), f(x2)), E(f(x3), f(x4)), E(f(x5), f(x6)). Then f it-\nself is of type minority on S.\n(2) Suppose that N(f(x1), f(x2)), N(f(x3), f(x4)), N(f(x5), f(x6)). Then f it-\nself is of type majority on S.\n(3) Suppose that E(f(x1), f(x2)), E(f(x3), f(x4)), N(f(x5), f(x6)). Let e be a\nself-embedding of (V; E) such that for all w ∈V and all i ≤6 we have\nthat N(xi, e(w)). Then (u1, u2, e(f(u1, u2, u3))) ∈S for all (u1, u2, u3) ∈S.\nHence, by the above, the ternary operation deﬁned by f(x, y, e(f(x, y, z)))\nis of type majority on S.\n(4) Suppose that E(f(x1), f(x2)), N(f(x3), f(x4)), and E(f(x5), f(x6)), or that\nN(f(x1), f(x2)), E(f(x3), f(x4)), and E(f(x5), f(x6)).\nThese cases are\nanalogous to the previous case.\nLet h(x, y, z) be a ternary injection of type majority or minority generated by f; it\nremains to make h canonical. By Theorem 9.3.8, f generates a binary canonical injec-\ntion g(x, y), which is of type projection by our assumption on f. Assume without loss\nof generality that it is of type p1 and set t(x, y, z) := g(x, g(y, z)). Then the function\nh(t(x, y, z), t(y, z, x), t(z, x, y)) is still of type majority or minority and canonical; we\nleave the straightforward veriﬁcation to the reader.\n□\nIn order to obtain a full proof of Proposition 9.3.29, it remains to show the\nfollowing proposition.\nProposition 9.3.32. Let f : V2 →V be a binary injection preserving E and N\nthat is neither of type p1 nor of type p2. Then f generates a binary injection of type\nmin or of type max.\nIn the remainder of this section we will show this by a Ramsey theoretic analysis\nof f. The global strategy behind what follows now is to take a binary injection f\nand ﬁx ﬁnitely many constants ¯c from V2 on which it can be seen that f is not of\ntype projection. Then, using Theorem 8.3.11, we generate a binary canonical function\nwhich is identical with f on all tuples with elements from ¯c; this canonical function\nthen still is not of type projection, and can be handled more easily because it is\ncanonical. To reduce the number of cases that we have to consider, we rule out some\nbehaviors of canonical functions already before introducing the constants.\nLemma 9.3.33. Suppose that f : V2 →V is injective and canonical, and suppose\nthat it is of type max/g or of type g/max, where g ∈{min, p1, p2}. Then f generates\na binary injection of type max.\nProof. Assume without loss of generality that f is of type max/g (when f is of\ntype g/max, replace f by f(x, ↔y), which is of type g/max). We also assume that f\nobeys p1 for the order (otherwise, continue with f(y, x) instead of f(y, x)).\n\n176\n9. SCHAEFER’S THEOREM FOR GRAPHS\nSet h(u, v) := f(u, ↔v). Then h behaves like g on input (<, <) and like max on\ninput (<, >); moreover, f(x1, x2) < f(y1, y2) iﬀh(x1, x2) < h(y1, y2), for all x1 ̸= y1\nand x2 ̸= y2. We then have that f(f(u, v), h(u, v)) is of type max/max, which means\nthat it is of type max.\n□\nLemma 9.3.34. Suppose that f : V2 →V is injective and canonical, and suppose\nthat it is of type min/pi or of type pi/min, where i ∈{1, 2}. Then f generates a\nbinary injection of type min.\nProof. The dual proof works.\n□\nLemma 9.3.35. Suppose that f : V 2 →V is injective and canonical as a function\nfrom (V ; E, ≺)2 to (V ; E, ≺), and suppose that it is of type max / min or of type\nmin / max. Then f generates a binary injection of type max (and by duality, a binary\ninjection of type min).\nProof. Assume without loss of generality that f is of type max / min, and\nremember that we may assume that f obeys p1 for the order.\nThen g(x, y) :=\nf(x, f(x, y)) is of type max /p1 and generates a binary injection of type max by\nLemma 9.3.33.\n□\nWe next consider the last remaining mixed behavior, p1/p2, by combining oper-\national with relational arguments.\nLemma 9.3.36. Let B be a structure that is ﬁrst-order deﬁnable in (V; E), con-\ntains the relations E, N, ̸=, and is preserved by a binary injection of type p1. Then\nthe following are equivalent.\n(1) B has a binary injective polymorphism of behavior min.\n(2) For every primitive positive formula φ over B, if φ∧N(x1, x2)∧V\n1≤i<j≤4 xi ̸=\nxj and φ ∧N(x3, x4) ∧V\n1≤i<j≤4 xi ̸= xj are satisﬁable over B, then φ ∧\nN(x1, x2) ∧N(x3, x4) is satisﬁable over B as well.\n(3) For every ﬁnite F ⊆V2 there exists a binary injective polymorphism of B\nwhich behaves like min on F.\nProof. The implication from (1) to (2) follows directly by applying a binary\ninjective polymorphism of behavior min to tuples r, s satisfying φ ∧N(x1, x2) ∧\nV\n1≤i<j≤4 xi ̸= xj and φ ∧N(x3, x4) ∧V\n1≤i<j≤4 xi ̸= xj, respectively.\nTo prove that (2) implies (3), assume (2) and let F ⊂V2 be ﬁnite. Without\nloss of generality we can assume that F is of the form {e1, . . . , en}2, for suﬃciently\nlarge n.\nLet A be the structure induced by F in B2.\nWe construct an injective\nhomomorphism h from ∆to B; every homomorphism can clearly be extended to a\nbinary polymorphism of B, for example inductively by using universality of (V; E).\nWe construct h in such a way that the extension behaves as min on F.\nTo construct h, consider the formula φ0 with variables xi,j for 1 ≤i, j ≤n which\nis the conjunction over all literals R(xi1,j1, . . . , xik,jk) such that R is a relation in\nB and R(ei1, . . . , eik) and R(ej1, . . . , ejk) hold in B. So φ0 states precisely which\nrelations hold in B2 on elements from F. Since B is preserved by a binary injection,\nwe have that φ1 := φ0 ∧V\n1≤i,j,k,l≤n,(i,j)̸=(k,l) xi,j ̸= xk,l is satisﬁable.\nLet P be the set of pairs of the form ((i1, i2), (j1, j2)) with i1, i2, j1, j2 ∈{1, . . . , n},\ni1 ̸= j1, i2 ̸= j2, and where N(ei1, ej1) or N(ei2, ej2). We show by induction on the\nsize of I ⊆P that the formula φ1 ∧V\n((i1,i2),(j1,j2))∈I N(xi1,i2, xj1,j2) is satisﬁable over\nB. Note that this statement applied to the set I = P gives us the a homomorphism\nh from A to B such that for all a, b ∈F we have N(h(a), h(b)) whenever EN(a, b)\n\n9.3. FIRST-ORDER EXPANSIONS OF (V; E, N)\n177\nor NE(a, b) by setting h(ei, ej) := s(xi,j), where s is the satisfying assignment for\nφ1 ∧V\n((i1,i2),(j1,j2))∈P N(xi1,i2, xj1,j2).\nFor the induction beginning, let p = ((i1, i2), (j1, j2)) be any element of P. Let\nr, s be the n2-tuples deﬁned as follows.\nr := (e1, . . . , e1, e2, . . . , e2, . . . , en, . . . , en)\ns := (e1, e2, . . . , en, e1, e2, . . . , en, . . . , e1, e2, . . . , en)\nIn the following we use double indices for the entries of n2-tuples; for example, r =\n(r1,1, . . . , r1,n, r2,1, . . . , rn,n). The two tuples r and s satisfy φ0. To see this, observe\nthat by deﬁnition of φ0 the tuple\n((e1, e1), . . . , (e1, en), (e2, e1), . . . , (en, en))\nsatisﬁes φ0 in B2; since r and s are projections of that tuple onto the ﬁrst and second\ncoordinate, respectively, and projections are homomorphisms, r and s satisfy φ0 as\nwell. Let g be a binary injective polymorphism of B which is of type p1, and set\nr′ := g(r, s) and s′ := g(s, r). Then r′ and s′ satisfy φ1 since g is injective. Since\np ∈P, we have that N(ei1, ej1) or N(ei2, ej2). Assume that N(ei1, ej1); the other\ncase is analogous. Since ri1,i2 = ei1, rj1,j2 = ej1, r′ := g(r, s), and g is of type p1, we\nhave that N(r′\ni1,i2, r′\nj1,j2), proving that φ1 ∧N(xi1,i2, xj1,j2) is satisﬁable in B.\nIn the induction step, let I ⊆P be a set of cardinality n ≥2, and assume that\nthe statement has been shown for subsets of P of cardinality n −1. Pick any distinct\nq1, q2 ∈I. We set\nψ := φ1 ∧\n^\n((i1,i2),(j1,j2))∈I\\{q1,q2}\nN(xi1,i2, xj1,j2)\nand observe that ψ is a primitive positive formula over B (here we use the as-\nsumption that B contains the relations N and ̸=).\nWrite q1 = ((u1, u2), (v1, v2))\nand q2 = ((u′\n1, u′\n2), (v′\n1, v′\n2)).\nThen the inductive assumption shows that each of\nψ ∧N(xu1,u2, xv1,v2) and ψ ∧N(xu′\n1,u′\n2, xv′\n1,v′\n2) is satisﬁable in B. Note that ψ con-\ntains in particular conjuncts that state that the four variables xu1,u2, xv1,v2, xu′\n1,u′\n2,\nxv′\n1,v′\n2 denote distinct elements. Hence, by (2), the formula ψ ∧N(xu1,u2, xv1,v2) ∧\nN(xu′\n1,u′\n2, xv′\n1,v′\n2) is satisﬁable over B as well, which is what we had to show.\nThe implication from (3) to (1) follows from Lemma 3.1.8.\n□\nLemma 9.3.37. Let f : V2 →V be a binary injection of behavior p1/p2 which\npreserves E and N. Then f generates a binary injection of type min and a binary\ninjection of type max.\nProof. By Theorem 9.3.8, f generates a binary injection of type max, min, or\np1. Suppose ﬁrst that it does not generate a binary injection of type max or min;\nwe will lead this to a contradiction. Let B be the structure with domain V that\ncontains all relations that are ﬁrst-order deﬁnable in (V; E) and that are preserved\nby f. Since f generates a binary injection of type p1, we may apply implication (2)\n→(1) from Lemma 9.3.36. Let φ be a primitive positive formula with variable set\nS, {x1, . . . , x4} ⊆S, such that the formulas φ ∧N(x1, x2) ∧V\ni<j≤4 xi ̸= xj and\nφ ∧N(x3, x4) ∧V\ni<j≤4 xi ̸= xj have in B the satisfying assignments r and s from\nS →V, respectively.\nWe can assume without loss of generality that r(x1) < r(x2) and r(x3) < r(x4);\notherwise, since r(x1), . . . , r(x4) must be pairwise distinct, we can apply an automor-\nphism of (V; E) to r such that the resulting map has the required property. Similarly,\n\n178\n9. SCHAEFER’S THEOREM FOR GRAPHS\nby applying an automorphism of (V; E) to s, we can assume without loss of general-\nity that s(x1) < s(x2) and s(x3) > s(x4). Then the mapping t: S →V deﬁned by\nt(x) = f(r(x), s(x)) shows that φ ∧N(x1, x2) ∧N(x3, x4) is satisﬁable in B:\n• The assignment t satisﬁes φ since f is a polymorphism of B.\n• We have that N(t(x1), t(x2)) since r(x1) < r(x2), s(x1) < s(x2), f is of type\np1 on input (<, <), and N(r(x1), r(x2)).\n• We have that N(t(x3), t(x4)) since r(x3) < r(x4), s(x3) > s(x4), f is of type\np2 on input (<, >), and N(s(x3), s(x4)).\nBy Lemma 9.3.36, we conclude that B is preserved by a binary injection of type min,\nand consequently f generates a binary injection of type min – a contradiction.\nTherefore, f generates a binary injection of type max or min. Since the assump-\ntions of the lemma are symmetric in E and N, we infer a posteriori that f generates\nboth a binary injection of type max and a binary injection of type min.\n□\nHaving ruled out some behaviors without constants, we now examine behaviors\nwhen we add constants to the language. In the sequel, we will also say that a function\nf : V2 →V has behavior B between two points x, y ∈V2 if it has behavior B on {x, y}.\nLemma 9.3.38. Let u ∈V2, and set U := (V \\ {u1}) × (V \\ {u2}). Let f : V2 →V\nbe a binary injection which preserves E and N, behaves like p1 between all points\nv, w ∈U, and which behaves like p2 between u and all points in U. Then f generates\na binary injection of type min as well as a binary injection of type max.\nProof. Let B be the structure with domain V that contains all relations that\nare ﬁrst-order deﬁnable in (V; E) and that are preserved by f.\nSince U contains\ncopies of products of arbitrary ﬁnite graphs, f behaves like p1 on arbitrarily large\nﬁnite substructures of (V; E)2, and hence generates a binary injection of type p1 by\nLemma 8.3.13. Hence B is also preserved by such a function, and we may apply the\nimplication from (2) to (1) in Lemma 9.3.36 to B.\nLet φ be a primitive positive formula with variable set S, {x1, . . . , x4} ⊆S, such\nthat φ ∧N(x1, x2) ∧V\n1≤i<j≤4 xi ̸= xj and φ ∧N(x3, x4) ∧V\n1≤i<j≤4 xi ̸= xj are\nsatisﬁable over B, witnessed by satisfying assignments r, s: S →V, respectively.\nLet α be an automorphism of (V; E) that maps r(x3) to u1, and let β be an\nautomorphism of (V; E) that maps s(x3) to u2.\nThen (αr(x3), βs(x3)) = u, and\nv := (αr(x4), βs(x4)) ∈U since αr(x4) ̸= αr(x3) = u1 and βs(x4) ̸= βs(x3) = u2.\nThus, f behaves like p2 between u and v, and since s satisﬁes N(x3, x4), we have that\nt: S →V deﬁned by\nt(x) = f(αx, βx)\nsatisﬁes N(x3, x4), too. Since α, β, f are polymorphisms of B, the assignment t also\nsatisﬁes φ. To see that N(t(x1), t(x2)), observe that αr(x1) ̸= αr(x3) and βs(x1) ̸=\nβs(x3), and hence p := (αr(x1), βs(x1)) /∈U. Similarly, q := (αr(x2), βs(x2)) /∈U.\nHence, f behaves as p1 between p and q, and since N(r(x1), r(x2)), so does t.\nBy Lemma 9.3.36 we conclude that B is preserved by a binary injection of type\nmin, and consequently f generates a binary injection of type min.\nSince our assumptions on f were symmetric in E and N, it follows that f also\ngenerates a binary injection of type max.\n□\nLemma 9.3.39. Let u ∈V2, and let f : V2 →V be a binary injection that behaves\nlike p1 between all points v, w ∈U := (V \\ {u1}) × (V \\ {u2}), and which behaves like\nmin between u and all points in U. Then f generates a binary injection of type min.\nProof. The proof is identical with the proof in the preceding lemma; note that\nour assumptions on f here imply more deletions of edges as the assumptions in that\nlemma, so it can only be easier to generate a binary injection of type min.\n□\n\n9.3. FIRST-ORDER EXPANSIONS OF (V; E, N)\n179\nLemma 9.3.40. Let u, v ∈V2 such that ̸≠=(u, v) and set W := (V \\ {u1, v1}) ×\n(V \\ {u2, v2}). Let f : V2 →V be a binary injection that\n• preserves E and N\n• behaves like p1 between all points w, r ∈W\n• behaves like p1 between u and all points w ∈W\n• behaves like p1 between v and all points w ∈W\n• does not behave like p1 between u and v.\nThen f generates a binary injection of type min as wella s a binary injection of type\nmax.\nProof. We have to consider the case that EN(u, v) and N(f(u), f(v)), and the\ncase that NE(u, v) and E(f(u), f(v)). In the ﬁrst case we prove that f generates a\nbinary injection of type min; it then follows by duality that in the second case, f\ngenerates a binary injection of type max.\nAs in Lemma 9.3.38, we apply the implication (2) →(1) from Lemma 9.3.36. Let\nB, φ, x1, . . . , x4, and S be as in the proof of Lemma 9.3.38; by the same argument\nas before, B is preserved by a binary injection of type p1. If N(r(x3), r(x4)), then\nthe assignment r shows that φ ∧N(x1, x2) ∧N(x3, x4) is satisﬁable and we are done.\nOtherwise, since r(x3) ̸= r(x4), we have E(r(x3), r(x4)). Therefore, there is an α ∈\nAut(V; E) such that (αr(x3), αr(x4)) = (u1, v1). Similarly, since N(s(x3), s(x4)) and\nN(u2, v2), there is a β ∈Aut(V; E) such that (βs(x3), βs(x4)) = (u2, v2). We claim\nthat the map t: S →V deﬁned by\nt(x) = f(αx, βx)\nis a satisfying assignment for φ ∧N(x1, x2) ∧N(x3, x4). The assignment t satisﬁes\nφ since α, β and f are polymorphisms of B.\nThen N(t(x3), t(x4)) holds because\n(αr(x3), βs(x3)) = u and (αr(x4), βs(x4)) = v, and N(f(u), f(v)). To prove that\nN(t(x1), t(x2)) holds, observe that r(x1) ̸= r(x3) and r(x1) ̸= r(x4), and hence\nαr(x1) /∈{αr(x3), αr(x4)} = {u1, v1} .\nSimilarly, βs(x1) /∈{βs(x3), βs(x4)} = {u2, v2}. Hence, (αr(x1), βs(x1) ∈W. A\nsimilar argument for x2 in place of x1 shows that (αr(x2), βs(x2) ∈W.\nSince f\nbehaves like p1 between all points of W, and since r satisﬁes N(x1, x2), we have\nproved the claim. This shows that B is preserved by a binary injection of type min,\nand hence f generates such a function.\nBy symmetry of our assumptions on f in E and N, it follows that f generates\na binary injection of type min if and only if it generates a binary injection of type\nmax.\n□\nWe are now set up to prove Proposition 9.3.32, and hence complete the proof of\nProposition 9.3.29.\nProof of Proposition 9.3.32. Let f be given. By Theorem 9.3.8, f generates\na binary canonical injection g of type projection, min, or max. In the last two cases we\nare done, so consider the ﬁrst case. We claim that f also generates a (not necessarily\ncanonical) binary injection h of type min or max. Then h(g(x, y), g(y, x)) is still of\ntype min or max and in addition canonical, and the proposition follows.\nTo prove our claim, ﬁx a ﬁnite set C := {c1, . . . , cm} ⊆V such that the fact that\nf does not behave like a projection is witnessed on C. Invoking Theorem 8.3.11, we\nmay henceforth assume that f is canonical as a function from (V; E, <, c1, . . . , cm)2\nto (V; E, <) (and hence also to (V; E) since tuples of equal type in (V; E, <) have\nequal type in (V; E)). It is clear that this new f must be injective.\n\n180\n9. SCHAEFER’S THEOREM FOR GRAPHS\nIn the following we consider orbits of elements in the structure (V; E, <, c1, . . . , cm).\nThe inﬁnite orbits are precisely the sets of the form\n{v ∈V | Qi(v, ci) and Ri(v, ci) for all 1 ≤i ≤m},\nfor Q1, . . . , Qm ∈{E, N}, and R1, . . . , Rm ∈{<, >}. The ﬁnite orbits are of the form\n{ci} for some 1 ≤i ≤m. Each inﬁnite orbit of (V; E, <, c1, . . . , cm) contains copies of\narbitrary linearly ordered ﬁnite graphs, and in particular, forgetting about the order,\nof all ﬁnite graphs.\nTherefore, if f behaves like min or max on an inﬁnite orbit of (V; E, <, c1, . . . , cm),\nthen by Lemma 8.3.13 it generates a function which behaves like min or max every-\nwhere, and we are done. Moreover, if f is of mixed type on an inﬁnite orbit, then,\nagain by Lemma 8.3.13, f generates a canonical function which has the same mixed\nbehavior everywhere. But then we are done by Lemmas 9.3.33, 9.3.34, and 9.3.37.\nHence, we may henceforth assume that f behaves like a projection on every inﬁnite\norbit. Fix in the following an inﬁnite orbit O and assume without loss of generality\nthat f behaves like p1 on O.\nNow suppose that there exists an inﬁnite orbit W such that f behaves like p2\nbetween all points u ∈O2 and v ∈W 2 for which u1 < v1 and u2 < v2. Then ﬁx\nany v ∈W 2, and set O1 := {o ∈O | o < v1} and O2 := {o ∈O | o < v2}. Set\nO′\n1 := O1 ∪{v1} and O′\n2 := O2 ∪{v2}. We then have that f behaves like p2 between\nv and any point u of (O′\n1 \\ {v1}) × (O′\n2 \\ {v2}), and like p1 between any two points of\n(O′\n1 \\{v1})×(O′\n2 \\{v2}). Since (O′\ni; E, vi) contains copies of all ﬁnite substructures of\n(V; E, vi), for i ∈{1, 2}, by Lemma 8.3.13 we get that f generates a function which\nbehaves like p2 between v and any point u of (V\\{v1})×(V\\{v2}), and which behaves\nlike p1 between any two points of (V \\ {v1}) × (V \\ {v2}). Then Lemma 9.3.38 implies\nthat f generates a binary injection of type min and we are done.\nThis argument is easily adapted to any situation where there exists an inﬁnite\norbit W such that f behaves like p2 between all points u ∈O2 and v ∈W 2 with\nR1(u1, v1) and R2(u2, v2), for R1, R2 ∈{<, >}.\nWhen there exists an inﬁnite orbit W such that f behaves like min between\nall points u ∈O2 and v ∈W 2 with R1(u1, v1) and R2(u2, v2), then we can argue\nsimilarly, invoking Lemma 9.3.39 at the end. Replacing min by max we can use the\ndual argument, with the notable diﬀerence that f generates a binary injection of type\nmax rather than min.\nSince f is canonical, one of the situations described so far must occur. Putting\nthis together, we conclude that for every inﬁnite orbit W and all points u ∈O2 and\nv ∈W 2, f behaves like p1 between u and v. Having that, suppose that for an inﬁnite\norbit W, f behaves like p2 on W. Then exchanging the roles of O and W and of p1 and\np2 above, we can again conclude that f generates a binary injection of type min. We\nmay thus henceforth assume that f behaves like p1 between all points u, v ∈(V\\C)2.\nPick any u ∈C2.\nSuppose that there exists v ∈(V \\ C)2 such that f does\nnot behave like p1 between u and v; say without loss of generality that EN(u, v)\nand N(f(u), f(v)). Let Oi be the (inﬁnite) orbit of vi, for i ∈{1, 2}. Then for all\nv ∈O1 × O2 we have EN(u, v) and N(f(u), f(v)) since f is canonical.\nNow let\nw ∈O2 × O1. We distinguish the two cases E(f(u), f(w)) and N(f(u), f(w)). In the\nﬁrst case, f behaves like p2 between u and all v ∈(O1 ∪O2)2. We can then argue\nas above and are done. In the second case, f behaves like min between u and all\nv ∈(O1 ∪O2)2, and we are again done by the corresponding argument above. We\nconclude that we may assume that for all u ∈C2 and all v ∈(V \\ C)2, f behaves like\np1 between u and v as well.\n\n9.4. FIRST-ORDER EXPANSIONS OF (V; R(3), S(3))\n181\nNow pick u, v ∈C2 such that f does not behave like p1 between u and v, say\nwithout loss of generality EN(u, v) and N(f(u), f(v)); this is possible since the fact\nthat f does not behave like p1 everywhere is witnessed on C. Pick any 16 inﬁnite\norbits O1, . . . , O16 such that for all Q1, Q2, R1, R2 ∈{E, N} there exists w ∈(O1 ∪\n· · · ∪O16)2 with Q1Q2(u, w) and R1R2(v, w). Set S1 := {u1, v1} ∪O1 ∪· · · ∪O16 and\nS2 := {u2, v2} ∪O1 ∪· · · ∪O16. Then Si contains copies of all ﬁnite substructures\nof (V; E, ui, vi), for i ∈{1, 2}, and hence applying Lemma 8.3.13 to functions from\n(V; E, u1, v1)×(V; E, u2, v2) to (V; E) we see that f generates a function which behaves\nlike p2 between u and v, like p1 between u and all points w ∈(V \\ {u1, v1}) × (V \\\n{u2, v2}), like p1 between v and all points w ∈(V \\ {u1, v1}) × (V \\ {u2, v2}), and like\np1 between any two points w, r ∈(V\\{u1, v1})×(V\\{u2, v2}). But then we are done\nby Lemma 9.3.40.\n□\n9.4. First-order Expansions of (V; R(3), S(3))\nThe structure of this section will be similar to the one of Section 9.3, but R(3) will\ntake the role of E, and S(3) will take the role of N. The relation H1 will be replaced\nby the following relation.\nDefinition 9.4.1. Let H2 be the smallest 9-ary relation that is preserved by {sw}\nand contains all tuples (x1, y1, z1, x2, y2, z2, x3, y3, z3) ∈V9 such that\n^\ni,j∈{1,2,3},i̸=j,u∈{xi,yi,zi},v∈{xj,yj,zj}\nN(u, v)\n∧\n\u0000(R(3)(x1, y1, z1) ∧S(3)(x2, y2, z2) ∧S(3)(x3, y3, z3))\n∨(S(3)(x1, y1, z1) ∧R(3)(x2, y2, z2) ∧S(3)(x3, y3, z3))\n∨(S(3)(x1, y1, z1) ∧S(3)(x2, y2, z2) ∧R(3)(x3, y3, z3))\n\u0001\n.\nProposition 9.4.2. Let B be a reduct of (V; E) whose endomorphisms are pre-\ncisely the unary functions generated by {sw}. Then either H2 is primitive positive\ndeﬁnable in B, or B satisﬁes item (b) or (d) of Proposition 9.3.4.\nProposition 9.4.3. There is a primitive positive interpretation of ({0, 1}; 1IN3)\nin (V; H2), and CSP(V; H2) is NP-hard.\nProof. This can be shown analogously to Proposition 9.3.5, but this time we\nrepresent 1 by triples from R(3) instead of pairs that satisfy E, and 0 by triples from\nS(3), and then use H2 analogously as we have used H1 in the proof of Proposition 9.3.5.\n□\n9.4.1. Producing canonical functions of type projection. As in Section 9.3.2,\nwe show that if B has an essential polymorphism f, then it must also contain a binary\ninjective polymorphism. Every binary injective function generates a binary injective\ncanonical function, and those can be classiﬁed similarly as in Section 9.3.3. Luckily,\neven though we do not work in this section under the assumption that E and N are\npreserved by f, we are able to reduce to this case in our argument.\nProposition 9.4.4. Suppose that B has an essential polymorphism. Then B is\npreserved by a constant function, eE, eN, or by a canonical binary injection of type\nmin, max, or p1.\nProof. If there is a primitive positive deﬁnition of E and N, then the statement\nfollows from Theorem 9.3.8. So suppose that this is not that case; also suppose that B\nis not preserved by eE, eN, or a constant function. Then Aut(B) is dense in End(B)\nby Proposition 9.2.2, and so they must violate E and N as otherwise these relations\n\n182\n9. SCHAEFER’S THEOREM FOR GRAPHS\nwould have a primitive positive deﬁnition. By Theorem 9.2.6, we then see that Aut(B)\nis 2-transitive. By Theorem 6.2.1, B has a binary injective polymorphism g. Since\n(V; E, ≺) is Ramsey (Example 8.1.7), we can apply Corollary 8.3.6 and obtain that g\ngenerates a binary injective function h which is canonical as a function from (V; E, ≺)2\nto (V; E, ≺). The function x 7→h(x, x) either preserves E and N, or behaves like −,\neE or eN. We can assume that it does not behave like eE or eN, and if it behaves\nlike −, we can replace h by −h and assume that x 7→h(x, x) preserves E and N.\nNow consider the function x 7→h(x, α(x)), where α ∈Aut(V; E) reverses ≺. Again,\nwe may exclude the possibility that it behaves like eE or eN. But then the function\n(x, y) 7→h(h(x, y), h(y, x)) preserves E and N and we can apply Theorem 9.3.8 to\nconclude that it generates a binary injection which is canonical as a function from\n(V; E)2 to (V; E) and of type min, max, or p1.\n□\nCorollary 9.4.5. Let B = (V; R(3), S(3), . . .) be ﬁrst-order deﬁnable over (V; E)\nwith an essential polymorphism. Then B is preserved by a binary canonical injection\nof type p1.\nProof. Since eN and functions of type min do not preserve R(3) and eE and\nfunctions of type max do not preserve S(3), Proposition 9.4.4 implies that B is pre-\nserved by a binary canonical injection of type p1.\n□\n9.4.2. Eliminating mixed behavior.\nLemma 9.4.6. Let f : V2 →V be a binary injection that preserves R(3) and S(3).\nThen f is not of type p1/p2.\nProof. Suppose for contradiction that f does have the behavior p1/p2.\nLet\nu1, u2, u3 ∈V with u1 ≺u2 ≺u3, E(u1, u2), N(u2, u3), and N(u1, u3). Let v1, v2, v3 ∈\nV with v1 ≺v2 ≺v3 and N(v1, v2), E(v2, v3), N(v1, v3). Then E(f(u1, v1), f(u2, v3))\nand N(f(u1, v1), f(u3, v2)) since f behaves like p1 on input (≺, ≺). Moreover, we have\nE(f(u2, v3), f(u3, v2)) since f behaves like p2 on input (≺, ≻). Then (u1, u2, u3) ∈\nR(3) and (u1, u2, u3) ∈R(3), but (f(u1, v2), f(u2, v3), f(u3, v2)) /∈R(3), in contradic-\ntion to our assumptions.\n□\n9.4.3. Behaviors relative to vertices.\nLemma 9.4.7. Let u ∈V2, and set U := (V \\ {u1}) × (V \\ {u2}). Let f : V2 →V\nbe a binary injection which behaves like p1 on U, and which behaves like p2 or max\nbetween u and all points in U. Then f does not preserve R(3).\nProof. Let v, w ∈U be such that NE(u, v), EN(v, w), and NN(u, w). Then\nwe have E(f(u), f(v)), E(f(v), f(w)), and N(f(u), f(w)). Hence, R(3)(ui, vi, w) for\ni ∈{1, 2}, but S(3)(f(u), f(v), f(w)).\n□\nDefinition 9.4.8. We say that a binary injective function f : V2 →V is\n• of type R(3)-pi, for i ∈{1, 2}, iﬀfor all u, v, w ∈V2 with ̸≠=(u, v), ̸≠=(v, w),\nand ̸≠=(u, w) we have R(3)(f(u), f(v), f(w)) if and only if R(3)(ui, vi, wi).\n• of type R(3)-projection iﬀit is of type R(3)-p1 or of type R(3)-p2.\nProposition 9.4.9. Suppose that f : V2 →V preserves R(3) and S(3)). Then f\nis of type R(3)-projection.\nProof. The proof is similar to the proof of Proposition 9.3.32.\nFix a ﬁnite\nset C := {c1, . . . , cm} ⊆V such that the fact that f is not of type R(3)-projection\nis witnessed on C. Invoking Theorem 8.3.11, we may henceforth assume that f is\ncanonical as a function from (V; E, ≺, c1, . . . , cm)2 to (V; E, ≺).\n\n9.4. FIRST-ORDER EXPANSIONS OF (V; R(3), S(3))\n183\nIn the following we consider orbits in the structure (V; E, ≺, c1, . . . , cm).\nThe\ninﬁnite orbits are precisely the sets of the form\n{v ∈V | Qi(v, ci) and Ri(v, ci) for all 1 ≤i ≤m},\nfor Q1, . . . , Qm ∈{E, N}, and R1, . . . , Rm ∈{≺, ≻}. The ﬁnite orbits are of the\nform {ci} for some 1 ≤i ≤m. Each inﬁnite orbit of (V; E, ≺, c1, . . . , cm) induces\nin (V; E, ≺) a structure isomorphic to (V; E, ≺). Lemma 8.3.14 implies that if f has\na certain behaviour on such an inﬁnite orbit, then it generates a canonical function\nwhich has the same behaviour everywhere. Therefore we have for all inﬁnite orbits O\nthat f\n• cannot be of type min or max on O since it preserves R(3) and S(3);\n• cannot have behaviour max /pi or pi/ max for i ∈{1, 2} on O, by Lemma 9.3.33;\n• cannot have behaviour min /pi or pi/ min for i ∈{1, 2} on O, by 9.3.34;\n• it cannot have behaviour max / min or min / max on O, by Lemma 9.3.35;\n• it cannot have behavior p1/p2 or p2/p1 on O, by Lemma 9.4.6.\nHence, we may assume that f behaves like a projection on every inﬁnite orbit. Fix in\nthe following an inﬁnite orbit O and assume without loss of generality that f behaves\nlike p1 on O.\nLet W be any inﬁnite orbit. Then since f is canonical, it behaves like p1, p2, min,\nor max between all u, v with u ∈O2, v ∈W 2 and u1 ≺v1 and u2 ≺v2. Consider\nthe case where there exists an inﬁnite orbit W such that f behaves like p2 or max\nbetween all points u ∈O2 and v ∈W 2 for which u1 ≺v1 and u2 ≺v2. Then ﬁx\nany v ∈W 2, and set O1 := {o ∈O | o ≺v1} and O2 := {o ∈O | o ≺v2}. Set\nO′\n1 := O1 ∪{v1} and O′\n2 := O2 ∪{v2}. We then have that f behaves like p2 or max\nbetween v and any point u of (O′\n1 \\ {v1}) × (O′\n2 \\ {v2}), and like p1 between any two\npoints of (O′\n1 \\ {v1}) × (O′\n2 \\ {v2}). Since (O′\ni; E, vi) is isomorphic to (V; E, vi), for\ni ∈{1, 2}, by Lemma 8.3.14 we get that f generates a function which behaves like p2\nor max between v and any point u of (V\\{v1})×(V\\{v2}), and which behaves like p1\nbetween any two points of (V\\{v1})×(V\\{v2}). This is impossible by Lemma 9.4.7.\nThis argument is easily adapted to any situation where there exists an inﬁnite orbit\nW such that f behaves like p2 between all points u ∈O2 and v ∈W 2 with R1(u1, v1)\nand R2(u2, v2), for R1, R2 ∈{≺, ≻}. When there exists an inﬁnite orbit W such\nthat f behaves like min between all points u ∈O2 and v ∈W 2 with R1(u1, v1) and\nR2(u2, v2), then we can argue similarly.\nSince f is canonical, one of the situations described so far must occur. Putting\nthis together, we conclude that for every inﬁnite orbit W and all points u ∈O2 and\nv ∈W 2, f behaves like p1 between u and v. Having that, suppose that for an inﬁnite\norbit W, f behaves like p2 on W. Then exchanging the roles of O and W and of p1\nand p2 above, we again arrive at a contradiction. We may thus henceforth assume\nthat f behaves like p1 on (V \\ C)2.\nPick any u ∈C2.\nSuppose that there exists v ∈(V \\ C)2 such that f does\nnot behave like p1 between u and v. Assume ﬁrst that EN(u, v) and N(f(u), f(v)).\nLet Oi be the (inﬁnite) orbit of vi, for i ∈{1, 2}. Then for all v ∈O1 × O2 we have\nEN(u, v) and N(f(u), f(v)) since f is canonical. Now let w ∈O2×O1. We distinguish\nthe two cases E(f(u), f(w)) and N(f(u), f(w)). In the ﬁrst case, f behaves like p2\nbetween u and all v ∈(O1 ∪O2)2. We can then argue as above and are done. In\nthe second case, f behaves like min between u and all v ∈(O1 ∪O2)2, and we are\nagain done by the corresponding argument above. The dual argument works when\nNE(u, v) and E(f(u), f(v)).\nNow assume that EE(u, v) and N(f(u), f(v)).\nWe\nclaim that EE(u, v′) implies N(f(u), f(v′)) and NN(u, v′) implies E(f(u), f(v′)) for\nall v′ ∈(V \\ C)2. Suppose that v′ ∈(V \\ C)2 is a counterexample. We can ﬁnd\n\n184\n9. SCHAEFER’S THEOREM FOR GRAPHS\nv′′ ∈(V \\ C)2 such that v′\n1, v′′\n1 and v′\n2, v′′\n2 belong to the same orbit and such that\nR(3)(ui, vi, v′′\ni ) for i ∈{1, 2}. But then S(3)(f(u), f(v), f(v′′)), a contradiction. By\napplying a version of sw which switches edges and non-edges with respect to f[C2]\nto f from the left, we may assume that f behaves like p1 between all u ∈C2 and all\nv ∈(V \\ C)2\nSince f does not behave like R(3)-p1 on C2, in particular it does not behave like\np1 on C2. Pick u, v ∈C2 witnessing this. Then f behaves like p1 between any point\nin {u, v} and any point in (V \\ C)2. Since (V \\ C) ∪{ui, vi} induces an isomorphic\ncopy of the random graph for i ∈{1, 2}, we can refer to Lemma 9.3.40 to arrive at\na contradiction: f generates eE, eN, or a binary injection of type min or max, all of\nwhich violate either R(3) or S(3).\n□\nDefinition 9.4.10. We say that a ternary injective function f : V3 →V is\n• of type R(3)-majority iﬀfor all u, v, w ∈V3 with ̸≠≠=(u, v), ̸≠≠=(u, w),\n̸≠≠=(v, w) we have R(3)(f(u), f(v), f(w)) if and only if R(3)R(3)R(3)(u, v, w),\nR(3)R(3)S(3)(u, v, w), R(3)S(3)R(3)(u, v, w), or S(3)R(3)R(3)(u, v, w).\n• of type R(3)-minority iﬀfor all u, v, w ∈V3 with ̸≠≠=(u, v), ̸≠≠=(u, w),\n̸≠≠=(v, w) we have R(3)(f(u), f(v), f(w)) if and only if R(3)R(3)R(3)(u, v, w),\nR(3)S(3)S(3)(u, v, w), S(3)R(3)S(3)(u, v, w), or S(3)S(3)R(3)(u, v, w).\nLemma 9.4.11. Functions f : V3 →V of type R(3)-majority do not preserve R(3).\nProof. Let u1, u2, u3 ∈V4 be such that\n• E(u1\n1, u1\n2) and N(u1\ni , u1\nj) for all pairs (i, j) of distinct elements from {1, . . . , 4}\nthat are distinct from (1, 2).\n• E(u2\n2, u2\n3) and N(u1\ni , u1\nj) for all pairs (i, j) of distinct elements from {1, . . . , 4}\nthat are distinct from (2, 3).\n• E(u3\n1, u3\n3) and N(u3\ni , u3\nj) for all pairs (i, j) of distinct elements from {1, . . . , 4}\nthat are distinct from (1, 3).\nSince f is of type R(3)-majority S(3)(f(u1), f(u2), f(u4)), S(3)(f(u1), f(u3), f(u4)),\nand S(3)(f(u2), f(u3), f(u4)). Since for all four-element subsets of V there must always\nbe an even number of three-element subsets in R(3), we have S(3)(f(x1), f(x2), f(x3)),\nand hence f does not preserve R(3).\n□\nLemma 9.4.12. Let f : V3 →V be of type R(3)-minority. Then {f, sw} generates\na function of type minority.\nProof. Let g be any ternary injection of type minority, and let u, v, w ∈V3 with\n̸≠≠=(u, v), ̸≠≠=(u, w), ̸≠≠=(v, w) be given. We will show that R(3)(g(u), g(v), g(w))\nif and only if R(3)(f(u), f(v), f(w)). Recall that R(3)(f(u), f(v), f(w)) if and only if\nR(3)S(3)S(3)(u, v, w),\nS(3)R(3)S(3)(u, v, w),\nS(3)S(3)R(3)(u, v, w),\nor R(3)R(3)R(3)(u, v, w) .\nThis is in turn the case if and only if the cardinality of the set\nE ∩\n[\ni∈{1,2,3}\n{(ui, vi), (ui, wi), (vi, wi)}\nis odd, which is the case if and only if E ∩{(g(u), g(v)), (g(u), g(w)), (g(v), g(w))} is\nodd, which is the case if and only if R(3)(g(u), g(v), g(w)) holds.\n\n9.4. FIRST-ORDER EXPANSIONS OF (V; R(3), S(3))\n185\nBy Corollary 9.4.5, f generates a binary canonical injection s(x, y) of type p1.\nSet t(x, y, z) := s(x, s(y, z)).\nAs in the proof of Proposition 9.3.31 the function\np(x, y, z) := f(t(x, y, z), t(y, z, x), t(z, x, y)) is still of type R(3)-minority, and the func-\ntion q(x, y, z) := g(t(x, y, z), t(y, z, x), t(z, x, y)) is still of type minority. Moreover, by\nthe above we have R(3)(p(u), p(v), p(w)) if and only if R(3)(q(u), q(v), q(w)) for all\nu, v, w ∈V3, since t is injective. Therefore, the homogeneity of (V; R(3)) implies that\nfor all ﬁnite S ⊆V3 there exists a unary operation a generated by {sw} such that the\nternary function a(p(x, y, z)) agrees with q(x, y, z) on S. By local closure, q is thus\ngenerated by {f, sw}.\n□\nLemma 9.4.13. Let B = (V; R(3), S(3), . . .) be a reduct of (V; E) such that H2 is\nnot primitive positive deﬁnable. Then B has a ternary injective polymorphism which\nviolates H2.\nProof. Since the relation H2 consists of three orbits of 9-tuples in Aut(V; R(3)),\nLemma 5.3.5 implies that f generates an at most ternary function that violates H2,\nand hence we can assume that f itself is at most ternary; by adding a dummy variable\nif necessary, we may assume that f is actually ternary. Moreover, f must certainly be\nessential, since essentially unary operations that preserve R(3) and S(3) are generated\nby {sw} and hence also preserve H2. Corollary 9.4.5 implies that B is preserved by\na binary canonical injection g of type p1. Consider\nh(x, y, z) := g(g(g(f(x, y, z), x), y), z) .\nThen h is clearly injective, and still violates H2 – the latter can easily be veriﬁed\ncombining the facts that f violates H2, g is of type p1, and all tuples in H2 have\npairwise distinct entries.\n□\nProposition 9.4.14. Let f be an operation on (V; E) that preserves R(3) and\nS(3) and violates H2. Then {f, sw} generates a ternary canonical injection of type\nminority.\nProof. The proof is similar to the proof of Proposition 9.3.31. By Lemma 9.4.13,\nwe can assume that f is a ternary injection.\nBecause f violates H2, there are\nx1, x2, x3 ∈H2 such that f(x1, x2, x3) /∈H2. In the following, we will write xi :=\n(x1\ni , x2\ni , x3\ni ) for 1 ≤i ≤9. So (f(x1), . . . , f(x9)) /∈H2. If there were a map a generated\nby sw such that a(xi) = xj for 1 ≤i ̸= j ≤3, then {f, sw} would generate a binary\ninjection that still violates H2. Proposition 9.4.9 asserts that all binary injections\ngenerated by {f, sw} are of type R(3)-projection, so we have reached a contradiction\nsince operations of type R(3)-projection preserve H2. By permuting arguments of f\nif necessary, we can therefore assume without loss of generality that\nR(3)S(3)S(3)(x1, x2, x3), S(3)R(3)S(3)(x4, x5, x6), and S(3)S(3)R(3)(x7, x8, x9).\nWe set\nS := {y ∈V3 | NNN(xi, y) for all 1 ≤i ≤9} .\nConsider the ternary relations Q1Q2Q3 on V3, where Qi ∈{R(3), S(3)} for 1 ≤i ≤3;\neach of these relations deﬁnes a 3-type in (V; R(3)). We claim that for ﬁxed Q1Q2Q3,\nwhether or not R(3)(f(u), f(v), f(w)) holds for u, v, w ∈S with Q1Q2Q3(u, v, w) does\nnot depend on u, v, w. We go through all possibilities of Q1Q2Q3.\n(1) Q1Q2Q3 = R(3)S(3)S(3).\nLet α ∈Aut(V; R(3)) be such that the tuple\n(x2\n1, x2\n2, x2\n3, u2, v2, w2) is mapped to (x3\n1, x3\n2, x3\n3, u3, v3, w3); such an automor-\nphism exists since NNN(x1, u), NNN(x1, v), NNN(x1, w), NNN(x2, u),\nNNN(x2, v), NNN(x2, w) and since the tuple (x2\n1, x2\n2, x2\n3) has the same type\n\n186\n9. SCHAEFER’S THEOREM FOR GRAPHS\nas (x3\n1, x3\n2, x3\n3), and (u2, v2, w2) has the same type as (u3, v3, w3) in (V; R(3)).\nBy Proposition 9.4.9, the operation g deﬁned by g(x, y) := f(x, y, α(y))\nmust be of type R(3)-projection. Hence, R(3)(g(u1, u2), g(v1, v2), g(w1, w2))\niﬀR(3)(g(x1\n1, x2\n1), g(x1\n2, x2\n2), g(x1\n3, x2\n3)). Combining this with the equations\n(f(u), f(v), f(w)) = (g(u1, u2), g(v1, v2), g(w1, w2)) and\n(g(x1\n1, x2\n1), g(x1\n2, x2\n2), g(x1\n3, x2\n3)) = (f(x1), f(x2), f(x3))\nwe get that R(3)(f(u), f(v), f(w)) iﬀR(3)(f(x1), f(x2), f(x3)), and so we are\ndone.\n(2) Q1Q2Q3 = S(3)R(3)S(3) or Q1Q2Q3 = S(3)S(3)R(3). These cases are analo-\ngous to the previous case.\n(3) Q1Q2Q3 = S(3)R(3)R(3). Let α be deﬁned as in the ﬁrst case. By Propo-\nsition 9.4.9, the operation deﬁned by f(x, y, α(y)) must be of type pro-\njection.\nReasoning as above, one obtains that R(3)(f(u), f(v), f(w)) iﬀ\nS(3)(f(x1), f(x2), f(x3)).\n(4) Q1Q2Q3 = R(3)S(3)R(3) or Q1Q2Q3 = R(3)R(3)S(3). These cases are analo-\ngous to the previous case.\n(5) Q1Q2Q3 = R(3)R(3)R(3) or Q1Q2Q3 = S(3)S(3)S(3). These cases are trivial\nsince f preserves R(3) and S(3).\nTo show that f generates an operation of type minority, by Lemma 8.3.14 it\nsuﬃces to prove that f generates a function of type minority on S, since S is the\nproduct of isomorphic copies of (V; E). We show this by another case distinction,\nbased on the fact that (f(x1), . . . , f(x9)) /∈H2.\n(1) Suppose that R(3)(f(x1), f(x2), f(x3)), R(3)(f(x4), f(x5), f(x6)) and that\nR(3)(f(x7), f(x8), f(x9)).\nBy the above, note that R(3)(f(u), f(v), f(w))\nfor u, v, w ∈S if and only if R(3)S(3)S(3)(u, v, w), S(3)R(3)S(3)(u, v, w),\nS(3)S(3)R(3)(u, v, w), or R(3)R(3)R(3)(u, v, w).\nHence, f behaves like an\nR(3)-minority on S, and we are done by Lemma 9.4.12.\n(2) Suppose that S(3)(f(x1), f(x2), f(x3)), S(3)(f(x4), f(x5), f(x6)), and that\nS(3)(f(x7), f(x8), f(x9)). Then f behaves like an R(3)-majority on S, which\nis impossible by Lemma 9.4.11.\n(3) Suppose that R(3)(f(x1), f(x2), f(x3)), R(3)(f(x4), f(x5), f(x6)), and that\nS(3)(f(x7), f(x8), f(x9)). Let e be a self-embedding of (V; E) such that for\nall w ∈V, all 1 ≤j ≤3, and all 1 ≤i ≤9 we have that N(xj\ni, e(w)). Then\n(u1, u2, e(f(u1, u2, u3))) ∈S for all (u1, u2, u3) ∈S. Hence, by the above,\nthe ternary operation deﬁned by f(x, y, e(f(x, y, z))) is of type R(3)-majority\non S; but this is impossible by Lemma 9.4.11.\n(4) Suppose that R(3)(f(x1), f(x2), f(x3)), S(3)(f(x4), f(x5), f(x6)), and that\nR(3)(f(x7), f(x8), f(x9)). Analogous to the previous case.\n(5) Suppose that S(3)(f(x1), f(x2), f(x3)), R(3)(f(x4), f(x5), f(x6)), and that\nR(3)(f(x7), f(x8), f(x9)). Analogous to the previous case.\nLet h(x, y, z) be a ternary injection of type minority generated by f; it remains to\nmake h canonical. By Corollary 9.4.5, f generates a binary canonical injection g(x, y)\nof type p1. Set t(x, y, z) := g(x, g(y, z)). As in the proof of Proposition 9.3.31 the\nfunction h(t(x, y, z), t(y, z, x), t(z, x, y)) is still of type minority and canonical.\n□\nProof of Proposition 9.4.2. Assume that H2 is not primitive positive deﬁn-\nable; by Theorem 5.2.3 there exists a polymorphism f of B that violates H2. Since\nAut(B) contains sw, the relations R(3) and S(3) consist of only one orbit of triples\nin B. Therefore, since they are preserved by all endomorphisms of B, it follows by\n\n9.5. FIRST-ORDER EXPANSIONS OF (V; R(4), S(4))\n187\nTheorem 5.2.3 and Lemma 5.3.5 that these relations are primitive positive deﬁnable\nin B.\nWe can now apply Proposition 9.4.14 and obtain that {f, sw} generates a ternary\ninjection of type minority which is canonical as a function from (V; E) to (V; E).\nCorollary 9.4.5 implies that B is preserved by a binary injection of type p1 which\nis canonical as a function from (V; E) to (V; E), and the statement follows from\nTheorem 9.3.8.\n□\n9.5. First-order Expansions of (V; R(4), S(4))\nWe assume that the endomorphisms of B are exactly the functions generated by\n{−}. In particular, Aut(B) contains −but not sw, and the automorphisms of B\ngenerate its endomorphisms.\nDefinition 9.5.1. Let H′\n1 be the smallest 6-ary relation that is preserved by {−}\nand contains H1.\nProposition 9.5.2. There is a primitive positive interpretation of ({0, 1}; NAE)\nin (V; H′\n1), and CSP(V; H′\n1) is NP-hard.\nProof. Similar to the proof of Proposition 9.3.5.\n□\nThe following is an analog of Proposition 9.3.4 for the situation of this section.\nProposition 9.5.3. Let B be a reduct of (V; E) whose endomorphisms are pre-\ncisely the unary functions generated by {−}. Then either H′\n1 is primitive positive\ndeﬁnable in B, or one of the cases (b)-(e) of Proposition 9.3.4 applies.\nProof. Note that H′\n1 consists of three orbits of 6-tuples in Aut(B), and hence,\nif H′\n1 is not primitive positive deﬁnable in B, then there exists by Theorem 5.2.3\nand Lemma 5.3.5 a ternary polymorphism f of B that violates H′\n1. That is, there\nare t1, t2, t3 ∈H′\n1 such that f(t1, t2, t3) /∈H′\n1. Note that for each tj, either tj or\n−tj ∈H1.\nIn the ﬁrst case we set gj to be the identity function on V, in the\nsecond case we let gj be the operation −. Now consider the function f ′ deﬁned by\nf ′(x1, x2, x3) := f(g1(x1), g2(x2), g3(x3)).\nWe have that sj := g−1\nj (tj) ∈H1, but\nf ′(s1, s2, s3) = f(t1, t2, t3) is not in H′\n1. Consider the function h(x) := f ′(x, x, x);\nsince the endomorphisms of B are generated by {−}, h either preserves E and N,\nor it ﬂips them. By replacing f ′ by −(f ′) in the latter case we may assume that\nh preserves E and N. Note that we still have that f ′(s1, s2, s3) is not in H′\n1, and\ntherefore not in H1 either. Hence, f ′ violates H1.\nNow suppose that f ′ violates E or N; we will derive a contradiction. Say without\nloss of generality that there are u, v ∈V3 with EEE(u, v) such that E(f ′(u), f ′(v))\ndoes not hold. Pick distinct a, b, c, d ∈V such that {a, b, c, d} induces a clique in\n(V; E), and such that each element is connected to all entries on u, v by an edge. Pick\nthen α1, α2, α3 ∈Aut(V; E) such that αi(a) = ui and αi(b) = vi for all i ∈{1, 2, 3},\nand such that α1(c) = α2(c) = α3(c) = c and α1(d) = α2(d) = α3(d) = d. We then\nhave that the function x 7→f ′(α1(x), α2(x), α3(x)) maps (c, d) to an edge since h(x)\npreserves E, but it does not map (a, b) to an edge, by our assumption on u and v.\nThis is, however, impossible, since the function must be generated by {−}.\nTherefore, f ′ preserves E and N. Then Proposition 9.3.4 implies that f ′ generates\nfunctions with the desired properties, or a binary canonical injection of type max or\nmin. A binary canonical injection of type max together with {−} generates a binary\ncanonical injection of type min, and vice versa. Then\nmax(min(x, y), min(y, z), min(x, z))\n\n188\n9. SCHAEFER’S THEOREM FOR GRAPHS\nis a ternary canonical injection of type majority with the desired properties, and\nwe are also done in this case, since identifying two of its variables yields a binary\ncanonical injection of type projection.\n□\n9.6. First-order Expansions of (V; R(5), S(5))\nWe assume that the endomorphisms of B are precisely the unary functions gen-\nerated by {−, sw}. In particular, Aut(B) contains −, sw, and the automorphisms of\nB generate its endomorphisms.\nDefinition 9.6.1. Let H′\n2 be the smallest 9-ary relation that is preserved by −\nand contains H2.\nProposition 9.6.2. There is a primitive positive interpretation of ({0, 1}; NAE)\nin (V; H′\n2), and CSP(V; H′\n2) is NP-hard.\nProof. Similar to Proposition 9.4.3.\n□\nThe following is an analog of Proposition 9.3.4 for the situation of this section.\nProposition 9.6.3. Let B be a reduct of (V; E) whose endomorphisms are pre-\ncisely the unary functions generated by {−, sw}. Then H′\n2 is primitive positive deﬁn-\nable in B, or (b) or (d) from Proposition 9.3.4 applies.\nProof. Note that H′\n2 consists of three orbits of 9-tuples in Aut(B), and hence,\nif H′\n2 is not primitive positive deﬁnable in B, then there exists by Theorem 5.2.3\nand Lemma 5.3.5 a ternary polymorphism f of B that violates H′\n2. That is, there\nare t1, t2, t3 ∈H′\n2 such that f(t1, t2, t3) /∈H′\n2. Note that for each tj, either tj or\n−tj ∈H2.\nIn the ﬁrst case we set gj to be the identity function on V, in the\nsecond case we let gj be the operation −. Now consider the function f ′ deﬁned by\nf ′(x1, x2, x3) := f(g1(x1), g2(x2), g3(x3)).\nWe have that sj := g−1\nj (tj) ∈H2, but\nf ′(s1, s2, s3) = f(t1, t2, t3) is not in H′\n2, and therefore not in H2 either. Hence, f ′\nviolates H2.\nThe function h(x) := f ′(x, x, x) is generated by {−, sw}, and hence\nh either preserves R(3) and S(3), or it ﬂips them. Since f ′(s1, s2, s3) is not in H′\n2,\nneither is −f ′(s1, s2, s3), and in particular not in H2, so also −f ′ violates H2. Hence,\nby replacing f ′ with −f ′ if necessary, we may assume that h preserves R(3) and S(3).\nWe claim that f ′ preserves R(3) and S(3). Suppose for contradiction that there are\nu, v, w ∈V3 with R(3)(ui, vi, wi) for all i ∈{1, 2, 3} such that R(3)(f ′(u), f ′(v), f ′(w))\ndoes not hold; the case where f ′ violates S(3) can be treated similarly. If (u1, v1, w1),\n(u2, v2, w2), and (u3, v3, w3) all lie in the same orbit of triples in (V; E), then we\nchoose a, b, c ∈V with R(3)(a, b, c) such that N(x, y) for x ∈{a, b, c} and y ∈\n{u1, v1, w1, u2, v2, w2, u3, v3, w3}.\nThen by the homogeneity of (V; E) there is for\neach i ∈{2, 3} a unary operation αi ∈Aut(V; E) such that αi(u1, v1, w1, a, b, c) =\n(ui, vi, wi, a, b, c). We then have that the unary function g(x) := f ′(x, α2(x), α3(x))\nmaps (u1, v1, w1) ∈R(3) to (f ′(u), f ′(v), f ′(w)) /∈R(3). But g and the function h\nabove agree on {a, b, c}, and hence g preserves R(3) on {a, b, c}, but violates it on\n{u1, v1, w1}. This contradicts the assumption that g is generated by {−, sw}.\nSo suppose in the following that R(3)(f ′(u), f ′(v), f ′(w)) for all u, v, w ∈V3\nwith R(3)(ui, vi, wi) for all i ∈{1, 2, 3} such that u, v, w belong to the same orbit\nof triples in (V; E).\nWe now show that R(3)(f ′(u), f ′(v), f ′(w)) for all u, v, w ∈\nV3 with R(3)(ui, vi, wi) for all i ∈{1, 2, 3}.\nTo this end, note that for each i ∈\n{2, 3} there is a subset Si of {ui, vi, wi} such that (sw Si(ui), sw Si(vi), sw Si(wi)) and\n(u1, v1, w1) belong to the same orbit in (V; E).\nHence, there is βi ∈Aut(V; E)\nsuch that βi(sw Si(u1)) = ui, βi(sw Si(v1)) = vi, and βi(sw Si(w1)) = wi.\nPick\na, b, c ∈V \\ S\ni∈{1,2,3}{ui, vi, wi}. Note that for both i ∈{2, 3} we have that the\n\n9.7. ALGORITHMS FOR GRAPH-SAT PROBLEMS\n189\ntriples (a, b, c) and (sw Si(a), sw Si(b), sw Si(c)) lie in the same orbit. We then have\nthat the function x 7→f ′(x, β2(sw S2(x)), β3(sw S3(x))) maps (u1, v1, w1) ∈R(3) to\n(f ′(u), f ′(v), f ′(w)) /∈R(3). But the same unary function also maps (a, b, c) ∈R(3)\nto a tuple in R(3) since f ′ by assumption preserves R(3) on tuples R(3) that lie\nin the same orbit, and indeed we have that for i ∈{2, 3} the triples (a, b, c) and\n(βi(sw Si(a)), βi(sw Si(b)), βi(sw Si(c))) lie in the same orbit. This again contradicts\nthe assumption that the unary function is generated by {−, sw}.\nWe therefore have that f ′ preserves R(3) and S(3). Since it violates H2, Propo-\nsition 9.4.3 implies that {f ′, sw} generates a ternary canonical injection of type mi-\nnority, and we are done.\n□\n9.7. Algorithms for Graph-SAT problems\nThroughout this section we assume that B is a structure with ﬁnite relational\nsignature τ and a ﬁrst-order deﬁnition in (V; E).\n9.7.1. The unbalanced case. We now prove tractability of the CSP for tem-\nplates B as in cases (b) and (c) of Proposition 9.3.4, that is, for structures with a\nﬁrst-order deﬁnition in (V; E) that have\n• a ternary polymorphism of type majority or minority, and\n• a binary polymorphism of type p1 which is either E-dominated or N-dominated\nin the second argument.\nBy duality, we may assume that the polymorphism of type p1 is E-dominated in the\nsecond argument.\nIt turns out that for such templates B we can reduce CSP(B) to the CSP of a\nstructure that we call the injectivization of B. This implies in turn that the CSP can\nbe reduced to a CSP over a Boolean domain.\nDefinition 9.7.1. A tuple is called injective if all its entries have pairwise dis-\ntinct entries. A relation is called injective if all its tuples are injective. A structure\nis called injective if all its relations are injective.\nDefinition 9.7.2. We deﬁne injectivizations for relations, atomic formulas, and\nstructures.\n• Let R be any relation. Then the injectivization of R, denoted by inj(R), is\nthe (injective) relation consisting of all injective tuples of R.\n• Let φ(x1, . . . , xn) be an atomic formula in the language of B, where x1, . . . , xn\nis a list of the variables that appear in φ.\nThen the injectivization of\nφ(x1, . . . , xn) is the formula Rinj\nφ (x1, . . . , xn), where Rinj\nφ is a relation symbol\nwhich stands for the injectivization of the relation deﬁned by φ.\n• The injectivization of a relational structure B, denoted by inj(B), is the\nrelational structure C with the same domain as B whose relations are the\ninjectivizations of the atomic formulas over B, i.e., the relations Rinj\nφ .\nNote that inj(B) also contains the injectivizations of relations that are deﬁned\nby atomic formulas in which one variable might appear several times. In particular,\nthe injectivization of an atomic formula φ might have smaller arity than the relation\nsymbol that appears in φ.\nTo state the reduction to the CSP of an injectivization, we also need the following\noperations on instances of CSP(B). Here, it will be convenient to view instances of\nCSP(B) as primitive positive τ-sentences (see Section 1.2).\n\n190\n9. SCHAEFER’S THEOREM FOR GRAPHS\n// Input: An instance φ of CSP(B) with variables W\nWhile φ contains a constraint that implies x = y for x, y ∈W do\nReplace each occurrence of x by y in φ.\nIf φ contains a false constraint then reject\nLoop\nAccept if and only if inj(φ) is satisﬁable in inj(B).\nFigure 9.1. Algorithm for CSP(B) when B is preserved by an un-\nbalanced binary injection, using an algorithm for inj(B).\nDefinition 9.7.3. Let φ be an instance of CSP(B). Then the injectivization of\nφ, denoted by inj(φ), is the instance ψ of CSP(inj(B)) obtained from φ by replacing\neach conjunct φ(x1, . . . , xn) of φ by Rinj\nφ (x1, . . . , xn).\nWe say that a constraint in an instance of CSP(B) is false if it deﬁnes an empty\nrelation in B. Note that a constraint R(x1, . . . , xk) might be false even if the relation\nR is non-empty (simply because some of the variables from x1, . . . , xk might be equal).\nProposition 9.7.4. Let B be preserved by a binary injection f of type p1 that is\nE-dominated in the second argument. Then the algorithm shown in Figure 9.1 is a\npolynomial-time reduction of CSP(B) to CSP(inj(B)).\nProof. In the main loop, when the algorithm detects a constraint that is false\nand therefore rejects, then φ cannot hold in B, because the algorithm only contracts\nvariables x and y when x = y in all solutions to φ – and contractions are the only\nmodiﬁcations performed on the input formula φ. So suppose that the algorithm does\nnot reject, and let ψ be the instance of CSP(B) computed by the algorithm when it\nreaches the ﬁnal line of the algorithm.\nBy the observation we just made it suﬃces to show that ψ holds in B if and only\nif inj(ψ) holds in inj(B). It is clear that when inj(ψ) holds in inj(B) then ψ holds in\nB (since the constraints in inj(ψ) have been made stronger). We now prove that if ψ\nhas a solution s in B, then there is also a solution for inj(ψ) in inj(B).\nLet s′ be any mapping from the variable set W of ψ to V such that for all distinct\nx, y ∈W we have that\n• if E(s(x), s(y)) then E(s′(x), s′(y));\n• if N(s(x), s(y)) then N(s′(x), s′(y));\n• if s(x) = s(y) then E(s′(x), s′(y)).\nBy universality of (V; E), such a mapping exists. We claim that s′ is a solution to ψ\nin B. Since s′ is injective, it is then clearly also a solution to inj(ψ). To prove the\nclaim, let γ be a constraint of ψ on the variables x1, . . . , xk ∈W. Since we are at\nthe ﬁnal stage of the algorithm, we can conclude that γ(x1, . . . , xk) does not imply\nequality of any of the variables x1, . . . , xk, and so there is for all 1 ≤i < j ≤k a tuple\nt(i,j) such that R(t(i,j)) and ti ̸= tj hold. Since γ(x1, . . . , xk) is preserved by a binary\ninjection, it is also preserved by injections of arbitrary arity (it is straightforward to\nbuild such terms from a binary injection). Application of an injection of arity\n\u0000k\n2\n\u0001\nto\nthe tuples t(i,j) shows that γ(x1, . . . , xk) is satisﬁed by an injective tuple (t1, . . . , tk).\nConsider the mapping r: {x1, . . . , xk} →V given by r(xl) := f(s(xl), tl). This\nassignment has the property that for all i, j ∈S if E(s(xi), s(xj)), then E(r(x), r(y)),\nand if N(s(xi), s(xj)) then N(r(xi), r(xj)), because f is of type p1.\nMoreover, if\ns(xi) = s(xj) then E(r(xi), r(xj)) because f is E-dominated in the second argument.\nTherefore, (s′(x1), . . . , s′(xn)) and (r(x1), . . . , r(xn)) have the same type in (V; E).\nSince f is a polymorphism of B, we have that (r(x1), . . . , r(xn)) satisﬁes the constraint\n\n9.7. ALGORITHMS FOR GRAPH-SAT PROBLEMS\n191\nγ(x1, . . . , xn). Hence, s′ satisﬁes γ(x1, . . . , xn) as well. We conclude that s′ satisﬁes\nall the constraints of ψ, proving our claim.\n□\nTo reduce the CSP for injective structures to Boolean CSPs, we make the following\ndeﬁnition.\nDefinition 9.7.5. Let t be a k-tuple of distinct vertices of (V; E), and let q be\n\u0000k\n2\n\u0001\n. Then Boole(t) is the q-tuple (a1,2, a1,3, . . . , a1,k, a2,3, . . . , ak−1,k) ∈{0, 1}q such\nthat ai,j = 0 if N(ti, tj) and ai,j = 1 if E(ti, tj). If R is a k-ary injective relation,\nthen Boole(R) is the q-ary Boolean relation {Boole(t) | t ∈R}. If φ is a formula\nthat deﬁnes an injective relation R over (V; E), then we also write Boole(φ) instead\nof Boole(inj(R)). Finally, for injective B, we write Boole(B) for the structure over\na Boolean domain with the relation Boole(R) for each relation R of B.\nProposition 9.7.6. Let B be injective. Then there is a polynomial-time reduction\nfrom CSP(B) to CSP(Boole(B)).\nProof. Let φ be an instance of CSP(B) with variable set W. We create an\ninstance ψ of CSP(Boole(B)) as follows. The variable set of ψ is the set of unordered\npairs of variables from φ. When γ = R(x1, . . . , xk) is a constraint in φ, then ψ contains\nthe constraint Boole(R)(x1,2, x1,3, . . . , x1,k, x2,3, . . . , xk−1,k). It is straightforward to\nverify that ψ can be computed from φ in polynomial time, and that φ is a satisﬁable\ninstance of CSP(B) if and only if ψ is a satisﬁable instance of CSP(Boole(B)).\n□\nThe following proposition, together with Propositions 9.7.4 and 9.7.6, solves the\ncase where Pol(B) contains a ternary injection of type minority or majority as well as\none of the functions of Theorem 9.3.8 which are unbalanced and of type projection.\nIt thus shows tractability of cases (b) and (c) of Proposition 9.3.4 given that none of\nthe other cases applies.\nProposition 9.7.7. Let B be injective, and suppose it has an polymorphism of\ntype minority (majority). Then Boole(B) has a minority (majority) polymorphism,\nand CSP(Boole(B)) can be solved in polynomial time.\nProof. It is straightforward to show that Boole(B) has a minority (majority)\npolymorphism.\nWe have seen in Theorem 5.4.3 that CSP(Boole(B)) can then be\nsolved in polynomial time.\n□\n9.7.2. Tractability for type minority. We show tractability of CSP(B) when\nB has a polymorphism of type minority as well as a binary canonical injection of type\np1 which is balanced. We start by proving that in this case the relations of B can\nbe deﬁned in (V; E) by ﬁrst-order formulas of a certain restricted syntactic form; this\nnormal form will later be essential for our algorithm.\nRecall that a Boolean relation R is aﬃne if it can be deﬁned by a conjunction\nof linear equations modulo 2, which is the case if and only if R is preserved by the\nBoolean minority operation (see Theorem 5.4.3).\nIn the following, we denote the\nBoolean exclusive-or connective (xor) by ⊕.\nDefinition 9.7.8. A graph formula is called edge aﬃne if it is a conjunction of\nformulas of the form\nx1 ̸= y1 ∨. . . ∨xk ̸= yk\n∨\n\u0000u1 ̸= v1 ∧· · · ∧ul ̸= vl\n∧E(u1, v1) ⊕· · · ⊕E(ul, vl) = p\n\u0001\n∨(u1 = v1 ∧· · · ∧ul = vl) ,\nwhere p ∈{0, 1}, variables need not be distinct, and each of k and l can be 0.\n\n192\n9. SCHAEFER’S THEOREM FOR GRAPHS\nDefinition 9.7.9. A ternary operation f : V3 →V is called balanced if for every\nc ∈V, the binary operations (x, y) 7→f(x, y, c), (x, z) 7→f(x, c, z), and (y, z) 7→\nf(c, y, z) are balanced injections of type p1.\nObserve that the existence of balanced operations and even balanced minority\noperations follows from the fact that (V; E) contains all countable graphs as induced\nsubgraphs.\nProposition 9.7.10. Let R be a relation with a ﬁrst-order deﬁnition in (V; E).\nThen the following are equivalent:\n(1) R can be deﬁned by an edge aﬃne formula;\n(2) R is preserved by every injection of type minority which is balanced;\n(3) R is preserved by an injection of type minority, and a balanced binary injec-\ntion of type p1.\nProof. We ﬁrst show the implication from 1 to 2, that every n-ary relation R\ndeﬁned by an edge aﬃne formula ψ(x1, . . . , xn) is preserved by balanced functions f\nof type minority. We verify that each clause φ from ψ is preserved by f. By injectivity\nof f, it is easy to see that we only have to show this for the case that φ does not\ncontain disequality disjuncts (i.e., for the case k = 0). In this case φ is of the following\nform, for p ∈{0, 1} and u1, . . . , ul, v1, . . . , vl ∈{x1, . . . , xn}.\nφ =\n\u0000u1 ̸= v1 ∧· · · ∧ul ̸= vl\n∧(E(u1, v1) ⊕· · · ⊕E(ul, vl) = p)\n\u0001\n∨(u1 = v1 ∧· · · ∧ul = vl)\nIn the following, it will sometimes be notationally convenient to consider tuples in\n(V; E) satisfying a formula as mappings from the variable set of the formula to V. Let\nt1, t2, t3 : {x1, . . . , xn} →V be three mappings that satisfy φ. We have to show that\nthe mapping t0 : {x1, . . . , xn} →V deﬁned by t0(x) = f(t1(x), t2(x), t3(x)) satisﬁes φ.\nSuppose ﬁrst that each of t1, t2, t3 satisﬁes u1 ̸= v1 ∧· · · ∧ul ̸= vl. In this case,\nt0(u1) ̸= t0(v1)∧· · ·∧t0(ul) ̸= t0(vl), since f preserves ̸=. Note that E(t0(ui), t0(vi)),\nfor 1 ≤i ≤l, if and only if E(t1(ui), t1(vi)) ⊕E(t2(ui), t2(vi)) ⊕E(t3(ui), t3(vi)) = 1.\nTherefore, since each t1, t2, t3 satisﬁes E(u1, v1) ⊕· · · ⊕E(ul, vl) = p, we ﬁnd that t0\nalso satisﬁes E(u1, v1) ⊕· · · ⊕E(ul, vl) = p ⊕p ⊕p = p.\nNext, suppose that one of t1, t2, t3 satisﬁes ui = vi for some (and therefore for all)\n1 ≤i ≤l. By permuting arguments of f, we can assume that t1(ui) = t1(vi) for all i ∈\n{1, . . . , l}. Since the function f is balanced, the operation g: (y, z) 7→f(t1(ui), y, z) is\na balanced injection of type p1. Suppose that t2(ui) = t2(vi). Then E(t0(ui), t0(vi))\nif and only if E(t3(ui), t3(vi)), since g is balanced. Hence, t0 satisﬁes φ. Now suppose\nthat t2(ui) ̸= t2(vi). Then E(t0(ui), t0(vi)) if and only if E(t2(ui), t2(vi)), since g is\nof type p1. Again, t0 satisﬁes φ. This shows that f preserves φ.\nThe implication from 2 to 3 is trivial, since every balanced function of type\nminority generates a balanced binary injection of type p1 by identiﬁcation of two of\nits variables. It is also here that we have to check the existence of balanced injections\nof type minority; as mentioned above, this follows easily from the universality of\n(V; E).\nWe show the implication from 3 to 1 by induction on the arity n of the relation R.\nLet g be the balanced binary injection of type p1, and let h be the operation of type\nminority. For n = 2 the statement of the theorem holds, because all binary relations\nwith a ﬁrst-order deﬁnition in (V; E) can be deﬁned over (V; E) by expressions as in\nDeﬁnition 9.7.8:\n\n9.7. ALGORITHMS FOR GRAPH-SAT PROBLEMS\n193\n• For x ̸= y we set k = 1 and l = 0.\n• For ¬E(x, y) we can set k = 0, l = 1, p = 0.\n• For ¬N(x, y) we can set k = 0, l = 1, p = 1.\n• Then, E(x, y) can be expressed as (x ̸= y) ∧¬N(x, y).\n• N(x, y) can be expressed as (x ̸= y) ∧¬E(x, y).\n• x = y can be expressed as ¬E(x, y) ∧¬N(x, y).\n• The empty relation can be expressed as E(x, y) ∧N(x, y).\n• Finally, V2 can be deﬁned by the empty conjunction.\nFor n > 2, we construct a formula φ that deﬁnes the relation R(x1, . . . , xn) as\nfollows.\nIf there are distinct i, j ∈{1, . . . , n} such that for all tuples t in R we\nhave ti = tj, consider the relation deﬁned by ∃xi.R(x1, . . . , xn). This relation is also\npreserved by g and h, and by inductive assumption has a deﬁnition ψ as required.\nThen the formula φ := (xi = xj) ∧ψ proves the claim. So let us assume that for all\ndistinct i, j there is a tuple t ∈R where ti ̸= tj. Note that since R is preserved by\nthe binary injective operation g, this implies that R also contains an injective tuple.\nSince R is preserved by an operation of type minority, the relation Boole(inj(R))\nis preserved by the Boolean minority operation, and hence has a deﬁnition by a\nconjunction of linear equations modulo 2 (Theorem 5.4.3). From this deﬁnition it is\nstraightforward to obtain a deﬁnition ψ(x1, . . . , xn) of inj(R) which is the conjunction\nof V\ni<j≤n xi ̸= xj and of formulas of the form\nE(u1, v1) ⊕· · · ⊕E(ul, vl) = p ,\nfor u1, . . . , ul, v1, . . . , vl ∈{x1, . . . , xn}. It is clear that we can assume that none of the\nformulas of the form E(u1, v1) ⊕· · · ⊕E(ul, vl) = p in ψ can be equivalently replaced\nby a conjunction of shorter formulas of this form.\nFor all i, j ∈{1, . . . , n} with i < j, let Ri,j be the relation that holds for the tuple\n(x1, . . . , xi−1, xi+1, . . . , xn) iﬀR(x1, . . . , xi−1, xj, xi+1, . . . , xn) holds. Because Ri,j is\npreserved by g and h, but has arity n −1, it has a deﬁnition ψi,j as in the statement\nby inductive assumption. We call the conjuncts of ψi,j also the clauses of ψi,j.\nLet φ be the conjunction composed of conjuncts from the following two groups:\n(1) γ ∨(xi ̸= xj) for all i < j ≤n and each clause γ of ψi,j;\n(2) when η = (E(u1, v1)⊕· · ·⊕E(ul, vl) = p) is a conjunct of ψ, then φ contains\nthe formula\n(u1 ̸= v1 ∧· · · ∧ul ̸= vl ∧η)\n∨(u1 = v1 ∧· · · ∧ul = vl) .\nObviously, φ is a formula of the required form. We have to verify that φ deﬁnes R.\nLet t be an n-tuple such that t /∈R. If t is injective, then t violates a formula of\nthe form\nE(u1, v1) ⊕· · · ⊕E(ul, vl) = p\nfrom the formula ψ deﬁning inj(R), and hence it violates a conjunct of φ of the second\ngroup. If there are i, j such that ti = tj then the tuple ti := (t1, . . . , ti−1, ti+1, . . . , tn) /∈\nRi,j. Therefore some conjunct γ of ψi,j is not satisﬁed by ti, and γ ∨(xi ̸= xj) is not\nsatisﬁed by t. Thus, in this case t does not satisfy φ either.\nIt remains to verify that all t ∈R satisfy φ. Let γ ∨(xi ̸= xj) be a conjunct of φ\ncreated from some clause in ψi,j. If ti ̸= tj, then t satisﬁes xi ̸= xj. If ti = tj, then\n(t1, . . . , ti−1, ti+1, . . . , tn) ∈Ri,j and thus this tuple satisﬁes ψi,j. This also implies\nthat t satisﬁes φ. Now, let η be a conjunct of φ from the second group. We distinguish\nthree cases.\n(1) For all 1 ≤i ≤l we have that t satisﬁes ui = vi. In this case we are clearly\ndone since t satisﬁes the second disjunct of η.\n\n194\n9. SCHAEFER’S THEOREM FOR GRAPHS\n(2) For all 1 ≤i ≤l we have that t satisﬁes ui ̸= vi. Suppose for contradiction\nthat t does not satisfy E(u1, v1)⊕· · ·⊕E(ul, vl) = p. Let r ∈R be injective,\nand consider the tuple s := g(t, r). Then s ∈R, and s is injective since the\ntuple r and the function g are injective. However, since g is of type p1, we\nhave E(s(ui), s(vi)) if and only if E(t(ui), t(vi)), for all 1 ≤i ≤l. Hence, s\nviolates the conjunct E(u1, v1) ⊕· · · ⊕E(ul, vl) = p from ψ, a contradiction\nsince s ∈inj(R).\n(3) The remaining case is that there is a proper non-empty subset S of {1, . . . , l}\nsuch that t satisﬁes ui = vi for all i ∈S and t satisﬁes ui ̸= vi for all\ni ∈{1, . . . , n} \\ S. We claim that this case cannot occur. Suppose that all\ntuples t′ from inj(R) satisfy that L\ni∈S E(ui, vi) = 1. In this case we could\nhave replaced E(u1, v1) ⊕· · · ⊕E(ul, vl) = p by the two shorter formulas\nL\ni∈S E(ui, vi) = 1 and L\ni∈[n]\\S E(ui, vi) = p ⊕1, in contradiction to our\nassumption on ψ. Hence, there is a tuple s ∈inj(R) where L\ni∈S E(ui, vi) =\n1. Now, for the tuple g(t, s) we have\nM\ni∈[n]\nE(ui, vi) =\nM\ni∈S\nE(ui, vi) ⊕\nM\ni∈[n]\\S\nE(ui, vi)\n= 1 ⊕p\n̸= p\nwhich is a contradiction since g(t, s) ∈inj(R).\nHence, all t ∈R satisfy all conjuncts of φ. We conclude that φ deﬁnes R.\n□\nWe now present a polynomial-time algorithm for CSP(B) for the case that B has\nﬁnitely many relations that are all edge aﬃne.\nDefinition 9.7.11. Suppose all relations of B are edge aﬃne, and let φ be an\ninstance of CSP(B). Then the graph of φ is the (undirected) graph whose vertices are\nunordered pairs of distinct variables of φ, and which has an edge between distinct sets\n{a, b} and {c, d} if φ contains a constraint whose deﬁnition as in Deﬁnition 9.7.8 has\na conjunct of the form\n\u0000u1 ̸= v1 ∧· · · ∧ul ̸= vl ∧(E(u1, v1) ⊕· · · ⊕E(ul, vl) = p)\n\u0001\n∨(u1 = v1 ∧· · · ∧ul = vl)\nsuch that {a, b} = {ui, vi} and {c, d} = {uj, vj} for some i, j ∈{1, . . . , l}.\nIt is clear that for B with ﬁnite signature, the graph of an instance φ of CSP(B)\ncan be computed in linear time from φ.\nDefinition 9.7.12. Let B only have edge aﬃne relations, and let φ be an instance\nof CSP(B). For a set C of 2-element subsets of variables of φ, we deﬁne inj(Φ, C) to\nbe the following aﬃne Boolean formula. The set of variables of inj(φ, C) is C. The\nconstraints of inj(φ, C) are obtained from the constraints γ of φ as follows. If γ has\na deﬁnition as in Deﬁnition 9.7.8 with a clause of the form\n\u0000u1 ̸= v1 ∧· · · ∧ul ̸= vl ∧(E(u1, v1) ⊕· · · ⊕E(ul, vl) = p)\n\u0001\n∨(u1 = v1 ∧· · · ∧ul = vl)\nwhere all pairs {ui, vi} are in C, then inj(φ, C) contains the conjunct {u1, v1} ⊕· · · ⊕\n{ul, vl} = p.\nTractability of case (d) of Proposition 9.3.4 now follows from the following propo-\nsition and Proposition 9.7.10.\n\n9.7. ALGORITHMS FOR GRAPH-SAT PROBLEMS\n195\n// Input: An instance φ of CSP(B)\nRepeat\nFor each connected component C of the graph of φ do\nLet ψ be the aﬃne Boolean formula inj(φ, C).\nIf ψ is unsatisﬁable then\nFor each {x, y} ∈C do\nReplace each occurrence of x by y in φ.\nIf φ contains a false constraint then reject\nLoop\nUntil inj(φ, C) is satisﬁable for all components C\nAccept\nFigure 9.2. A polynomial-time algorithm for CSP(B) when B is\npreserved by a balanced operation of type minority.\nProposition 9.7.13. Let B be a structure with a ﬁrst-order deﬁnition in (V; E)\nand a ﬁnite signature, and suppose that B is preserved by a balanced injection of type\nminority. Then the algorithm shown in Figure 9.2 solves CSP(B) in polynomial time.\nProof. We ﬁrst show that when the algorithm detects a constraint that is false\nand therefore rejects in the innermost loop, then φ must be unsatisﬁable.\nSince\nvariable contractions are the only modiﬁcations performed on the input formula φ, it\nsuﬃces to show that the algorithm only equates variables x and y when x = y in all\nsolutions to φ. To see that this is true, assume that ψ := inj(φ, C) is an unsatisﬁable\nBoolean formula for some connected component C. Hence, in any solution s to φ\nthere must be a pair {x, y} in C such that s(x) = s(y). It follows immediately from\nthe deﬁnition of the graph of φ that then s(u) = s(v) for all {u, v} adjacent to {x, y}\nin the graph of φ. By connectivity of C, we have that s(u) = s(v) for all {u, v} ∈C.\nSince this holds for any solution to φ, the contractions in the innermost loop of the\nalgorithm preserve satisﬁability.\nSo we only have to show that when the algorithm accepts, there is indeed a\nsolution to φ. When the algorithm accepts, we must have that inj(φ, C) has a solution\nsC for all components C of the graph of φ. Let s be a mapping from the variables\nof φ to the V such that E(xi, xj) if {xi, xj} is in component C of the graph of φ and\nsC({xi, xj}) = 1, and N(xi, xj) otherwise. It is straightforward to verify that this\nassignment satisﬁes all of the constraints.\n□\n9.7.3. Tractability for type majority. We turn to case (e) of Proposition 9.3.4,\ni.e., the case where B has ternary injection of type majority and a binary canonical\ninjection of type p1 which is balanced.\nRecall that a Boolean relation is called bijunctive if it can be deﬁned by a con-\njunction of clauses of size at most two.\nIt is well-known that a Boolean relation\nis bijunctive if and only if it is preserved by the Boolean majority operation (see\nSection 5.4).\nDefinition 9.7.14. A formula is called graph bijunctive iﬀit is a conjunction\nof graph bijunctive clauses, i.e., formulas of the form\nx1 ̸= y1 ∨· · · ∨xk ̸= yk ∨φ\nwhere φ is of one of the following forms\n(i) u1 = v1;\n(ii) L1(u1, v1);\n(iii) L1(u1, v1) ∨L2(u2, v2);\n\n196\n9. SCHAEFER’S THEOREM FOR GRAPHS\n(iv) L1(u1, v1) ∨u1 = v1;\n(v) (L1(u1, v1) ∨u1 = v1 ∨L2(u2, v2)) ∧(u1 ̸= v1 ∨L2(u2, v2) ∨u2 = v2);\nfor L1, L2 ∈{E, N}, and k ≥0.\nNote that when M1, M2 are such that {Li, Mi} = {E, N} for i ∈{1, 2}, then the\ngraph bijunctive clause in Item (v) can be equivalently written in the form\n(M1(u1, v1) ⇒L2(u2, v2)) ∧(u1 = v1 ⇒¬M2(u2, v2)) .\nTheorem 9.7.15. Let R be a relation with a ﬁrst-order deﬁnition over (V; E).\nThen the following are equivalent.\n(1) R can be deﬁned by a graph bijunctive formula;\n(2) R is preserved by every ternary injection which is of type majority and bal-\nanced;\n(3) R is preserved by some ternary injection of type majority and some binary\nbalanced injection of type p1.\nProof. We show the equivalence of (1) and (2); the equivalence between (2) and\n(3) is easy and is to be added later.\nFor the implication (1) ⇒(2), let ψ be a graph bijunctive clause. It suﬃces to\nshow that ψ is preserved by every balanced injection f of type majority. Let t1, t2, t3\nbe three tuples that satisfy ψ. If ψ contains an inequality disjunct xi ̸= yi, and one of\nt1, t2, t3 satisﬁes xi ̸= yi, then by injectivity of f we have that t0 = f(t1, t2, t3) satisﬁes\nxi ̸= yi and therefore also ψ. So we can focus on the case k = 0, i.e., ψ does not\ncontain any inequality disjunct. If ψ is of the form u1 = v1, ψ is clearly preserved. If\nψ is of the form L1(u1, v1) or of the form ¬L1(u1, v1), then f preserves ψ since it is of\ntype majority and balanced. Suppose now that ψ is of the form L1(u1, v1)∨L2(u2, v2)\nfor L1, L2 ∈{E, N}. Then at least two of t1, t2, t3 satisfy L1(u1, v1), or at least two\nof t1, t2, t3 satisfy L2(u2, v2). In the former case, t0 satisﬁes L1(u1, v1), in the latter\ncase t0 satisﬁes L2(u2, v2), since f is of type majority and balanced.\nFinally, suppose that ψ is as in item (v) of the deﬁnition of graph bijunctive\nformulas. If t0 = f(t1, t2, t3) satisﬁes ¬M1(u1, v1) ∧u1 ̸= v1, then t0 satisﬁes both\nconjuncts of ψ and we are done. We thus may assume that t0 satisﬁes either u1 = v1\nor M1(u1, v1). If t0 satisﬁes u1 = v1, then t0 satisﬁes the ﬁrst conjunct of ψ. By\ninjectivity of f we must have that all of t1, t2, t3 satisfy u1 = v1, and therefore all\nthree tuples satisfy L2(u2, v2) ∨u2 = v2. Since f is of type majority and balanced,\nalso t0 satisﬁes L2(u2, v2) ∨u2 = v2, which is the second conjunct of ψ, and we are\ndone also in this case.\nSuppose now that t0 satisﬁes M1(u1, v1). Since f is of type majority and balanced,\neither\n(a) at least two out of t1, t2, t3 satisfy M1(u1, v1), or\n(b) t1 satisﬁes M1(u1, v1) and exactly one out of t2, t3 satisfy u1 = v1, or\n(c) t1 satisﬁes u1 = v1 and t2 satisﬁes M1(u1, v1).\nIf at least two tuples out of t1, t2, t3 satisfy M1(u1, v1), then they also satisfy L2(u2, v2),\nand so does t0 since f is of type majority and balanced. We conclude that t0 satisﬁes ψ.\nNow assume (b). Then t1 satisﬁes M1(u1, v1), and therefore also satisﬁes L2(u2, v2).\nMoreover, one of t2, t3 satisﬁes u1 = v1, and therefore also L2(u2, v2)∨u2 = v2. Since\nf is balanced and of type majority we have that t0 satisﬁes L2(u2, v2), and there-\nfore also ψ. Suppose ﬁnally that (c) holds, i.e., t1 satisﬁes u1 = v1 and t2 satisﬁes\nM1(u1, v1). In this case t1 satisﬁes L2(u2, v2) ∨u2 = v2 and t2 satisﬁes L2(u2, v2).\nAgain, since f is balanced and of type majority, we have that t0 satisﬁes L2(u2, v2),\nand therefore also ψ.\n\n9.7. ALGORITHMS FOR GRAPH-SAT PROBLEMS\n197\nWe next show the implication (2) ⇒(1). Let R be a relation preserved by a\nternary injection f which is of type majority and balanced. Let Φ be a formula in\nCNF that deﬁnes R over (V; E, N) such that all literals of Φ are of the form E(x, y),\nN(x, y), x ̸= y, or x = y. This can be achieved by replacing literals of the form\n¬L(x, y) by M(x, y) ∨x = y, for M such that {L, M} = {E, N}. Also suppose that\nΦ is minimal in the sense that no clause φ of Φ can be replaced by a set of clauses\nsuch that\n(1) each replacing clause has fewer literals of the form L(x, y) for L ∈{E, N}\nthan φ, or\n(2) each replacing clause has the same number of literals of the form L(x, y),\nbut fewer literals of the form x = y than φ, or\n(3) each replacing clause has the same number of literals of the form L(x, y) and\nof the form x = y, but fewer literals of the form x ̸= y than φ.\nLet Ψ be the set of all graph bijunctive clauses that are implied by Φ. To prove\n(2) ⇒(1), it suﬃces to show that Ψ implies all clauses φ of Φ. Let φ such a clause. In\nthe entire proof we make the convention that L1, . . . , Ln denote elements of {E, N},\nand M1, . . . , Mn are such that {Li, Mi} = {E, N}, for all i ≤n.\nObservation 1:\nThe clause φ cannot contain two diﬀerent literals of the form\nx1 = y1 and x2 = y2. Otherwise, since Φ is minimal, the formula obtained by re-\nmoving x1 = y1 from φ is inequivalent to Φ, and hence there exists a tuple t1 that\nsatisﬁes Φ, and none of the literals in φ except for x1 = y1. Similarly, there exists\na tuple t2 that satisﬁes Φ, and none of the literals in φ except for x2 = y2. By the\ninjectivity of f, the tuple t0 = f(t1, t2, t2) satisﬁes x1 ̸= y1 and x2 ̸= y2. Moreover,\nt0 does not satisfy any other literal of φ because the fact that it is of type majority\nand balanced implies that f preserves the negations of all literals of the form x = y,\nE(x, y), N(x, y), and x ̸= y. Therefore, t0 satisﬁes none of the literals in φ, contra-\ndicting the assumption that f preserves Φ.\nObservation 2:\nThe clause φ contains at most two literals of the form L(x, y),\nwhere L ∈{E, N}. Suppose to the contrary that φ contains three diﬀerent literals of\nthe form L1(x1, y1), L2(x2, y2), and L3(x3, y3). Let θ be the clause obtained from φ by\nremoving those three literals from φ. Note that it is impossible that Φ has satisfying\nassignments t1, t2, t3 with\nt1 |=M2(x2, y2) ∧M3(x3, y3) ∧¬θ\nt2 |=M1(x1, y1) ∧M3(x3, y3) ∧¬θ\nt3 |=M1(x1, y1) ∧M2(x2, y2) ∧¬θ .\nOtherwise, t0 = f(t1, t2, t3) satisﬁes M1(x1, y1) ∧M2(x2, y2) ∧M3(x3, y3) since f is of\ntype majority and balanced. Moreover, t0 satisﬁes ¬θ, since f preserves the negations\nof literals of the form x = y, E(x, y), N(x, y), and x ̸= y. Therefore, t0 does not satisfy\nφ, in contradiction to the assumption that f preserves Φ.\nSuppose without loss of generality that there is no satisfying assignment t1 as\nabove. In other words, Φ implies the clause\nθ ∨L2(x2, y2) ∨(x2 = y2) ∨L3(x3, y3) ∨(x3 = y3) .\n(10)\nNote that Φ also implies the clauses\nθ ∨L1(x1, y1) ∨L2(x2, y2) ∨(x3 ̸= y3)\n(11)\nθ ∨L1(x1, y1) ∨(x2 ̸= y2) ∨L3(x3, y3)\n(12)\n\n198\n9. SCHAEFER’S THEOREM FOR GRAPHS\nsince they are obvious weakenings of φ. We claim that the clauses in (10), (11), and\n(12) together imply φ. To see this, suppose they hold for a tuple t which does not\nsatisfy φ. Then t satisﬁes neither θ nor any of the Li, and hence it satisﬁes both\n(x2 ̸= y2) and (x3 ̸= y3), by (11) and (12). On the other hand, in this situation (10)\nimplies x2 = y2 ∨x3 = y3, a contradiction. Hence φ is equivalent to the conjunction\nof these three clauses. Now replacing φ by this conjunction in Φ, we arrive at a con-\ntradiction to the minimality of Φ.\nTaking the two observations together, we conclude that φ contains at most one\nliteral of the form x = y, and at most two literals of the form L(x, y).\nIf it has\nno literal of the form x = y or no literal of the form L(x, y) then it is itself graph\nbijunctive and hence an element of Ψ, and we are done. So assume henceforth that\nφ contains a literal x1 = y1 and a literal of the form L2(x2, y2). It may or may not\ncontain at most one more literal L3(x3, y3); all other literals of φ are of the form\nx ̸= y.\nLet us ﬁrst consider the case where φ does not contain the literal L3(x3, y3). Let\nθ be the clause obtained from φ by removing x1 = y1 and L2(x2, y2); all literals in θ\nare of the form x ̸= y. We claim that Φ implies the following formula.\nθ ∨(x1 ̸= y1) ∨L2(x2, y2) ∨(x2 = y2)\n(13)\nTo show the claim, suppose for contradiction that there is a tuple t1 that satisﬁes\nΦ∧¬θ∧(x1 = y1)∧M2(x2, y2). By minimality of Φ, there is also a tuple t2 that satisﬁes\nΦ∧¬θ∧(x1 ̸= y1)∧L2(x2, y2). Then f(t1, t1, t2) satisﬁes Φ∧¬θ∧x1 ̸= y1∧M2(x2, y2)\nsince f is of type majority and balanced; but this is a contradiction since such a tuple\ndoes not satisfy φ. We next show that Φ implies the graph bijunctive formulas\nθ ∨(E(x1, y1) ∨x1 = y1 ∨L2(x2, y2)) ∧(x1 ̸= y1 ∨L2(x2, y2) ∨x2 = y2)\n(14)\nθ ∨(N(x1, y1) ∨x1 = y1 ∨L2(x2, y2)) ∧(x1 ̸= y1 ∨L2(x2, y2) ∨x2 = y2) .\n(15)\nSince Φ implies (13), it suﬃces to show that Φ implies θ ∨E(x1, y1) ∨(x1 = y1) ∨\nL2(x2, y2) and θ ∨N(x1, y1) ∨(x1 = y1) ∨L2(x2, y2). But this is clear since those\nformulas are weakenings of φ.\nHence, the formulas (14) and (15) are in Ψ.\nAs\nE(x1, y1) ∨(x1 = y1) ∨L2(x2, y2) and N(x1, y1) ∨(x1 = y1) ∨L2(x2, y2) implies\n(x1 = y1)∨L2(x2, y2), the formulas (14) and (15) imply φ, and therefore Ψ implies φ.\nFinally, we consider the case where φ also contains a literal L3(x3, y3). Let θ be the\nclause obtained from φ by removing x1 = y1, L2(x2, y2), and L3(x3, y3); all literals of\nθ are of the form x ̸= y. If Φ implies θ∨¬M2(x2, y2), then we could have replaced φ by\nthe two clauses θ∨L2(x2, y2)∨(x2 = y2) and θ∨(x1 = y1)∨(x2 ̸= y2)∨L3(x3, y3) which\ntogether imply φ, in contradiction to the minimality of Φ. The same argument shows\nthat Φ does not imply θ ∨¬M3(x3, y3). Now observe that Φ implies the following.\nθ ∨x1 = y1 ∨x2 ̸= y2 ∨x3 ̸= y3\n(16)\nθ ∨¬M2(x2, y2) ∨¬M3(x3, y3)\n(17)\nθ ∨x2 ̸= y2 ∨L3(x3, y3) ∨x3 = y3\n(18)\nθ ∨x3 ̸= y3 ∨L2(x2, y2) ∨x2 = y2 .\n(19)\nThis is obvious for (16). For (17), assume otherwise that there is an assignment t\nsatisfying Φ ∧¬θ ∧M2(x2, y2) ∧M3(x3, y3).\nBy minimality of Φ there is also an\nassignment t′ satisfying Φ ∧¬θ ∧(x1 ̸= x2).\nThen f(t, t, t′) satisﬁes none of the\nliterals of φ, a contradiction. We now show that (18) is implied; the proof for (19)\nis symmetric. Assume otherwise that t satisﬁes Φ ∧¬θ ∧(x2 = y2) ∧M3(x3, y3).\nThere also exists a tuple t′ that satisﬁes Φ ∧¬θ ∧M2(x2, y2) since Φ does not imply\n\n9.7. ALGORITHMS FOR GRAPH-SAT PROBLEMS\n199\nθ ∨¬M2(x2, y2) as we have observed above. Then f(t, t, t′) satisﬁes ¬θ ∧M2(x2, y2) ∧\nM3(x3, y3), which contradicts (17).\nWe now claim that Φ also implies at least one of the following two formulas.\nθ ∨L2(x2, y2) ∨x2 = y2 ∨L3(x3, y3)\n(20)\nθ ∨L3(x3, y3) ∨x3 = y3 ∨L2(x2, y2) .\n(21)\nOtherwise, there would be a tuple t satisfying Φ ∧¬θ ∧M2(x2, y2) ∧¬L3(x3, y3)\nand a tuple t′ satisfying Φ ∧¬θ ∧¬L2(x2, y2) ∧M3(x3, y3). Then f(t, t′, t′) would\nsatisfy ¬θ ∧M2(x2, y2) ∧M3(x3, y3), which is impossible by (17). Suppose without\nloss of generality that Φ implies θ ∨L2(x2, y2) ∨(x2 = y2) ∨L3(x3, y3). Since Φ also\nimplies (18), we have that Ψ contains the graph bijunctive formula\nθ ∨\n\u0000(L2(x2, y2) ∨x2 = y2 ∨L3(x3, y3)) ∧(x2 ̸= y2 ∨L3(x3, y3) ∨x3 = y3)\n\u0001\n.\n(22)\nWe ﬁnally show that Ψ implies φ. Let t be a tuple that satisﬁes Ψ. If t satisﬁes\nθ ∨(x1 = y1) there is nothing to show, so suppose otherwise. Then (16), which is\ngraph bijunctive and thereofore in Ψ, implies that either x2 ̸= y2 or x3 ̸= y3. If\nx2 ̸= y2, then by the ﬁrst conjunct in (22) we have that L2(x2, y2) or L3(x3, y3), in\nwhich case t satisﬁes φ and we are done. Otherwise, suppose that x2 = y2. Then\nx3 ̸= y3 as we have seen above. But then the second conjunct in (22) implies that\nL3(x3, y3), and we are again done.\n□\nProposition 9.7.16. Let B be a reduct of (V; E) with ﬁnite relational signature,\nand suppose that B has a balanced ternary polymorphism of type majority.\nThen\nCSP(B) can be solved in polynomial time.\nProof. Let Φ be an instance of CSP(B) with variables S, and let Ψ be the set of\nclauses obtained from Φ by replacing each constraint by its graph bijunctive deﬁnition\nover (V; E, N) which exists by Theorem 9.7.15. Clearly, Φ is satisﬁable in B if and\nonly if Ψ is satisﬁable in (V; E, N).\nWe associate to Ψ a 2SAT instance ψ = ψ(Ψ) as follows. For each unordered pair\n{u, v} of distinct variables u, v of Ψ we have a variable x{u,v} in ψ(Ψ). Then\n• if Ψ contains the clause E(u, v) or the clause E(u, v) ∨u = v then ψ(Ψ)\ncontains the clause {x{u,v}};\n• if Ψ contains the clause N(u, v) or the clause N(u, v) ∨u = v then ψ(Ψ)\ncontains the clause {¬x{u,v}};\n• if Ψ contains the clause N(a, b) ∨E(c, d) then ψ(Ψ) contains the clause\n{¬x{a,b}, x{c,d}}. Clauses of the form L1(a, b) ∨L2(c, d) are translated cor-\nrespondingly for all L1, L2 ∈{E, N};\n• if Ψ contains the clause (N(a, b) ∨a = b ∨E(c, d)) ∧(a ̸= b ∨E(c, d) ∨c =\nd) then ψ(Ψ) contains the clause {¬x{a,b}, x{c,d}}.\nClauses of the form\n(L1(u1, v1) ∨u1 = v1 ∨L2(u2, v2)) ∧(u1 ̸= v1 ∨L2(u2, v2) ∨u2 = v2) are\ntranslated correspondingly for all L1, L2 ∈{E, N}.\nAll other clauses of Ψ are ignored for the deﬁnition of ψ(Ψ).\nWe recall an important and well-known concept to decide satisﬁability of 2SAT\ninstances ψ.\nIf ψ contains clauses of size one, we can reduce to the case where\nall clauses have size two by replacing the clause {x} by {x, x}.\nThe implication\ngraph Gψ of a conjunction ψ of propositional clauses of size two is the directed graph\nwhose vertices T are the variables x, y, z, . . . of ψ, and the negations ¬x, ¬y, ¬z of the\nvariables. The edge set of Gψ contains (x, x′) ∈V 2 if ψ contains the clause {¬x, x′}\n(here we identify ¬(¬x) with x). It is well-known that ψ is unsatisﬁable if and only\nif there exists x ∈T such that x and ¬x belong to the same strongly connected\ncomponent (SCC) of Gψ.\n\n200\n9. SCHAEFER’S THEOREM FOR GRAPHS\n// Input: A set of graph bijunctive clauses Ψ\nDo\nWhile Ψ contains a clause of the form u = v do\nReplace each occurrence of v by u in Ψ.\nRemove literals of the form E(u, u), N(u, u), and u ̸= u from Ψ.\nIf Ψ contains an empty clause then reject.\nLoop.\nCompute the 2SAT instance ψ = ψ(Ψ), and the graph Gψ.\nIf Gψ contains x{u,v} such that x{u,v} and ¬x{u,v} are in the same SCC then\nReplace each occurrence of v by u in Ψ.\nRemove literals of the form E(u, u), N(u, u), and u ̸= u from Ψ.\nIf Ψ contains an empty clause then reject.\nLoop until Ψ does not change any more.\nAccept.\nFigure 9.3. Polynomial-time algorithm to test satisﬁability of a\ngiven set of graph bijunctive clauses.\nNow consider the algorithm displayed in Figure 9.3.\nWe make the following\nclaims.\n(1) Whenever the algorithm replaces all occurrences of a variable v in Ψ by a\nvariable u, then u and v must have the same value in all solutions of Ψ.\n(2) When the algorithm rejects an instance, then Ψ is unsatisﬁable.\n(3) When the algorithm accepts, then the input formula indeed is indeed satis-\nﬁable.\nThe ﬁrst claim can be shown inductively over the execution of the algorithm as follows.\nWhen the algorithm replaces all occurrences of v by u in line 4 of the algorithm, the\nﬁrst claim is trivially true. The only other variable contraction can be found in line\n10 of the algorithm.\nSo let Ψ be the set of graph bijunctive clauses when we reach line 10, and suppose\nthat x{u,v} and ¬x{u,v} lie in the same SCC of Gψ. Since x{u,v} and ¬x{u,v} belong\nto the same SCC, there is a path x{u,v} = x0, x1, . . . , xn = ¬x{u,v} from x{u,v} to\n¬x{u,v}, and a path ¬x{u,v} = y0, y1, . . . , ym = x from ¬x{u,v} to x{u,v}.\nSuppose that Ψ has a solution s: S →V . We have to show that s(u) = s(v).\nSuppose otherwise that s(u) ̸= s(v); without loss of generality, E(s(u), s(v)) holds.\nLet {ui, vi} be the pair of variables of Φ that corresponds to xi. We show by induction\non i that if xi is positive, then E(s(ui), s(vi)), and if xi is negative then N(s(ui), s(vi)).\nSuppose without loss of generality that xi is positive, and suppose inductively that\nE(s(ui), s(vi)). There is a clause in Ψ that contributed the edge (xi, xi+1) to Gψ. If\nxi+1 is a positive literal, then this clause is either of the form N(ui, vi)∨E(ui+1, vi+1),\nor of the form\n(N(ui, vi) ∨ui = vi ∨E(ui+1, vi+1)) ∧(ui ̸= vi ∨E(ui+1, vi+1) ∨ui+1 = vi+1) .\nIn both cases, the clause together with E(s(ui), s(vi)) implies that E(s(ui+1), s(vi+1)).\nThe argument in the case that xi+1 is a negative literals is similar. For i + 1 = n we\nobtain that N(s(u), s(v)), in contradiction to our assumption. Therefore, we conclude\nthat s(u) = s(v), which concludes the proof of the ﬁrst claim.\nSince the only modiﬁcations to Ψ are variable contractions, the ﬁrst claim implies\nthat when at some stage during the execution of the algorithm the formula Ψ contains\nan empty clause, then there is indeed no solution to the original input formula; this\nproves the second claim.\n\n9.7. ALGORITHMS FOR GRAPH-SAT PROBLEMS\n201\nTo prove the third claim, suppose that the algorithm accepts. Let ψ = ψ(Ψ) be\nthe 2SAT instance in the ﬁnal round of the main loop of the algorithm, and let T be\nthe set of variables of ψ. The 2SAT formula ψ must have a solution, since otherwise\nthe algorithm would have changed Φ, in contradiction to our assumptions. From a\nsolution t: T →{0, 1} for ψ we obtain a solution s: S →V for the clause set Ψ at\nthe end of the execution of the algorithm by assigning distinct vertices of V to every\nvariable of Ψ such that (s(u), s(v)) ∈E if and only if s(x{u,v}) = 0. We also get\na solution to the originally given set of clauses (before contractions of variables) by\nsetting contracted variables to the same value.\nThe three claims show the correctness of the algorithm. It is easy to see that the\nalgorithm can be implemented in polynomial (in fact, in quadratic) time in the input\nsize.\n□\n9.7.4. Tractability of types max and min. We are left with the case where B\nhas a canonical binary injective polymorphism of type max or min, which corresponds\nto case (f) of Proposition 9.3.4.\nWe claim that we can assume that this polymorphism is either balanced, or of\ntype max and E-dominated, or of type min and N-dominated.\nProposition 9.7.17. If B = (V; E, N, ̸=, . . .) is ﬁrst-order deﬁnable in (V; E)\nand has a canonical binary injective polymorphism of type max (min), then it also\nhas a canonical binary injective polymorphism of type max which is balanced or E-\ndominated (N-dominated).\nProof. We prove the statement for type max (the situation for min is dual). Let\np be the polymorphism of type max. Then h(x, y) := p(x, p(x, y)) is not N-dominated\nin the ﬁrst argument; this is easy to see. But then p(h(x, y), h(y, x)) is either balanced\nor E-dominated, and still of type max.\n□\nWe apply Theorem 6.3.4 to our setting as follows.\nProposition 9.7.18. Let B be a structure with a ﬁrst-order deﬁnition in (V; E)\nand a ﬁnite relational signature, and suppose B is preserved by a binary canonical\ninjection which is of type max and balanced or E-dominated, or of type min and\nbalanced or N-dominated. Then CSP(B) can be solved in polynomial time.\nProof. First note that\nCSP(V; E, ¬E, N, ¬N, =, ̸=)\ncan be solved in polynomial time. One way to see this is to verify that all relations\nare preserved by a balanced polymorphism of type majority, and to use the algorithm\npresented in Section 9.7.3. We observe the following.\n• A canonical binary injection which is of type min and N-dominated is an\nembedding of (V; E, =)2 into (V; E, =).\n• A canonical binary injection which is of type max and E-dominated is a an\nembedding of (V; N, =)2 into (V; N, =).\n• A canonical binary injection which is of type max and balanced is an em-\nbedding of (V; ¬E, =)2 into (V; ¬E, =).\n• A canonical binary injection which is of type min and balanced is an em-\nbedding of (V; ¬N, =)2 into (V; ¬N, =).\nIn each case, polynomial-time tractability of CSP(B) follows from Theorem 6.3.4.\n□\nThis completes the proof of Proposition 9.3.4.\n\n202\n9. SCHAEFER’S THEOREM FOR GRAPHS\n9.8. Classiﬁcation\nIn this section we present a reﬁned description of the polymorphisms of structures\nwith a ﬁrst-order deﬁnition in (V; E) that imply tractability. This leads to a dichotomy\nresult that has already been stated in Theorem 9.1.4, and which holds without any\ncomplexity-theoretic assumptions: either\n(1) there is a primitive positive interpretation of all ﬁnite structures in the\nmodel-complete core of B, or\n(2) B has a cyclic polymorphism modulo an endomorphism.\nIt follows from Proposition 5.6.10 that (1) and (2) are indeed disjoint cases. In order to\nprove that every B satisﬁes (1) or (2) above, we ﬁrst determine a list of 17 operations\nwith the following properties:\n(a) every structure B with a ﬁrst-order deﬁnition in (V; E) either interprets\n({0, 1}; 1IN3) or ({0, 1}; NAE) or is preserved by one of those 17 operations;\nand\n(b) the list is minimal, that is, if any operation is removed from the list, then\nthe list looses property (a).\nOur next step (Proposition 9.8.4) will be the veriﬁcation that each of the 17\noperations generates an operation that is cyclic modulo an endomorphism of (V; E).\nIt will also turn out that CSP(B) can be solved in polynomial time if B has one of\nthose operations as a polymorphism (Proposition 9.8.5).\nDefinition 9.8.1. Let B be a behaviour for binary functions on (V; E). A ternary\ninjection f : V3 →V is hyperplanely of type B if the binary functions (x, y) 7→\nf(x, y, c), (x, z) 7→f(x, c, z), and (y, z) 7→f(c, y, z) have behaviour B for all c ∈V.\nWe have already met a special case of this concept in Deﬁnition 9.7.9 of Sec-\ntion 9.7.2: a ternary function is balanced if and only if it is hyperplanely balanced of\ntype p1. The following behaviors of binary functions appear hyperplanely in ternary\nfunctions of our classiﬁcation result.\nDefinition 9.8.2. A binary injection f : V2 →V is of type\n• E-constant if the image of f is a clique;\n• N-constant if the image of f is an independent set;\n• xnor if for all u, v ∈V2 with ̸≠=(u, v) the relation E(f(u), f(v)) holds if\nand only if EE(u, v) or NN(u, v) holds;\n• xor if for all u, v ∈V2 with ̸≠=(u, v) the relation E(f(u), f(v)) holds if and\nonly if neither EE(u, v) nor NN(u, v) hold.\nRecall from Deﬁnition 5.5.8 that I6 := IV\n6 denotes the 6-ary relation deﬁned by\n{(x1, x2, y1, y2, z1, z2) ∈V6 | (x1 = x2 ∧y1 ̸= y2 ∧z1 ̸= z2)\n∨(x1 ̸= x2 ∧y1 = y2 ∧z1 ̸= z2)\n∨(x1 ̸= x2 ∧y1 ̸= y2 ∧z1 = z2)} .\nSimilarly, we deﬁne relations E6 and N6 by altering the above deﬁnition and replacing\nall occurrences of ̸= by E and N, respectively.\nTheorem 9.8.3. Let B be a structure with a ﬁrst-order deﬁnition in (V; E).\nThen either one of the following relations is primitive positive deﬁnable in B: I6,\nE6, N6, H1, H′\n1, H2, H′\n2, and ({0, 1}; 1IN3) or ({0, 1}; NAE) are primitive positive\ninterpretable in B, or B has a polymorphism of one of the following types.\n(1) A constant operation,\n(2) a balanced binary injection of type max,\n\n9.8. CLASSIFICATION\n203\n(3) an E-dominated binary injection of type max,\n(4) a function of type majority which is hyperplanely of type projection and\nbalanced,\n(5) a function of type majority which is hyperplanely E-constant,\n(6) a function of type majority which is hyperplanely of type max and E-dominated.\n(7) a function of type minority which is hyperplanely of type projection and\nbalanced,\n(8) a function of type minority which is hyperplanely of type projection and E-\ndominated,\n(9) a function of type minority which is hyperplanely of type xnor and balanced,\n(10) a binary injection which is E-constant,\nor the dual of one of the last seven operations.\nProof. If B has a constant endomorphism, then we are in case (1), so we may\nassume that this is not the case.\nFirst consider the case where all polymorphisms of B are essentially unary. Then\neither I6, N6, or E6 is preserved by all polymorphisms of B, and hence primitive\npositive deﬁnable in B, and we are done. So we assume that B has an essential\noperation. By Lemma 5.3.10, we even have a binary essential polymorphism f.\nConsider now the case that eE ∈Pol(B). Then consider the structure D induced\nin B on the image D := eE[V]. This structure D is preserved by all permutations\nof its domain, and hence is ﬁrst-order deﬁnable in (D; =). It follows from Corol-\nlary 6.4.1 that D either has a constant polymorphism, or a binary injection, or all\npolymorphisms of D are essentially unary. The structure D cannot have a constant\nendomorphism as otherwise also B has a constant polymorphism by composing the\nconstant with eE. Suppose that f(a, a) = f(a, b) for all a, b ∈V with E(a, b). We\nclaim that f(u, u) = f(u, v) for every u, v ∈V. To see this, let w ∈V be such that\nE(u, w) and E(v, w). Then f(u, u) = f(u, w) = f(u, v), as required. It follows that f\ndoes not depend on its ﬁrst variable, a contradiction. Hence, there exist a, b ∈V such\nthat E(a, b) and f(a, a) ̸= f(a, b). Similarly, there exist c, d ∈V such that E(c, d)\nand f(c, c) ̸= f(d, c). Let T be an inﬁnite clique adjacent to a, b, c, d. Then f is either\nessential on T ∪{a, b} or on T ∪{c, d}, both cliques. Suppose without loss of generality\nthat f is essential on C = T ∪{a, b}. Since all operations with the same behaviour\nas eE generate each other, we can also assume that the image of eE is C. Then the\nrestriction f ′ of (x1, x2) 7→eE(f(x1, x2)) to eE[V] is an essential polymorphism of\nD. Hence, Corollary 6.4.1 implies that D has a binary injective polymorphism h′.\nThen h(x, y) := h′(eE(x), eE(y)) is a polymorphism of B. But h is a binary canonical\ninjection which is E-constant, and so B has a polymorphism from Item (10) of our\nlist. When B is preserved by eN the dual argument works.\nHence, by Theorem 9.2.3 it remains to consider the case where the endomorphisms\nof B are generated by the automorphisms of B, that is, B is a model-complete core\n(Theorem 3.6.11). By Theorem 9.2.6 there are ﬁve possibilities for End(B). Suppose\nﬁrst that B is preserved by all permutations on V. Then by Corollary 6.4.1, B is\npreserved by all binary injections, and in particular B is preserved by, say, a balanced\nbinary canonical injection operation of type max.\nWe can therefore assume that End(B) does not contain all permutations. We\nconsider the case where the automorphism of (V; E) are dense in End(B). If H1 is\nprimitive positive deﬁnable in B, then we have found a primitive positive interpreta-\ntion of ({0, 1}; 1IN3) in B by Proposition 9.4.3. Otherwise, Proposition 9.3.4 applies,\nand Pol(B) contains a binary canonical injection of type max or min, or a function\nof type minority or majority. If it contains a canonical injection of type max or min,\nthen B is preserved by some of the operations from case (2), (3), or their duals, by\n\n204\n9. SCHAEFER’S THEOREM FOR GRAPHS\nProposition 9.7.17. Otherwise, Pol(B) contains a ternary injection t of type minority\nor majority, and one of the binary canonical injections of type projection listed in\nTheorem 9.3.8, which we denote by p. Set s(x, y, z) := t(p(x, y), p(y, z), p(z, x)) and\nw(x, y, z) := s(p(x, y), p(y, z), p(z, x)). Then w has the same behavior as one of the\noperations from case (4) to case (9) — see Figure 9.4; we leave the veriﬁcation to the\nreader.\nNow suppose that End(B) is the monoid generated by sw. If H2 is primitive pos-\nitive deﬁnable in B, then we have a primitive positive interpretation of ({0, 1}; 1IN3)\nin B by Proposition 9.4.3. Otherwise we are done by Proposition 9.4.2, since the\nfunctions that appear in Proposition 9.4.2 are a subset of the function that appear in\nProposition 9.3.4 and that we have treated above.\nNext consider the case where End(B) is the monoid generated by −. If the relation\nH′\n1 is primitively positively deﬁnable in B, then ({0, 1}; NAE) has a primitive positive\ninterpretation in B by Proposition 9.5.2. Otherwise we are done by Proposition 9.5.3.\nIf End(B) is the monoid generated by {sw, −} and H′\n2 is primitive positive de-\nﬁnable in B, then we have a primitive positive interpretation of ({0, 1}; NAE) in B\nby Proposition 9.4.3. Otherwise we are done by Proposition 9.6.3.\n□\nProposition 9.8.4. The 17 operations listed in Theorem 9.8.3 generate 17 dis-\ntinct clones, each containing an operation which is cyclic modulo a unary operation.\nProof. Observe that all of the 17 operations listed in Theorem 9.8.3 are canon-\nical as functions over (V; E).\nLet g be one of them.\nBy Lemma 5.6.5 there is a\nhomomorphism µ from (V; g)2 to an algebra A = ({=, E, N}, f) (where =, E, and\nN are the image of µ for the pairs (x, y) ∈V2 such that x = y, E(x, y), or N(x, y),\nrespectively).\nIn case (1), case (10), and its dual, the algebra A is not idempotent. In case (1),\nwhen g is constant, then g is in particular a cyclic polymorphism. In case (10), the\nimage of g induces an inﬁnite clique in (V; E). As in the proof of Corollary 3.6.2\nwe see that B is preserved by all permutations of its domain. Also note that A has\na congruence with the congruence classes {=} and {E, N} (see Proposition 6.1.4),\nand in the corresponding quotient algebra g denotes max with respect to the order\n{=} < {E, N}. It is then easy to see that f : (x, y, u, v) 7→g(g(g(x, y), u), v) is a cyclic\noperation modulo an endomorphism of (V; E). The dual proof works for the dual of\ncase (10).\nBy Theorem 5.6.4 in combination with Theorem 5.6.2 and Theorem 5.6.3, every\nﬁnite idempotent algebra either\n• has a 2-element factor all of whose operations are projections, or\n• has a cyclic term.\nIf the second case applies, then Corollary 5.6.8 shows that B has a cyclic polymor-\nphism modulo an endomorphism. Therefore, it suﬃces to show in the remaining 14\ncases that all factors of A contain operations that are not projections. Since in those\n14 cases both E and N are preserved by g, the relation ̸= is also preserved, and\n{E, N} induce a subalgebra of A. In this subalgebra and if the operation g is ternary,\nit either acts as a majority (that is, g(x, x, y) = g(x, y, x) = g(y, x, x) = x), or as a\nminority (that is, g(x, x, y) = g(x, y, x) = g(y, x, x) = y). If f is binary, it satisﬁes\ng(x, y) = g(y, x) in this subalgebra. In all cases, f does not act as a projection. Four\nout of the 14 remaining operations are balanced, which is equivalent to saying that\nboth {E, =} and {N, =} induce a subalgebra B in A. In this case it is easy to check\n\n9.8. CLASSIFICATION\n205\nBinary injection type p1\nType majority\nType minority\nBalanced\nHp. balanced, type p1\nHp. balanced, type p1\nE-dominated\nHp. E-constant\nHp. type p1, E-dominated\nN-dominated\nHp. N-constant\nHp. type p1, N-dominated\nBalanced in 1st, E-dom. in 2nd arg.\nHp. type max, E-dom.\nHp. type xnor, balanced.\nBalanced in 1st, N-dom. in 2nd arg.\nHp. type min, N-dom.\nHp. type xor, balanced.\nFigure 9.4. Minimal tractable canonical functions of type majority\nand minority, and their corresponding canonical binary injections of\ntype projection.\nfrom the description of the balanced operations in Theorem 9.8.3 that\ng(x, y) satisﬁes g(x, y) = g(y, x) if f is binary, and\n(23)\nh(x, y) := g(x, x, y) satisﬁes h(x, y) = h(y, x) if g is ternary.\n(24)\nSo g is not a projection in those factors as well. For ﬁve of the remaining non-balanced\noperations we have that {E, =} induces a subalgebra of A. Again, g satisﬁes the\ncondition in (23). For the other ﬁve remaining operations, the set {N, =} induces\na subalgebra, and the argument that the operation f is not a projection in those\nalgebras is analogous.\nFinally, we have to argue that the operation g is in none of the 2-element ho-\nmomorphic images of A a projection. Since all of the 14 remaining operations are\ninjective, they have a congruence with the classes {E, N} and {=} (Proposition 6.1.4).\nThen the operation g satisﬁes (23) in the corresponding factor. It can be veriﬁed that\nfrom all 14 operations, only\n• the balanced operation of type max,\n• the N-dominated operation of type min,\n• and the edge majority that is hyperplanely of type min and N-dominated\npreserve the relation E(x, y) ⇔E(u, v). In those cases, the algebra A has a congru-\nence with the classes {E} and {N, =}. For the balanced operation of type max, and\nthe N-dominated operation of type min, in the corresponding quotient the operation g\nsatisﬁes the condition in (23). For the edge majority that is hyperplanely of type min\nand N-dominated, the condition in (24) applies. Congruences of A with the classes\n{N} and {E, =} can be checked analogously.\n□\nLemma 9.8.5. Suppose that Pol(B) contains one of the 17 operations from Theo-\nrem 9.8.3. Then every ﬁnite signature reduct B′ of B has a polynomial-time tractable\nCSP.\nProof. For the constant operation this is Proposition 1.1.11. Cases (2) and (3)\nare tractable by case (f) of Proposition 9.3.4. In all cases, the duals can be solved\nanalogously. The functions of type majority or minority are tractable by cases (b)\nto (e) of Proposition 9.3.4: in those cases, certain binary canonical injections of\ntype projection are required – these are obtained by identifying any two variables of\nthe function of type majority / minority; Figure 9.4 shows which function of type\nmajority / minority yields which type of binary injection. We leave the veriﬁcation\nto the reader.\nFinally, let f(x, y) be an E-constant binary injection (case (10)),\nand denote the reduct corresponding to this clone by B. Then g(x) := f(x, x) is a\nhomomorphism from B to the structure C induced by the image g[V] in B. This\nstructure C is invariant under all permutations of its domain, and hence is deﬁnable\nin (g[V]; =); such structures have been treated in Chapter 6. The structure C has a\n\n206\n9. SCHAEFER’S THEOREM FOR GRAPHS\nbalanced \nmax\nsw\nconstant\neE\nE-\nconstant\nNP-complete\nin P\n-\nE-dom \nmax\np1 \nE-dom\np1 \nbalanced \np1 E-\nsemi-dom\nmajority\nhp balanced \np1\nminority\nhp p1 \nbalanced \nmajority\nhp E-\nconstant\nminority\nhp xnor \nbalanced\nmajority\nhp max E-\ndom\nminority \nhp p1 \nE-dom \nPol(H1)\nPol(H2)\nPol(H'1)\nPol(E6)\n12,13:\n14,15:\n6:\n7,8:\n11:\n9,10:\n16,17:\n2,3:\n1:\n4,5:\nPol(H'2)\nPol(I6)\nFigure 9.5. The border:\nMinimal tractable and maximal hard\nclones containing Aut((V; E)).\nbinary injection among its polymorphisms (namely, the restriction of f to C). It then\nfollows from Theorem 6.4.2 that CSP(C) is tractable. Hence, CSP(B) is tractable as\nwell, since B and C are homomorphically equivalent.\n□\nFigure 9.5 shows the border between the hard and the tractable clones.\nThe\npicture contains all minimal tractable clones as well as all maximal hard clones, plus\nsome other clones that are of interest in this context. Lines represent containment of\nclones, but edges that are implied by transitivity of containment are not drawn. Note\nthat lines do not mean to imply that there are no other clones between them which\nare not shown in the picture. Clones are symbolized with a double border when they\nhave a dual clone (generated by the dual function in the sense of Deﬁnition 9.3.7,\nwhose behavior is obtained by exchanging E with N, max with min, and xnor with\nxor). Of two dual clones, only one representative (the one which has E and max in\nits deﬁnition) is included in the picture. The numbers of the minimal tractable clones\nrefer to the numbers in Theorem 9.8.3. “E-semidom” refers to “balanced in the ﬁrst\nand E-dominated in the second argument”.\nProof of Theorem 9.1.4. By Theorem 9.8.3, either there is a primitive pos-\nitive interpretation of ({0, 1}; 1IN3) in B, and the statement follows from Corol-\nlary 5.5.7, or B is preserved by one out of the 17 canonical operations listed in Theo-\nrem 9.8.3. By Proposition 9.8.4, these operations are cyclic modulo an endomorphism\nof B, and polynomial-time tractability for the CSP of ﬁnite-signature reducts of B\nfollows from Proposition 9.8.5.\n□\n\nCHAPTER 10\nTemporal Constraint Satisfaction Problems\nMartin Kutz, 2001\nThis chapter contains results from [41,42,50].\n10.1. Introduction\nA temporal relation is a relation R ⊆Qk, for some ﬁnite k, with a ﬁrst-order\ndeﬁnition in (Q; <), the ordered rational numbers (which can be thought of time\npoints). A temporal constraint language is a set of temporal relations, and will be\ntreated here as a relational structure with a ﬁrst-order deﬁnition in (Q; <). Constraint\nsatisfaction problems for temporal constraint languages will be called temporal CSPs\nin the following. We have already discussed some temporal constraint languages in\nSection 1.5: for instance and/or precedence constraints from scheduling, and Ord-\nHorn constraints on time points.\nThere are also several famous NP-complete temporal CSPs.\nFor example the\nBetweenness Problem [101], which has been introduced in Example 1.1.3 as a CSP\nwith domain Z, can also be formulated as CSP((Q; Betw)) where Betw is the ternary\nrelation Betw = {(x, y, z) ∈Q3 | (x < y < z) ∨(z < y < x)}. We have seen in Propo-\nsition 5.5.13 that this CSP is NP-hard. Similarly, the Cyclic Ordering Problem [101]\ncan be formulated as the CSP for (Q; {(x, y, z) | (x < y < z) ∨(y < z < x) ∨(z <\nx < y)}), and is also NP-complete [99] (a hardness proof using primitive positive\ninterpretations can be found in Section 10.2.3).\n207\n\n208\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nA subclass of temporal CSPs called ordering CSPs has been introduced in [109].\nAn ordering CSP is a temporal CSP where the constraint language only contains\nrelations where the arguments are pairwise distinct (thus, CSP((Q; ≤, ̸=)) is not an\nordering CSP). Satisﬁability thresholds for random instances of ordering CSPs have\nbeen studied in [103]. Approximability of ordering CSPs has been studied in [121].\nThe class of temporal constraint languages is of fundamental importance for in-\nﬁnite domain constraint satisfaction, since CSPs for such languages appear as im-\nportant special cases in several other classes of CSPs that have been studied, e.g.,\nconstraint languages about branching time, partially ordered time, spatial reasoning,\nand set constraints [59,85,127]. Moreover, several polynomial-time solvable classes\nof constraint languages on time intervals [86,140,165] can be solved by translation\ninto polynomial-time solvable temporal constraint languages.\nIn this chapter we prove a complete classiﬁcation of the computational complexity\nof CSP(B) when B is a temporal constraint language.\nTheorem 10.1.1. Let B be a structure with a ﬁrst-order deﬁnition in (Q; <), and\nlet C be the model-complete core of B. Then exactly one of the following two cases is\ntrue.\n• C has an (at most ternary) weak near unanimity polymorphisms modulo\nendomorphisms. In this case, CSP(B′) is in P for every ﬁnite reduct B′ of\nB.\n• All ﬁnite structures have a primitive positive interpretation with parameters\nin C. In this case, CSP(B) is NP-hard by Corollary 5.5.7.\nOur classiﬁcation proof is based on the universal-algebraic approach and Ramsey\ntheory as described in Chapter 5 and Chapter 8.\n10.2. Preliminaries\n10.2.1. Cameron’s theorem. In this subsection we recall the classical result\nof Cameron [69] that describes temporal constraint languages up to ﬁrst-order inter-\ndeﬁnability. For x1, . . . , xn ∈Q write −−−−−→\nx1 · · · xn when x1 < · · · < xn.\nTheorem 10.2.1 (Relational version of Cameron’s theorem; see e.g. [128]). Let\nB be a temporal constraint language. Then B is ﬁrst-order interdeﬁnable with exactly\none out of the following ﬁve homogeneous structures.\n• The dense linear order (Q; <) itself,\n• The structure (Q; Betw), where Betw is the ternary relation\n\b\n(x, y, z) ∈Q3 | −−→\nxyz ∨−−→\nzyx\n\t\n,\n• The structure (Q; Cycl), where Cycl is the ternary relation\n\b\n(x, y, z) | −−→\nxyz ∨−−→\nyzx ∨−−→\nzxy\n\t\n,\n• The structure (Q; Sep), where Sep is the 4-ary relation\n\b\n(x1, y1, x2, y2) | −−−−−−→\nx1x2y1y2 ∨−−−−−−→\nx1y2y1x2 ∨−−−−−−→\ny1x2x1y2 ∨−−−−−−→\ny1y2x1x2\n∨−−−−−−→\nx2x1y2y1 ∨−−−−−−→\nx2y1y2x1 ∨−−−−−−→\ny2x1x2y1 ∨−−−−−−→\ny2y1x2x1\n\t\n,\n• The structure (Q; =).\nThe relation Sep is the so-called separation relation; note that Sep(x1, y1, x2, y2)\nholds for elements x1, y1, x2, y2 ∈Q iﬀall four points x1, y1, x2, y2 are distinct and\nthe smallest interval over Q containing x1, y1 properly overlaps with the smallest\ninterval containing x2, y2 (where properly overlaps means that the two intervals have\na non-empty intersection, but none of the intervals contains the other).\n\n10.2. PRELIMINARIES\n209\nThe next theorem is also due to Cameron [69], and was his original motivation for\nthe investigation of structures with a ﬁrst-order deﬁnition in (Q; <). It is not used for\nour results; however, we would like to state it here because it provides a fundamentally\ndiﬀerent characterization of the class of temporal constraint languages.\nTheorem 10.2.2. A relational structure B is highly set-transitive if and only if\nit is a temporal constraint language.\n10.2.2. Polymorphisms of Temporal Constraint Languages. For this chap-\nter only, we make the following convention. We say that a set of operations F gener-\nates an operation g if F together with all automorphisms of (Q; <) locally generates\ng. In case that F contains just one operation f, we also say that f generates g.\nA k-ary operation f on Q deﬁnes a weak linear order ⪯on Qk, as follows: for x, y ∈\nQk, let x ⪯y iﬀf(x) ≤f(y). The following observation follows straightforwardly\nfrom Proposition 5.2.1.\nObservation 10.2.3. Let f and g be two k-ary operations that deﬁne the same\nweak linear order on Qk. Then f generates g and g generates f.\nWe now deﬁne fundamental operations on Q. The unary operation ↔is deﬁned\nas ↔(x) := −x in the usual sense. Let c be any irrational number, and let e be\nany order-preserving bijection between (−∞, c) and (c, ∞). Then the operation ⟳is\ndeﬁned by e(x) for x < c and by e−1(x) for x > c. With these operations and the\nnotion of generation, Cameron’s theorem can be rephrased as follows.\nTheorem 10.2.4 (Operational version of Camerons theorem; see e.g. [128]). Let\nB be a temporal constraint language. Then exactly one of the following holds.\n• Aut(B) equals Aut((Q; <));\n• The automorphisms of B are the permutations generated by ↔;\n• The automorphisms of B are the permutations generated by ⟳;\n• The automorphisms of B are the permutations generated by ↔and ⟳;\n• Aut(B) equals Sym(Q).\nIf f is a k-ary operation on Q, then the operation ↔f(↔x1, . . . , ↔xk) is called the\ndual of f. Note that if f preserves an m-ary relation R, then the dual of f preserves the\nrelation ↔R, which is deﬁned to be the relation {(↔a1, . . . , ↔am) | (a1, . . . , am) ∈R}.\nClearly, CSP((Q; R1, . . . , Rk)) and CSP((Q; ↔R1, . . . , ↔Rk)) are exactly the same\ncomputational problem.\n10.2.3. Hard temporal CSPs. In this subsection we discuss various important\nNP-complete temporal constraint satisfaction problems. We have already mentioned\nin the introduction that the Betweenness and the Cyclic Ordering Problem in [101]\ncan be formulated as temporal CSPs, and that these problems are NP-complete.\nThe corresponding relations Betw and Cycl re-appeared in Cameron’s theorem (The-\norem 10.2.1).\nAnother important relation for our classiﬁcation is the relation T3,\ndeﬁned as follows.\nDefinition 10.2.5. Let T3 be the ternary relation\n{(x, y, z) ∈Q3 | (x = y < z) ∨(x = z < y)}\nProposition 10.2.6. The structure ({0, 1}; 1IN3) has a primitive positive inter-\npretation in (Q; T3, 0). The problem CSP((Q; T3)) is NP-hard.\nProof. We give a 2-dimensional primitive positive interpretation I of the struc-\nture ({0, 1}; 1IN3) in (Q; T3, 0). The domain formula δI(x1, x2) is T3(0, x1, x2); the\nformula 1IN3I(x1, x2, y1, y2, z1, z2) is\n∃u (T3(u, x1, y1) ∧T3(0, u, z1));\n\n210\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nthe formula =I (x1, x2, y1, y2) is T3(0, x1, y2). The coordinate map h: δI(B2) →{0, 1}\nis deﬁned as follows. Let (b1, b2) be a pair of elements of B that satisﬁes δI. Then\nexactly one of b1, b2 must have value 0, and the other element is strictly greater than\n0. We deﬁne h(b1, b2) to be 1 if b1 = 0, and to be 0 otherwise.\nTo see that this is the intended interpretation, let (x1, x2), (y1, y2), (z1, z2) ∈\nδI(B2), and suppose that t := (h(x1, x2), h(y1, y2), h(z1, z2)) = (1, 0, 0) ∈1IN3. We\nhave to verify that (x1, x2, y1, y2, z1, z2) satisﬁes 1IN3I in B. Since h(x1, x2) = 1, we\nhave x1 = 0, and similarly we get that y1, z1 > 0. We can then set u to 0 and have\nT3(u, x1, y1) since 0 = u = x1 < y1, and we also have T3(0, u, z1) since 0 = u < z1.\nThe case that t = (0, 1, 0) is analogous.\nSuppose now that t = (0, 0, 1) ∈1IN3.\nThen x1, y1 > 0, and z1 = 0.\nWe can then set u to min(x1, y1), and therefore\nhave T3(u, x1, y1), and T3(0, u, z1) since 0 = z1 < u.\nConversely, suppose that\n(x1, x2, y1, y2, z1, z2) satisﬁes 1IN3I in B. Since T3(0, u, z1), exactly one out of u, z1\nequals 0. When u = 0, then because of T3(u, x1, y1) exactly one out of x1, y1 equals\n0, and we get that (h(x1, x2), h(y1, y2), h(z1, z2)) ∈{(0, 1, 0), (1, 0, 0)} ⊆1IN3. When\nu > 0, then x1 > 0 and y1 > 0, and so (h(x1, x2), h(y1, y2), h(z1, z2)) = (0, 0, 1) ∈\n1IN3.\nSince the orbit of 0 is primitive positive deﬁnable, NP-hardness of CSP((Q; T3))\nfollows from the NP-hardness of CSP(({0, 1}; 1IN3)) via Proposition 5.5.11.\n□\nWe will see in Theorem 10.6.3 that if no relation among Betw, Cycl, Sep, T3,\n↔T3, or E6 is primitive positive deﬁnable in a temporal constraint language B, then\nCSP(B) is tractable. In fact, when B is (Q; R) for one of the relations R above, then\nwe give primitive positive interpretations of ({0, 1}; 1IN3) with ﬁnitely many constants\nin B. Thus, hardness of temporal CSPs can always be shown with Proposition 5.5.11.\nWe have already seen this for Betw, T3 (and thus ↔T3), and E6, and close by showing\nit for Cycl and Sep. We thank Trung Van Pham for pointing out a simpler proof for\nCycl than our original proof which was inspired by the NP-hardness proof of [99] for\nthe ‘Cyclic ordering problem’ (see [101]).\nTheorem 10.2.7. The structure ({0, 1}; <, Betw) has a primitive positive inter-\npretation in (Q; Cycl, 0, 1). The structure ({0, 1}; 1IN3) has a primitive positive in-\nterpretation with parameters in (Q; Cycl), and CSP((Q; Cycl)) is NP-hard.\nProof. Our interpretation of (Q; <, Betw) in (Q; Cycl, 0, 1) is 1-dimensional.\nThe domain formula δ(x) is Cycl(0, x, 1), and deﬁnes the open interval (−1, 1) ⊆Q.\nThe coordinate map c is any isomorphism between (Q; <) and the substructure in-\nduced by these numbers. The interpreting relation for x < y is Cycl(0, x, y). It is\neasy to verify that the relation Cycl is not preserved by any of the relations listed in\nLemma 10.6.2. Hence, Betw has a primitive positive deﬁnition in (Q; Cycl, <), which\nis the interpreting formula for Betw in the interpretation.\nSince (Q; Betw) can in turn interpret primitively positively ({0, 1}; 1IN3) with pa-\nrameters by Proposition 5.5.13, the desired interpretation can be obtained by compos-\ning interpretations (see Section 5.5.4). We can then apply Proposition 5.5.11, and the\nNP-hardness of CSP((Q; Cycl)) follows from the NP-hardness of ({0, 1}; 1IN3).\n□\nAnother relation that appeared in Theorem 10.2.1 is the separation relation Sep.\nThe corresponding CSP is again NP-complete.\nProposition 10.2.8. There is a primitive positive interpretation of (Q; Betw) in\n(Q; Sep, −1, 1, 2), and therefore also a primitive positive interpretation of ({0, 1}; 1IN3)\nin (Q; Sep) with parameters. The problem CSP((Q; Sep)) is NP-hard.\nProof. Our interpretation of (Q; Betw) in (Q; Sep, −1, 1, 2) is 1-dimensional.\nThe domain formula δ(x) is Sep(−1, 1, x, 2), and deﬁnes the open interval (−1, 1) ⊆\n\n10.3. ENDOMORPHISMS\n211\nQ. The coordinate map c is any isomorphism between (Q; <) and the substructure\ninduced by these numbers. Then the formula Sep(x, z, y, 1) interprets Betw: x and y\nmust satisfy δ, and so −1 < x, y < 1. Therefore,\nBetw(c(x), c(y), c(z)) ⇔−1 < x < y < z < 1 or −1 < z < y < x < 1\n⇔Sep(x, z, y, 1)\nA primitive positive interpretation of ({0, 1}; 1IN3) can be obtained as follows.\nThe argument above shows that the structure (Q; Sep) can interpret primitively pos-\nitively (Q; Betw, 0) with parameters, which in turn can interpret primitively posi-\ntively ({0, 1}; 1IN3) by Proposition 5.5.13. Then the desired interpretation can be\nobtained by composing interpretations (see Section 5.5.4). We can then apply Propo-\nsition 5.5.11, and the NP-hardness of CSP((Q; Sep)) follows from the NP-hardness of\n({0, 1}; 1IN3).\n□\n10.3. Endomorphisms\nIn this section we study the endomorphisms of temporal constraint languages.\nAs an application, we obtain a reduction of the complexity classiﬁcation for temporal\nconstraint satisfaction problems to the classiﬁcation for those languages that admit a\nprimitive positive deﬁnition of the binary relation <.\nTheorem 10.3.1. Let B be a temporal constraint language. Then exactly one of\nthe following cases applies.\n(1) B has a constant endomorphism;\n(2) All endomorphisms of B preserve <;\n(3) End(B) equals the set of unary operations generated by ↔;\n(4) End(B) equals the set of unary operations generated by ⟳;\n(5) End(B) equals the set of unary operations generated by ↔and ⟳;\n(6) End(B) equals the set of all injective unary operations.\nProof. First note that all the cases are indeed disjoint: a constant endomor-\nphism violates <, and cannot be generated by a set of injective unary operations;\nthis shows that the ﬁrst case is distinct from all others. Disjointness of the remaining\ncases follows from Theorem 10.2.4.\nIf B has a non-injective endomorphism, then Corollary 5.3.7 shows that there\nis also a constant endomorphism.\nOtherwise all endomorphisms of B are injec-\ntive. We show that then all endomorphisms e of B are locally invertible: for any\na1, . . . , al ∈Q there exists a self-embedding f of B into B such that f(e(ai)) = ai\nfor all i ∈{1, . . . , l}. Because e is injective, there is an α ∈Aut((Q; <)) such that\nαe({a1, . . . , al}) = {a1, . . . , al}.\nThen (αe)l!, i.e., the composition of (αe) . . . (αe)\nwith l-factorial many terms of the form (αe), maps ai to itself for all 1 ≤i ≤l. Then\n(αe)l!−1α is also an endomorphism of B, and we have\n\u0000(αe)l!−1α\n\u0001\n(e(a1), . . . , e(al)) =\n(αe)l!(a1, . . . , al) = (a1, . . . , al). This proves that e is locally invertible.\nTheorem 3.6.7 shows that the endomorphisms of B are generated by the automor-\nphisms of B. The claim of the statement follows directly from Theorem 10.2.4.\n□\nThe following theorem shows that we can focus on constraint languages where <\nis primitive positive deﬁnable.\nTheorem 10.3.2. Let B be a temporal constraint language. Then it satisﬁes at\nleast one of the following:\n(a) There is a primitive positive deﬁnition of Cycl, Betw, or Sep in B.\n(b) Pol(B) contains a constant operation.\n(c) Aut(B) contains all permutations of Q.\n\n212\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\n(d) There is a primitive positive deﬁnition of < in B.\nProof. If there is a pp deﬁnition of Betw in B we are in case (a). Otherwise,\nsince Betw consists of two orbits of triples of the automorphism group of (Q; <),\nLemma 5.3.5 shows that B has a binary polymorphism that violates Betw. If there\nis a pp deﬁnition of < in B, we are in case (d). Otherwise, again by Lemma 5.3.5,\nthere is a unary polymorphism of B that violates <. Proposition 10.3.1 shows that\nB is preserved by a constant, −, or ⟳. For each of these three operations we show\nthe claim of the statement separately in the following three paragraphs.\nIf B is preserved by a constant we are in case (b), so we assume in the following\nthat B is not preserved by a constant.\nIf B is preserved by −, the relation Betw consists of only one orbit of triples,\nand Lemma 5.3.5 shows that there is an endomorphism that violates Betw. Proposi-\ntion 10.3.1 then implies that B is also preserved by ⟳. Thus, the relation Sep consists\nof only one orbit of 4-tuples. Again, either Sep has a pp deﬁnition, and we are in case\n(a), or there is an endomorphism that violates Sep. Proposition 10.3.1 now shows\nthat B is preserved by all injective unary operations and we are in case (c).\nIf B is preserved by ⟳, then the relation Cycl consists of only one orbit of triples.\nIf Cycl has a pp deﬁnition in B, we are in case (a). Otherwise, Lemma 5.3.5 shows\nthat there is an endomorphism that violates Cycl. Proposition 10.3.1 then shows that\nB is also preserved by −. But the statement of the lemma has already been shown in\nthe case that B is preserved by both −and ⟳in the previous paragraph, so we are\ndone.\n□\nIn case (a), there is a ﬁnite signature reduct B′ of B such that CSP(B′) is NP-\nhard, as we have seen in Section 10.2.3. In case (b), for all ﬁnite signature reducts B′\nof B the problem CSP(B) is trivially in P (see Proposition 1.1.11). In case (c) the\ncomplexity of CSP(B) has been classiﬁed in Chapter 6. In the following, we therefore\nstudy only those temporal constraint languages where < is pp deﬁnable.\n10.4. Lex-closed Constraints\nFirst-order expansions of (Q; <) can be divided into four (non-disjoint) groups:\nthose where the betweenness relation is primitive positive deﬁnable, those that are\npreserved by an operation called pp, an operation called dual-pp, or by the binary\ninjective operation called lex that we have already encountered in Section 8.3.3. None\nof the three polymorphisms pp, dual-pp, and lex alone guarantees tractability of the\nCSP. An illustration of the complexity classiﬁcation result for ﬁrst-order expansions\nof (Q; <) can be found in Figure 10.1.\n10.4.1. The operations lex and ll. An important class of temporal constraint\nlanguages are the languages preserved by the operation lex, introduced in Section 8.3.3.\nRecall that lex is a binary injective operation on Q such that lex(a, b) < lex(a′, b′) if\neither a < a′, or a = a′ and b < b′.\nBy Observation 10.2.3, all such operations\ngenerate the same clone. We also write\n• lexy,x for the operation (x, y) 7→lex(y, x),\n• lexy,−x for the operation (x, y) 7→lex(y, −x),\n• lexx,−y for the operation (x, y) 7→lex(x, −y),\n• lexx,y for the operation (x, y) 7→lex(x, y),\n• px for the operation (x, y) 7→x, and\n• py for the operation (x, y) 7→y.\nA k-ary operation f : Qk →Q is dominated by the i-th argument when for all\n¯a,¯b ∈Qk it holds that f(a1, . . . , ak) ≤f(b1, . . . , bk) if and only if ai ≤bi. Examples of\n\n10.4. LEX-CLOSED CONSTRAINTS\n213\nll\nNP-complete\nin P\npp\nlex\nmin\nmx\nmi\nFigure 10.1. An illustration of the classiﬁcation result for temporal\nconstraint languages that contain <. Double-circles mean that the\ncorresponding operation has a dual generating a distinct clone which\nis not drawn in the ﬁgure.\nFigure 10.2. Illustrations of the six basic operations lexx,y, lexx,−y,\nlexy,x, lexy,−x, px, py.\noperations dominated by the ﬁrst argument are px, lexx,y, and lexx,−y, and examples\nof operations dominated by the second argument are py, lexy,x, lexy,−x.\nIt is easy to see that the relation Betw is preserved by lex, and more generally\nby all operations that are dominated by one argument. Therefore, we are interested\nin further restrictions of languages preserved by lex that imply tractability of the\ncorresponding CSP.\nA large tractable temporal constraint language has been introduced in [42]. The\nlanguage is deﬁned in terms of a binary polymorphism, denoted by ll, and it has a\ndual version, which is tractable as well. We will see in Proposition 10.4.2 that this\nlanguage contains the class of Ord-Horn constraints (Section 1.5.9).\nDefinition 10.4.1. Let ll: Q2 →Q be such that ll(a, b) < ll(a′, b′) if\n• a ≤0 and a < a′, or\n• a ≤0 and a = a′ and b < b′, or\n• a, a′ > 0 and b < b′, or\n• a > 0 and b = b′ and a < a′.\nAll operations satisfying these conditions are by deﬁnition injective, and they all\ngenerate the same clone. For an illustration of ll and its dual, see Figure 10.3. It is\neasy to see that ll generates lex.\n\n214\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nx\ny\nx\ny\nFigure 10.3. A visualization of ll (left) and dual-ll (right).\nAll Ord-Horn relations (Section 1.5.9) are preserved by ll.\nProposition 10.4.2. All relations in Ord-Horn are preserved by ll and dual ll.\nProof. We give the argument for ll only; the argument for dual ll is analogous.\nIt suﬃces to show that every relation that can be deﬁned by a formula φ of the form\n(x1 = y1 ∧· · · ∧xk−1 = yk−1) →xk O yk is preserved by ll, where O ∈{=, <, ≤, ̸=}.\nLet t1 and t2 be two 2k-tuples that satisfy φ. Consider a 2k-tuple t3 obtained by\napplying ll componentwise to t1 and t2. Suppose ﬁrst that there is an i ≤k −1 such\nthat one of the tuples does not satisfy xi = yi. Then xi = yi is not satisﬁed in t3\nas well, by injectivity of ll, and therefore the tuple t3 satisﬁes φ. Now consider the\ncase that xi = yi holds for all i ≤k −1 in both tuples t1 and t2. Since t1 and t2\nsatisfy φ, the literal xkOyk holds in both t1 and t2. Because ll preserves all relations\nin {=, <, ≤, ̸=}, the literal xkOyk holds in t3, and therefore t3 satisﬁes φ as well.\n□\nSince the relation Rmin deﬁned by (x > y) ∨(x > z) (see Section 1.5.8) is\npreserved by ll but not by dual ll, the class of ll-closed constraints is strictly larger\nthan Ord-Horn.\n10.4.2. Operations generating ll, dual-ll, or lex. In this section we present\noperations that generate ll, dual-ll, or lex. We again use the concept of a behavior\nof operations over a relational structure; note that a k-ary operation f behaves like\na k-ary operation g on S = S1 × · · · × Sk if for all t, t′ ∈S we have f(t) ≤f(t′)\niﬀg(t) ≤g(t′). That is, the weak linear order induced by f on the tuples from G\n(in the sense of Observation 10.2.3) is the same as the weak linear order induced on\nthese tuples by g. Let Q+ denote the set of all positive rational numbers, and let Q−\n0\ndenote Q \\ Q+.\nDefinition 10.4.3. Let f, g be from Q2 →Q. Then [f|g] denotes an arbitrary\noperation from Q2 →Q with the following properties. For all x, x′, y, y′ ∈Q,\n• if x ≤0 and x′ > 0 then [f|g](x, y) < [f|g](x′, y′);\n• [f|g] behaves like f on Q−\n0 × Q;\n• [f|g] behaves like g on Q+ × Q;\nFor example, if f = lexx,y and g = lexy,x, then [f|g] behaves like ll.\nLemma 10.4.4. Let f, g ∈{lexx,y, lexx,−y, lexy,x, lexy,−x, px, py}, and let f ′ (g′)\nbe lexx,y if f (g) is dominated by the ﬁrst argument, and lexy,x otherwise.\nThen\n{lex, [f|g]} generates [f ′|g′](x, y).\nProof. By Proposition 5.2.1 it suﬃces to show that every relation R preserved\nby lex and [f|g] is preserved by [f ′|g′]. So let R be an arbitrary relation preserved\nby lex and [f|g], let k denote its arity, and let t1, t2 be k-tuples from R. We have to\nshow that t3 := [f ′|g′](t1, t2) is in R.\n\n10.4. LEX-CLOSED CONSTRAINTS\n215\nx\ny\ny\nx\nFigure 10.4. An illustration of the operation [py|py] (on the left)\nand the operation [lexy,x|lexy,x] (on the right).\nLet α ∈Aut((Q; <)) be such that for each entry x of t1 and for each entry y of\nt2, the value of αlex(x, y) is negative when x ≤0, and positive otherwise. We will\nshow that there is an automorphism of (Q; <) that maps the tuple\ns := [f|g](αlex(t1, t2), lex(t2, t1))\nto t3, which proves that t3 is in R. It suﬃces to show for j1, j2 ∈[k] that\ns[j1] ≤s[j2] if and only if t3[j1] ≤t3[j2] .\n(25)\nWe can assume that t1[j1] ≤t1[j2] by exchanging the name of j1 and j2 if neces-\nsary, and distinguish three cases:\n• t1[j1] ≤0, t1[j2] > 0. Then t3[j1] < t3[j2] by deﬁnition of [f ′|g′]. Since for\nj ∈[k], the value of αlex(t1[j], t2[j]) is positive if and only if the value of\nt1[j] is positive, we have s[j1] < s[j2] by deﬁnition of [f|g]. Thus we have\nveriﬁed (25) in this case.\n• t1[j2] ≤0. Note that f(lex(x, y), lex(y, x)) behaves like f ′(x, y). Thus, writ-\ning a[j] for lex(t1[j], t2[j]) and b[j] for lex(t2[j], t1[j]), we have the following\nequivalences.\nt3[j1] ≤t3[j2]\niﬀ\nf ′(t1[j1], t2[j1]) ≤f ′(t1[j2], t2[j2])\niﬀ\nf(a[j1], b[j1]) ≤f(a[j2], b[j2])\niﬀ\nf(αa[j1], b[j1]) ≤f(αa[j2], b[j2])\niﬀ\ns[j1] ≤s[j2]\n• t1[j1] > 0. This case is analogous to the previous one and left to the reader.\n□\nLemma 10.4.5. For f, g ∈{py, lexy,x} the operation [f|g] generates [lexx,y|g].\nIn particular, for f = g = lexy,x the lemma shows that [f|g] generates ll. For\nf = g = py, the lemma shows that [f|g] generates [lexx,y|py] and in particular lexx,y.\nSee Figure 10.4 for illustrations of those two cases.\nProof of Lemma 10.4.5. We show that every relation R preserved by [f|g] is\npreserved by [lexx,y|g], and conclude by Proposition 5.2.1 that [f|g] generates [lexx,y|g].\nSo let R be an arbitrary relation preserved by [f|g], let k denote its arity, and let t1, t2\nbe k-tuples from R. We have to show that t3 := [lexx,y|g](t1, t2) is in R.\nLet l denote the number of non-positive values in t1. We take α1, . . . , αl from\nAut((Q; <)) such that αi maps all but the i smallest values in t1 to positive values.\n\n216\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nWe deﬁne a sequence of tuples s1, . . . , sl as follows: s1 = t2, and for i ≥2\nsi := [f|g](αit1, si−1) .\nClearly, for all i ∈[l] the tuple si is in R. We will show that there is an automor-\nphism of (Q; <) that maps sl to t3, which proves that t3 is also in R. By symmetry\nit is enough to show for j1, j2 ∈[k] with t1[j1] ≤t1[j2] that\nsl[j1] ≤sl[j2] if and only if t3[j1] ≤t3[j2] .\n(26)\nWe distinguish three cases:\n• t1[j1] = t1[j2] ≤0. Since αit1[j1] = αit1[j2] for all i ∈[l], we have sl[j1] ≤\nsl[j2] if and only if s1[j1] ≤s1[j2].\nSince s1 = t2 and t1[j1] ≤0, and\nbecause f is dominated by the second argument, s1[j1] ≤s1[j2] if and only\nif t3[j1] ≤t3[j2], which proves (26).\n• t1[j1] < t1[j2], t1[j1] ≤0. Let i ∈[l] be such that αit1[j1] ≤0 and αit1[j2] >\n0.\nBy deﬁnition of [f|g] we see that si[j1] < si[j2].\nBecause αit1[j1] <\nαit1[j2] for all i ∈[l], and because [f|g] preserves <, by induction on i′ ≥i\nwe have that si′[j1] < si′[j2]. In particular, sl[j1] < sl[j2]. On the other\nhand, t3[j1] < t3[j2] by deﬁnition of lexx,y and [lexx,y|g], and so (26) also\nholds in this case.\n• t1[j1] > 0. Observe that by the choice of l we have αit1[j1] > 0 for all i ∈[l].\nThus (26) holds, because both [f|g] and [lexx,y|g] behave like g on Q+ × Q.\n□\n10.4.3. A syntactic description of ll-closed constraints. In this section we\npresent a syntactic characterisation of ll-closed relations. As a consequence, we also\nobtain a better understanding of the clone generated by ll.\nDefinition 10.4.6. A formula is called ll-Horn if it is a conjunction of formulas\nof the following form\n(x1 = y1 ∧· · · ∧xk = yk) ⇒(z1 < z0 ∨· · · ∨zl < z0) , or\n(x1 = y1 ∧· · · ∧xk = yk) ⇒(z1 < z0 ∨· · · ∨zl < z0 ∨(z0 = z1 = · · · = zl))\nwhere 0 ≤k, l.\nNote that k or l might be 0: if k = 0, we obtain a formula of the form z1 <\nz0∨· · ·∨zl < z0 or (z1 < z0∨· · ·∨zl < z0∨(z0 = z1 = · · · = zl)), and if l = 0 we obtain\na disjunction of disequalities. Also note that the variables x1, . . . , xk, y1, . . . , yk, z0,\n. . . , zl need not be pairwise distinct. On the other hand, the clause z1 < z2 ∨z3 < z4\nis an example of a formula that is not ll-Horn.\nThe following result is from [42], but Antoine Mottet found a mistake in the proof\npresented there; the new proof presented below is also due to him.\nProposition 10.4.7. A temporal relation is preserved by ll if and only if it can\nbe deﬁned by an ll-Horn formula.\nProof. The proof that every relation deﬁned by an ll-Horn formula is ll-closed\nis similar to the proof of Proposition 10.4.2.\nWe just need to additionally check\nthat the relation deﬁned by z1 < z0 ∨· · · ∨zl < z0 and the relation deﬁned by\nz1 < z0 ∨· · · ∨zl < z0 ∨(z0 = · · · = zl) are preserved by ll.\nSo let s and t be\ntwo assignments that satisfy φ := z1 < z0 ∨· · · ∨zl < z0, and let r := ll(s, t). Let\ni ∈{1, . . . , l} be such that s(zi) = min(s(z1), . . . , s(zl)). Note that s(zi) < s(z0). Let\nj ∈{1, . . . , l} be such that t(zj) < t(z0).\n• If s(zi) ≤0 then ll(s(zi), t(zi)) < ll(s(z0), s(z0)) since s(zi) < s(z0), and\nhence r satisﬁes φ.\n\n10.4. LEX-CLOSED CONSTRAINTS\n217\n• If s(zi) > 0, then s(z0) > s(zi) > 0 and s(zj) > s(zi) > 0, and hence\nll(s(zj), t(zj)) < ll(s(z0), s(z0)) since t(zj) < t(z0), and hence r satisﬁes φ.\nWhen t1 and t2 are satisfying assignments of z1 < z0 ∨· · · ∨zl < z0 ∨(z0 = · · · = zl)\nwhere one of the assignments satisﬁes the last clause, then the statement follows from\nthe fact that ll is injective and preserves ≤.\nLet R be a temporal relation, and let φ be a quantiﬁer-free formula in CNF that\ndeﬁnes R over (Q; <). In this formula, we replace literals of the form ¬(y < x) by\nx < y ∨x = y, and we use x ≤y as shortcut for those two literals. For reasons\nthat will become clear later, we additionally allow that clauses contain ‘clustered\nequations’ which are expressions of the form x1 = x2 = · · · = xn and which stand for\nx1 = x2 ∧· · · ∧x1 = xn; such an expression will be treated as one literal.\nWe describe four rewriting rules that yield a formula ψ that also deﬁnes R over\n(Q; <) such that R is preserved by ll if and only if ψ is ll-Horn.\n(1) If φ implies x = y for distinct variables x, y of φ, replace all occurrences of\nu in φ by x and add the clause x = y.\n(2) Suppose that φ contains a clause θ of the form\nx < y ∨u < v ∨θ′ ,\nlet φ′ be the other clauses of φ, and suppose that\n(φ′ ∧¬θ′ ∧x < y) implies (u ≤v ∨x ≤v)\nand (φ′ ∧¬θ′ ∧u < v) implies (x ≤y ∨u ≤y) .\nThen replace θ by\n(u ≤v ∨x ≤v ∨θ′) ∧(u ̸= v ∨x < y ∨θ′)\n∧(x ≤y ∨u ≤y ∨θ′) ∧(x ̸= y ∨u < v ∨θ′) .\n(3) Suppose that φ contains a clause θ of the form\nx < y ∨u < v ∨θ′ .\nLet φ′ be the other clauses of φ, and suppose that\n(φ′ ∧¬θ′ ∧x < y) implies u ≤v .\nThen replace θ by\n(u ≤v ∨θ′) ∧(x < y ∨u ̸= v ∨θ′).\n(4) Suppose that θ is a clause of φ of the form\nx1 ̸= y1 ∨· · · ∨xk ̸= yk ∨z1 < z0 ∨· · · ∨zl < z0 ∨u = v ,\nlet φ′ be the other clauses of φ, and that\nφ′ ∧x1 = y1 ∧· · · ∧xk = yk ∧z0 ≤z1 ∧· · · ∧z0 ≤zl ∧u = v\nimplies that z0 = z1 = · · · = zl. Then replace θ by\n(x1 ̸= y1 ∨· · · ∨xk ̸= yk ∨z0 ̸= z1 ∨· · · ∨z0 ̸= zl ∨u = v)\n∧(x1 ̸= y1 ∨· · · ∨xk ̸= yk ∨z1 < z0 ∨· · · ∨zl < z0 ∨z0 = z1 = · · · = zl) .\n(5) If φ contains a literal such that removing this literal from φ results in an\nequivalent formula, then remove the literal.\nWe claim that for each of the four rewriting rules, the resulting formula ψ is equivalent\nto φ. This is obvious for rules (1) and (5). To see that φ implies the new clauses in\nrule (2), let s be a satisfying assignment to φ. If s satisﬁes θ′, then s also satisﬁes\nthe new clauses, so let us assume that θ′ is false. Then s satisﬁes x < y or u < v.\nThe two cases are symmetric, so we only treat the case that s satisﬁes x < y in the\n\n218\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nfollowing. By assumption, s must then satisfy u ≤v ∨y ≤v, and hence the ﬁrst new\nclause is satisﬁed by s. Since x < y, the other new clauses are satisﬁed, too.\nNow suppose conversely that s is a solution to φ′ and the four new clauses, and\nsuppose for contradiction that θ does not hold. Because of the second and fourth new\nclause, we then must have u ̸= v and x ̸= y. Then the ﬁrst new clause implies that\nx ≤v and the third new clause implies that u ≤y. But then x ≤v ≤u ≤y ≤x, a\ncontradiction to x ̸= y.\nFor rule (3), let s be a solution to φ. Then s obviously satisﬁes the ﬁrst new clause\nif u < v or θ′ holds; otherwise, s must satisfy x < y because of θ. But then u ≥v by\nassumption and hence the ﬁrst new clause also holds in this case. The second new\nclause is weaker then θ, so it is also satisﬁed by s. Now suppose conversely that s\nsatisﬁes φ′ and the two new clauses, and suppose for contradiction that θ does not\nhold. Then in particular v ≤u holds and the ﬁrst new clause implies that u = v, and\nhence x < y because of the second new clause, contradiction to the assumption that\nθ does not hold.\nFinally, for the fourth rule, the ﬁrst new clause is a weakening of θ, and the second\nnew clause is a consequence of φ by assumption. Conversely, suppose that s satisﬁes\nall clauses of φ except for θ which is not satisﬁed. Then the ﬁrst new clause implies\nthat z1 < z1 ∨· · · ∨zl < z0, and thus the second new clause implies that u = v, and\nhence θ holds, contradiction. Hence, ψ is indeed equivalent to φ.\nNote that rules (2) and (3) strictly reduce the number of pairs of literals x < y\nand u < v in the same clause where y and v are distinct variables. Rule (4) leaves\nthis number invariant, but strictly reduces the number of literals of the form u = v or\nof the form u < v in the clause (here, we do not count complex equations). Rules (1)\nand (5) do not increase these numbers, and strictly reduce the number of variables\nthat occur more than once, or strictly reduce the total number of literals. Hence,\nwhen we repeatedly apply these rules, the procedure will eventually terminate.\nClaim 1. The formula ψ cannot contain a clause θ of the form x < y ∨u < v ∨θ′\nwhere x and u are distinct variables. Since rule (2) is not applicable, there must exist\na solution s to φ′ ∧¬θ′ ∧x < y ∧v < u ∧v < x or to φ′ ∧¬θ′ ∧u < v ∧y < x ∧y < u.\nSuppose the former is the case, since the latter case can be treated similarly. Since\nrule (3) is not applicable, there exists a solution t to φ′ ∧¬θ′ ∧u < v ∧y < x. Let\nα ∈Aut(Q; <) be such that αs(v) = 0. We claim that r = ll(αs, t) does not satisfy θ:\n• we have r(y) < r(x) since 0 < s(x), s(y) and t(y) < t(x);\n• we have r(v) < r(u) since s(v) = 0 and s(u) > 0;\n• ﬁnally, r does not satisfy θ′ since neither s nor t satisfy θ′.\nHence, r does not satisfy ψ, in contradiction to the assumption that ll preserves R.\nClaim 2. The formula ψ cannot contain a clause with two distinct literals x = y\nand u = v. This is because rule (5) and since φ is preserved by the injective function\nll.\nClaim 3. If ψ contains a clause with a literal z1 < z0 and a literal u = v, then\n{u, v} = {x, y}. This is because of Claim 1 and Claim 2, any such clause must be of\nthe form x1 ̸= y1 ∨· · · ∨xk ̸= yk ∨z1 < z0 ∨· · · ∨zl < z0 ∨u = v. Since rule (4) does\nnot apply, there exists a solution s to\nφ′ ∧x1 = y1 ∧· · · ∧xk = yk ∧z0 ≤z1 ∧· · · ∧z0 ≤zl ∧u = v\n∧z0 ̸= z1 ∨· · · ∨z0 ̸= zl .\nHence, there exists an i ∈{1, . . . , l} such that s(z0) ̸= s(zi).\nBecause the literal\nzi < z0 cannot be removed from ψ with rule (5), there exists a solution t to φ such\nthat zi < z0 is the only literal in θ satisﬁed by t. Let α ∈Aut(Q; <) be such that\nαt(zi) = 0. Then r := ll(αt, s) does not satisfy θ:\n\n10.4. LEX-CLOSED CONSTRAINTS\n219\nFigure 10.5. Illustration of an operation f generated by ll that\nsatisﬁes f(x, y) = αf(β(x), β(y)).\n• r satisﬁes θ′ ∧x1 = y1 ∧· · ·∧xk = yk since both t and s satisfy this formula.\n• r(zi) < r(z0) since 0 = αt(zi) < αt(z0).\n• r(zj) ≤r(z0) for all i ∈{1, . . . , k}\\{i} since t(z0) ≤t(zj) and s(z0) ≤s(zj).\n• r(u) ̸= r(v) since t(u) ̸= t(v) and ll is injective.\nThe three claims imply that each of the clauses of ψ must be logically equivalent to\nan implication as in Deﬁnition 10.4.6, and this concludes the proof.\n□\n10.4.4. Weak Commutativity. In this section we present a diﬀerent descrip-\ntion of ll-closed temporal constraint languages.\nLet c1, . . . , cn ∈Q be arbitrary.\nPartition the rationals Q = Q1 ⊎Q1 such that each of Q1 and Q2 is dense in Q, and\nlet f be any injective binary operation that preserves < and ≤such that\n• f(ci, ci) = ci for all i ≤n;\n• for x ∈Q1, we have that f(x, y1) > f(y2, x) for all y1, y2 > x;\n• for x ∈Q2, we have that f(x, y1) < f(y2, x) for all y1, y2 > x.\nWe even assume that f is bijective: since the image of any such function will induce\na dense linear order without endpoints in (Q; <), the existence of such a function\nfollows from ω-categoricity of (Q; <).\nFor an illustration of f, see Figure 10.5. The red vertices are the elements of\n{(x, x) | x ∈Q1}, and the blue blue vertices the elements of {(x, x) | x ∈Q2}.\nObserve that f(x, y) < f(z, z) for all x, y, z such that x < z or y < z.\nProposition 10.4.8. There are automorphisms α, β of (Q; <, c1, . . . , cn) such\nthat f(x, y) = αf(βy, βx) holds for all x, y ∈Q.\nProof. Let β be an automorphism of (Q; <, c1, . . . , cn) that maps Q1\\{c1, . . . , cn}\nto Q2\\{c1, . . . , cn} and Q2\\{c1, . . . , cn} to Q1\\{c1, . . . , cn}; such an automorphism can\neasily be constructed by going back-and-forth. To deﬁne α ∈Aut((Q; <, c1, . . . , cn)),\nlet d ∈Q be arbitrary. Since f and β are bijective, f ′ : (x, y) 7→f(βy, βx) is bijec-\ntive as well, so there exists a unique pair (a, b) ∈Q2 such that f ′(a, b) = d. Deﬁne\nα(d) = f(a, b). Then by deﬁnition αf(βy, βx) = f(x, y) holds for all x, y ∈Q, and it\nis straightforward to verify that α ∈Aut((Q; <, c1, . . . , cn)).\n□\n\n220\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nProposition 10.4.9. The operation f deﬁned above is generated by ll, and gen-\nerates ll.\nProof. It is easy to see that f interpolates ll. For the converse, it suﬃces to\nverify that f preserves all ll-Horn formulas, by Proposition 10.4.7. Since f is injective,\nit suﬃces to show that f preserves formulas of the form\n(z0 > z1) ∨· · · ∨(z0 > zl)\nand formulas of the form\n(z0 > z1) ∨· · · ∨(z0 > zl) ∨(z0 = z1 = · · · = zl) .\nPreservation of formulas of the latter type reduces to the former type, since f preserves\n≤and is injective binary. Now suppose that ¯a = (a0, a1, . . . , al) and ¯b = (b0, b1, . . . , bl)\nare two tuples that satisfy z1 < z0 ∨· · · ∨zl < z0. Assume that a0 ≤b0. Let i be\nsuch that ai = min(a1, . . . , al). Then ai < a0, and we get that f(a0, b0) ≥f(a0, a0) >\nf(ai, bi) by the properties of f. Therefore, min(f(a1, b1), . . . , f(al, bl)) < f(a0, b0).\nWe can argue analogously in the case that a0 ≥b0.\n□\n10.4.5. Weak near-unanimity modulo endomorphisms. For a uniform pre-\nsentation of the classiﬁcation result in Section 10.6, we need yet another description\nof the clone generated by ll.\nWe write lex(x1, . . . , xn) as a shortcut for lex(x1, lex(x2, . . . lex(xn−1, xn) . . . )).\nProposition 10.4.10. There are a, b, c ∈End(Q; <) such that the ternary func-\ntion f : Q3 →Q deﬁned by\nf(x, y, z) = lex(min(x, y, z), max(min(x, y), min(x, z), min(y, z)), x, y, z)\nsatisﬁes for all x, y ∈Q\na(f(x, x, y)) = b(f(x, y, x)) = c(f(y, x, x)) .\nThat is, f is a weak near unanimity modulo endomorphisms of (Q; <).\nProof. By Lemma 5.6.7, it suﬃces to show that for every ﬁnite S ⊂Q there are\nα, β ∈Aut(Q; <) such that for all x, y ∈S\nf(y, x, x) = α1f(x, y, x) = α2f(x, x, y) .\nBy the properties of f we have that f(y, x, x) ≤f(y′, x′, x′) if and only if one of the\nfollowing holds:\n• min(x, y) < min(x′, y′);\n• min(x, y) = min(x′, y′) and x < x′;\n• min(x, y) = min(x′, y′), x = x′, and y < y′;\n• x = x′ and y = y′.\nNote that this is the case if and only if f(x, y, x) < f(x′, y′, x′), and if and only if\nf(x, x, y) < f(x′, x′, y′). Hence, the existence of α1 and α2 follows from the homo-\ngeneity of (Q; <).\n□\nNote that the function f deﬁned in Proposition 10.4.10 is injective and preserves\n≤.\nTheorem 10.4.11. Let R ⊆Qn be ﬁrst-order deﬁnable over (Q; <). Then the\nfollowing are equivalent.\n(1) R is preserved by the operation f as deﬁned in Proposition 10.4.10 (a weak\nnear unanimity modulo endomorphisms).\n(2) R is preserved by ll.\n(3) R has an ll-Horn deﬁnition.\n\n10.4. LEX-CLOSED CONSTRAINTS\n221\nProof. The implication from (1) to (2) follows from the observation that (x, y) 7→\nf(x, x, y) interpolates ll. The implication from (2) to (3) is Lemma 10.4.7. For the\nimplication from (3) to (1), it suﬃces to verify that f preserves all ll-Horn formulas.\nSince f is injective, it suﬃces to show that f preserves formulas φ of the form\n(z1 < z0) ∨· · · ∨(zl < z0)\nand of the form\n(z1 < z0) ∨· · · ∨(zl < z0) ∨(z0 = z1 = · · · = zl) .\nSuppose that s1, s2, s3 are assignments that satisfy φ; we have to show that the\nassignment s deﬁned by s(x) := f(s1(x), s2(x), s3(x)) satisﬁes φ. Let j ∈{1, 2, 3} be\nsuch that sj(z0) = min(s1(z0), s2(z0), s3(z0)).\nSuppose ﬁrst that sj satisﬁes (z1 < z0 ∨· · · ∨zl < z0).\nLet i be such that\nsj(zi) = min(sj(z1), . . . , sj(zl)). Then sj(zi) < sj(z0) by assumption, and hence\nmin(s1(zi), s2(zi), s3(zi)) < min(s1(z0), s2(z0), s3(z0)) .\nTherefore, f(s1(zi), s2(zi), s3(zi)) < f(s1(z0), s2(z0), s3(z0)) by the properties of f,\nand s satisﬁes (z1 < z0 ∨· · · ∨zl < z0).\nOtherwise, sj must satisfy z0 = z1 = · · · = zl. Let a, b be such that a < b and\n{a, b} = {1, 2, 3} \\ {j}. We next consider the case that there exists c ∈{a, b} and\np ∈{1, . . . , l} such that sj(z0) > sc(zp). Let d ∈{a, b} \\ {c}. Note that\nmin(sc(zp), sd(zp)) ≤sc(zp) < sj(zp) = sj(z0) = min(sc(z0), sd(z0))\nmin(sj(zp), sc(zp)) = sc(zp) < sj(zp) = sj(z0) = min(sc(z0), sj(z0))\nmin(sj(zp), sc(zp)) = sc(zp) < sj(zp) = sj(z0) = min(sc(z0), sj(z0))\nand hence\nmax(min(sc(zp), sd(zp)), min(sj(zp), sc(zp)), min(sj(zp), sd(zi)))\n< max(min(sc(z0), sd(z0)), min(sj(z0), sc(z0)), min(sj(z0), sd(zi))) .\nThus, by the deﬁnition of f, we have s(zp) < s(z0) and s satisﬁes φ.\nOtherwise, sj(z0) ≤min(sa(z1), . . . , sa(zl)) and sj(z0) ≤min(sb(z1), . . . , sb(zl)).\nFor all i ∈{0, 1, . . . , l} we have sj(zi) = sj(z0) and hence\nmax(min(sa(zi), sb(zi)), min(sj(zi), sa(zi)), min(sj(zi), sb(zi)))\n= min(sa(zi), sb(zi)) ≥sj(zi) .\nThe deﬁnition of f then implies that f(s1(zi), s2(zi), s3(zi)) < f(s1(z0), s2(z0), s3(z0))\nif and only if sa(zi) < sa(z0). If there exists an i ∈{1, . . . , l} such that sk(zi) < sk(z0),\nwe therefore have s(zi) < s(z0) and s satisﬁes (z1 < z0) ∨· · · ∨(zl < z0). Otherwise,\nwe must have that\nsa(z0) = sa(z1) = · · · = sa(zl)\nIf also sb(z0) = sb(z1) = · · · = sb(zl) then s satisﬁes z0 = z1 = · · · = zl, too. So\nsuppose that there exists a p ∈{1, . . . , l} such that sb(zp) < sb(z0). Since sj(zp) =\nsj(z0) and sa(zp) = sa(z0) we then have s(zp) < s(z0) since s is injective and preserves\n≤. Hence, s satisﬁes φ also in this case.\n□\n10.4.6. An Algorithm for ll-closed Constraints. In this section we present\nan algorithm for ll-closed constraints. One of the underlying ideas of the algorithm is\nto use a subroutine that tries to ﬁnd a solution where every variable has a diﬀerent\nvalue. If this is impossible, the subroutine must return a set of at least two variables\nthat denote the same value in all solutions – since the constraints are preserved by a\nbinary injective operation, such a set must exist (Proposition 6.1.5).\n\n222\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nThe i-th entry in a k-tuple t is called minimal if t[i] ≤t[j] for every j ∈[k]. It is\ncalled strictly minimal if t[i] < t[j] for every j ∈[k] \\ {i}.\nDefinition 10.4.12. Let R be a k-ary temporal relation. A set S ⊆[k] is called\na min-set for the i-th entry in R if there exists a tuple t ∈R such that the i-th entry\nis minimal in t, and for all j ∈[k] it holds that j ∈S if and only if t[i] = t[j]. We\nsay that t is a witness for this min-set.\nLet R be a k-ary relation that is preserved by lex (recall that ll-closed constraints\nare preserved by lex as well), and suppose that the i-th entry has the min-sets\nS1, . . . , Sl, for l ≥1, with the corresponding witnesses t1, . . . , tl. Consider the tu-\nple t := lex(t1, lex(t2, . . . lex(tl−1, tl))). Since the entry i is minimal in every tuple\nt1, . . . , tl, and since lex preserves both < and ≤, it is also minimal in t. Because lex\nis injective, we have that t[i] = t[j] if and only if these two entries are equal in each\ntuple t1, . . . , tl. Hence, the min-set for the i-th entry in R witnessed by the tuple t is\na subset of every other min-set S1, . . . , Sl. We then call this set the minimal min-set\nfor the i-th entry in R.\nLemma 10.4.13. Let R be a k-ary relation preserved by lex, and let S be the\nminimal min-set for the i-th entry in R. If t ∈R is such that t[j] ≥t[i] for every\nj ∈S, then t[i] = t[j] for every j ∈S.\nProof. Let t′ ∈R be the tuple that witnesses the minimal min-set S. Let t ∈R\nbe such that not all entries in S are equal (in particular, |S| > 1). Consider the tuple\ns := lex(t′, t). By the properties of lex it holds that s[i] < s[j] for every j ∈[k] \\ S.\nFurthermore, s[i] ≤s[j] for j ∈S if and only if t[i] ≤t[j]. Thus, unless s witnesses a\nsmaller min-set for i in R (which would be a contradiction), we have that s[i] > s[j]\nfor some j ∈S.\n□\nTo develop our algorithm, we use a speciﬁc notion of constraint graph of a tem-\nporal CSP instance, deﬁned as follows.\nDefinition 10.4.14. The constraint graph Gφ of a temporal CSP instance φ is\na directed graph (V ; E) deﬁned on the variables V of φ. For each constraint of the\nform R(x1, . . . , xk) from φ we add a directed edge (xi, xj) to E if in every tuple from\nR where the i-th entry is minimal, the j-th entry is minimal as well.\nDefinition 10.4.15. If an instance of a temporal CSP contains a constraint φ\nimposed on y such that φ does not admit a solution where y denotes the minimal\nvalue, the we say that y is blocked (by φ).\nWe can easily determine for each constraint which variables are blocked by this\nconstraint: For a constraint represented by weak linear orders we just check all weak\nlinear orders and build a set of variables that are not minimal in any of them. Thus, by\ninspecting all the constraints it is possible to compute the blocked variables in linear\ntime in the input size. We want to use the constraint graph to identify variables that\nhave to denote the same value in all solutions, and therefore introduce the following\nconcepts.\nDefinition 10.4.16. A strongly connected component K of the constraint graph\nGφ for a temporal CSP instance φ is called a sink component if no edge in Gφ leaves\nK, and no variable in K is blocked. A vertex of G that belongs to a sink component\nof size one is called a sink.\nLemma 10.4.17. Let B be a lex-closed temporal constraint language. Let φ be\nan instance of CSP(B) with variables V , and let K ⊆V be a sink component of the\ngraph Gφ. Then in every solution of φ all variables from K must have equal values.\n\n10.4. LEX-CLOSED CONSTRAINTS\n223\nProof. We assume that φ has a solution s: V →Q, and that K has at least\ntwo vertices; otherwise the statement is trivial.\nDeﬁne M := {x ∈K | s(x) ≤\ns(y) for all y ∈K}. We want to show that M = K. Otherwise, because K is a\nstrongly connected component, there is an edge in Gφ from some vertex u ∈M to\nsome vertex v ∈K \\ M. By the deﬁnition of Gφ, there is a constraint ψ in φ such\nthat whenever u denotes the minimal value of a solution of ψ, then v has to denote\nthe minimal value as well. By permuting arguments, we can assume without loss of\ngenerality that ψ is of the form R(w1, . . . , wk) where w1 = u. Because K is a sink\ncomponent, the variable u cannot be blocked, and hence there is a minimal min-set\nS for the ﬁrst entry in R.\nNote that Gφ contains an edge from u to wi for all i ∈S. Since K is a strongly\nconnected component, all these variables wi are in K. Because s(u) ≤s(y) for all\ny ∈K, there is no variable wi, i ∈S, such that s(wi) < s(u). This contradicts\nLemma 10.4.13, because s(u) ̸= s(v).\n□\nLemma 10.4.17 immediately implies that we can add constraints of the type x = y\nfor all variables x, y from the same sink component K. Equivalently, we can consider\nthe CSP instance where all the variables in K are contracted, i.e., where all variables\nfrom K are replaced by the same variable. When φ = ∃x1, . . . , xn (φ1 ∧· · ·∧φm) is an\ninstance of a CSP(B), and xi ∈V := {x1, . . . , xn}, then we write φ[V \\ {xi}] for the\nformula ∃x1, . . . , xi−1, xi+1, . . . , xn\n\u0000(∃xi.φ1)∧· · ·∧(∃xi.φm)\n\u0001\n. Note that if B contains\nall primitive positive deﬁnable relations whose arity is bounded by the maximal arity\nof the relations in B, then φ[V \\ {xi}] can be viewed as an instance of CSP(B).\nLemma 10.4.18. Let B be an ll-closed temporal constraint language. Let φ be an\ninstance of CSP(B) with variables V , and let x be a sink in Gφ. If φ[V \\ {x}] has an\ninjective solution, then φ has an injective solution as well.\nProof. Let s: V →Q be an injective solution to φ[V \\ {x}]. We claim that any\nextension r of s to x such that r(x) < s(y) for all y ∈V \\ {x} is injective and satisﬁes\nφ. If x appears in no constraint in φ, the statement is trivial. Consider a constraint\nψ = R(x1, . . . , xk) from φ that is imposed on x, and let S ⊆[k] be such that i ∈S if\nand only if x = xi. By the deﬁnition of φ[V \\ {x}], the mapping s has an extension\ns′ that is also deﬁned on x such that (s′(x1), . . . , s′(xk)) ∈R. Because x is a sink,\nthere is tuple t ∈R such that S is the minimal min-set for the i-th entry of R for\neach i ∈S. Let t′ be the tuple (s′(x1), . . . , s′(xk)), and let α ∈Aut((Q; <)) be such\nthat αs′(x) = 0. Then r := ll(αt′, t) ∈R. Note that for i, j ∈[k] \\ S, we have that\nr[i] ≤r[j] if and only if r(xi) ≤r(xj). Hence, r satisﬁes all constraints from φ, which\nis what we had to show.\n□\nOur algorithm for ll-closed constraints can be found in Figure 10.7; we are now\nready to prove its correctness.\nTheorem 10.4.19. The procedure Solve(φ) in Algorithm 10.7 decides whether a\ngiven set of ll-closed constraints φ has a solution. There is an implementation of the\nalgorithm that runs in time O(nm), where n is the number of variables of φ and m\nis the size of the input.\nProof. The correctness of the procedure Spec immediately implies the correct-\nness of the procedure Solve. In the procedure Spec, after iterated deletion of sinks in\nGφ, we have to distinguish three cases.\nFirst, consider the case V = X.\nIn this case it follows by a straightforward\ninduction from Lemma 10.4.18 that φ has an injective solution. Otherwise, consider\nthe case that Gφ contains a sink component S with |S| ≥2. We claim that for all\n\n224\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nSpec(φ)\n// Input: An instance φ of CSP(B) with variables V .\n// Output: If algorithm returns false then φ has no solution.\n// If φ has an injective solution, then algorithm returns true.\n// Otherwise return S ⊆V , |S| ≥2, such that\n// for all x, y ∈S we have x = y in all solutions to φ.\nSet X := ∅\nWhile Gφ contains a sink s\nX := X ∪{s}\nIf X = V then return true\nelse φ := φ[V \\ X]\nIf Gφ has sink component S return S\nelse return false\nend if\nFigure 10.6. A polynomial-time algorithm for CSP(B) when B is\nll-closed: the sub-procedure Spec.\nSolve(Φ)\n// Input: An instance φ.\n// Output: accept if φ is true, reject otherwise.\nS := Spec(φ)\nIf S = false then reject\nelse if S = true then accept\nelse\nLet φ′ be contraction of S in φ.\nReturn Solve(φ′).\nend if\nFigure 10.7. A polynomial-time algorithm for CSP(B) when B is\nll-closed: the main procedure.\nvariables x, y ∈S we have x = y in all solutions to φ. Lemma 10.4.17 applied to\nφ[V \\ X] implies that all variables in the same sink component must have the same\nvalue in every solution, and hence the output is correct in this case as well.\nIn the third case we have X ̸= V but Gφ does not contain a sink component.\nNote that in every solution to φ some variable must take the minimal value. However,\nsince each strongly connected component without outgoing edges contains a blocked\nvertex, there is no variable that can denote the minimal element, and hence φ has no\nsolution. Because φ is at all times of the execution of the algorithm implied by the\noriginal input constraints, the algorithm correctly rejects.\nSince in each recursive call of Solve the instance in the argument has at least\none variable less, Solve is executed at most n times. It is not diﬃcult to implement\nthe algorithm such that the total running time is cubic in the input size. However,\nit is possible to implicitly represent the constraint graph and to implement all sub-\nprocedures such that the total running time is in O(nm); for the details, we refer\nto [42].\n□\n10.5. Shuﬄe-closed Constraints\nAn important subclass of temporal constraint languages are shuﬄe-closed con-\nstraint languages.\nAs we will see, there are NP-complete shuﬄe-closed constraint\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n225\nx\ny\nx\ny\nFigure 10.8. A visualization of pp (left) and dual-pp (right).\nlanguages. However, in this section we present three additional restrictions for shuﬄe-\nclosed constraint languages that imply that the corresponding CSPs can be solved in\npolynomial time.\n10.5.1. Shuﬄe closure. We deﬁne shuﬄe closure, and show how shuﬄe closure\ncan also be described by a certain binary operation on Q.\nDefinition 10.5.1. A k-ary relation R is called shuﬄe-closed iﬀfor all tuples\nt1, t2 ∈R and all indices l ∈[k] there is a tuple t3 ∈R such that for all i, j ∈[k] we\nhave t3[i] ≤t3[j] iﬀ\n• t1[i] ≤t1[l] and t1[i] ≤t1[j], or\n• t1[l] < t1[i], t1[l] < t1[j], and t2[i] ≤t2[j].\nLet pp be an arbitrary binary operation on Q such that pp(a, b) ≤pp(a′, b′) iﬀ\none of the following cases applies:\n• a ≤0 and a ≤a′\n• 0 < a, 0 < a′, and b ≤b′.\nClearly, such an operation exists. For an illustration, see the left diagram in Fig-\nure 10.8. In diagrams for binary operations f as in Figure 10.8, we draw a directed\nedge from (a, b) to (a′, b′) if f(a, b) < f(a′, b′). Unoriented lines in rows and columns\nof the picture for an operation f relate pairs of values that get the same value under\nf. The right diagram of Figure 10.8 is an illustration of the dual-pp operation. The\nname of the operation pp is derived from the word ‘projection-projection’, since the\noperation behaves as a projection to the ﬁrst argument for negative ﬁrst argument,\nand a projection to the second argument for positive ﬁrst argument.\nProposition 10.5.2. A temporal relation is shuﬄe-closed if and only if it is\npreserved by pp.\nProof. Let R be a shuﬄe-closed relation, and let t1 and t2 be tuples from R.\nWe want to show that t3 = pp(t1, t2) ∈R. If t1 only contains positive values, then\nthere clearly exists an α ∈Aut((Q; <)) such that t3 = αt2, and since R is preserved\nby the automorphisms of (Q; <), we are done. Otherwise, let l ∈[k] be an index such\nthat t1[l] is the largest entry in t1 that is not positive. Because R is shuﬄe-closed,\nwe know that there exists a tuple t′\n3 ∈R such that t′\n3[i] ≤t′\n3[j] iﬀ(t1[i] ≤t1[l] and\nt1[i] ≤t1[j]) or (t1[l] < t1[i], t1[l] < t1[j], and t2[i] ≤t2[j]) for all i, j ∈[k]. By\nthe deﬁnition of pp, and the choice of l, the tuple t3 satisﬁes the same property, and\ntherefore there exists β ∈Aut((Q; <)) such that t3 = βt′\n3, and hence t3 ∈R.\nFor the opposite direction, we assume that R is preserved by pp, and have to show\nshuﬄe closure of R. Let t1, t2 be tuples in R, and let l ∈[k]. Choose γ ∈Aut((Q; <))\nsuch that γ maps t1[l] to 0. Then t3 = pp(γt1, t2) is a tuple that satisﬁes the conditions\nspeciﬁed in the deﬁnition of shuﬄe-closure.\n□\n\n226\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nDue to Proposition 10.5.2, we use the phrase ‘B is shuﬄe-closed’ interchangeably\nwith ‘B is preserved by pp’ . The following lemma states an important property of\nshuﬄe-closed languages that will be used several times in the next subsections.\nLemma 10.5.3. Let t1, . . . , tl be tuples from a k-ary shuﬄe-closed relation R, and\nlet M1, . . . , Ml ⊂[k] be disjoint sets of indices such that Sl\ni=1 Mi = [k] and such that\nfor all i, j ∈[l] with i < j and for all i′ ∈Mi, j′ ∈Mj it holds that ti[i′] < ti[j′].\nThen there is a tuple t ∈R such that\n• t[i′] < t[j′] for all i, j ∈[l] with i < j and for all i′ ∈Mi, j′ ∈Mj;\n• t[i′] ≤t[i′′] iﬀti[i′] ≤ti[i′′] for all i ∈[l] and all i′, i′′ ∈Mi.\nProof. Let β1, . . . , βl−1 ∈Aut((Q; <)) be such that βi maps max{ti[i′]|i′ ∈Mi}\nto 0. We set\nt := pp(β1t1, pp(β2t2, . . . , pp(βl−1tl−1, tl) . . . )) .\nThe tuple t clearly belongs to R.\nWe prove by induction on l that t satisﬁes the other conditions of the lemma.\nObserve that β1 maps all the entries of t1 at M1 to non-positive values. Thus for\nl = 2, it is easy to check from the properties of pp that for each i ∈M1 and i′ ∈M2\nwe have t[i] < t[i′] as required by the statement of the lemma.\nAlso the second\ncondition is immediate. For l > 2 let t′ be deﬁned by\nt′ := pp(β2t2, pp(β3t3, . . . , pp(βl−1tl−1, tl) . . . )) .\nThen we have t = pp(β1t1, t′). Now we apply the same argument as for l = 2. Because\nthe order on [k]\\M1 is preserved by the application of pp, we know that the conditions\nare satisﬁed for the sets M2, . . . , Ml. The argument also shows that the entries at M1\nare smaller than the entries at [k] \\ M1 and that their order is the same as in t1.\n□\nThe following lemma is a simple criterion for showing that certain operations\ngenerate pp.\nLemma 10.5.4. Let f be a binary operation preserving < such that for some\nα, β ∈Aut((Q; <)) we have f(x, y) = αx for all x ≤−1, 0 < y < 1, and f(x, y) = βy\nfor all x > 1, 0 < y < 1. Then f generates pp.\nProof. It suﬃces to show that every relation preserved by f is also preserved by\npp. Let R be preserved by f, and let t1, t2 be two tuples from R. Let γ1 ∈Aut((Q; <))\nbe such that γx = x + 1 for all positive entries x of t2 and γ1x = x −1 for all other\nentries x of t2. Let γ2 ∈Aut((Q; <)) be such that all entries of γ2t2 are larger than\n0 and smaller than 1. Then f(γ1t1, γ2t2) is in the same orbit as pp(t1, t2), which is\nwhat we wanted to show.\n□\nIt is easy to verify that the relation T3, deﬁned in Section 10.2.3, is shuﬄe-closed.\nProposition 10.2.6 shows that CSP((Q; S)) is NP-complete, and thus the property of\nshuﬄe-closure is not strong enough to guarantee tractability.\n10.5.2. Min-union closure. This section introduces and studies a stronger\nproperty than shuﬄe-closure, namely preservation under the binary operation min\nthat maps two values x and y to the smaller of the two values; see Figure 10.9 for an\nillustration of the operation min. We also present a suﬃcient condition that implies\nthat a temporal constraint language is preserved by min.\nFor constraint languages over a ﬁnite domain, min- and max-closed relations\nwere studied in [125]. An equivalent clausal description of such constraints is known;\nhowever, the equivalence only holds for ﬁnite domains. The tractability of the CSP\nwhere the constraint language has such a clausal description has also been shown for\ninﬁnite domains [77]. But the algorithm presented in [77] cannot be applied to all\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n227\nFigure 10.9. Illustration of the operation min.\nmin-closed constraint languages over an inﬁnite domain; it is already not clear how\nto adapt this approach to deal with the relation {(x, y, z) | x > y ∨x > z}, which is\npreserved by min. In Section 10.5.7 we describe an algorithm that eﬃciently solves\nthe CSP for temporal constraint languages that are preserved by min.\nDefinition 10.5.5. Let t be from Qk. The set of indices\n{i ∈[k] | t[i] ≤t[j] for all j ∈[k]}\nis called the min-set of t, and denoted by M(t).\nDefinition 10.5.6. A relation is called min-union closed if for all tuples t1, t2\nin R there exists a tuple t3 in R such that M(t3) = M(t1) ∪M(t2).\nWe now want to link min-union closure of the relations in the constraint language\nto the existence of certain polymorphisms.\nDefinition 10.5.7. Let f be a binary operation preserving <. We say that f\nprovides min-union closure if f(0, 0) = f(0, x) = f(x, 0) for all integers x > 0.\nThe operation min is an example of an operation providing min-union closure.\nThe following lemma connects Deﬁnition 10.5.6 and Deﬁnition 10.5.7.\nLemma 10.5.8. Let R be a temporal relation preserved by an operation f providing\nmin-union closure. Then R is min-union closed.\nProof. Let t1 and t2 be tuples in R, and let a1 and a2 be the minimal values\namong the entries of t1 and t2, respectively. Then there are α1, α2 ∈Aut((Q; <)) such\nthat α1a1 = α2a2 = 0, and such that α1 and α2 map all other entries of t1 and t2\nto integers. Observe that all entries at M(t1) ∪M(t2) in the tuple t3 = f(α1t1, α2t2)\nhave the same value. Because f preserves <, this value is strictly smaller than the\nvalues at all other entries in t3. Hence, M(t3) = M(t1) ∪M(t2).\n□\nThe following proposition implies that {f, pp} generates min for every operation\nf that provides min-union closure.\nProposition 10.5.9. A temporal relation R is preserved by pp and an operation\nproviding min-union closure if and only if R is preserved by min.\nProof. Clearly, min provides min-union closure. Also observe that min satisﬁes\nthe conditions of Lemma 10.5.4, and hence generates pp.\nFor the opposite direction, suppose that R is k-ary and preserved by pp and an\noperation f providing min-union closure. We show that for any two tuples t1, t2 ∈R\nthe tuple t3 = min(t1, t2) is in R as well. Let l be the number of distinct values in t3\nand v1 < v2 < · · · < vl be these values. We deﬁne Mi, i ∈[l], to be the set of indices\nof t3 with the i-th lowest value, i.e., Mi = {j ∈[k] | t3[j] = vi}.\nNow let α1, . . . , αl ∈Aut((Q; <)) be such that αivi = 0 and such that the en-\ntries of αit1 and αit2 are integers. Using these automorphisms we deﬁne the tuples\n\n228\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\ns1, . . . , sl by si = f(αit1, αit2). Clearly, these tuples belong to R. It also holds that\nsi is constant at Mi because for each j ∈Mi at least one of the entries t1[j], t2[j] is\nequal to vi (the other one can be only greater) which is subsequently mapped to 0\nby αi and f maps all such pairs to the same value. Furthermore, for each j′ ∈Mi′\nfor i < i′ ≤l we have that si[j′] is greater than the value of si at Mi, because\nmin(t1[j′], t2[j′]) = vi′ is greater than vi and f preserves <.\nNow we can apply Lemma 10.5.3 to the obtained tuples s1, . . . , sl and the corre-\nsponding sets M1, . . . , Ml. The lemma gives us some tuple t′\n3 from R which is constant\nat each set Mi, i ≤[l], and such that for each i < j ≤l the value of t′\n3 at Mi is lower\nthan the value of t′\n3 at Mj. Thus t′\n3 has the same order of entries as t3 which shows\nthat t3 is in R as well.\n□\n10.5.3. Min-intersection closure. In this section, we study a diﬀerent restric-\ntion of shuﬄe-closed constraint languages.\nDefinition 10.5.10. A relation R is called min-intersection closed if for all tuples\nt1, t2 in R, if M(t1) ∩M(t2) ̸= ∅, then there exists a tuple t3 in R such that M(t3) =\nM(t1) ∩M(t2).\nDefinition 10.5.11. Let f be a binary operation preserving <. We say that f\nprovides min-intersection closure if f(0, 0) < f(0, x) and f(0, 0) < f(x, 0) for all\nintegers x > 0.\nLemma 10.5.12. Let R be a temporal relation that is preserved by an operation f\nthat provides min-intersection closure. Then R is min-intersection closed.\nProof. Let t1 and t2 be two tuples in R such that M(t1) ∩M(t2) is non-empty,\nthat is, it contains an index i.\nChoose α1, α2 ∈Aut((Q; <)) such that α1t1[i] =\nα2t2[i] = 0, and such that α1 and α2 map all other entries of t1 and t2 to integers.\nConsider the tuple t3 = f(α1t1, α2t2). Because at the entries from M(t1) (from M(t2))\nthe tuple α1t1 (α2t2) equals 0, and because f(0, 0) < f(0, x) and f(0, 0) < f(x, 0)\nfor all positive integers x, it follows that in t3 all entries at M(t1) ∩M(t2) have\na strictly smaller value than all values at the symmetric diﬀerence M(t1) △M(t2).\nBecause f preserves <, it also follows that all entries at M(t1)∩M(t2) have a strictly\nsmaller value than the entries not at M(t1) ∪M(t2). We conclude that M(t3) =\nM(t1) ∩M(t2).\n□\nAn example of an operation that provides min-intersection closure is the operation\nmi, deﬁned by\nmi(x, y) :=\n\n\n\na(x)\nif x < y\nb(x)\nif x = y\nc(y)\nif x > y\nwhere a, b, c are unary operations that preserve < such that\nb(x) < c(x) < a(x) < b(x + ε)\nfor all x ∈Q and all 0 < ε ∈Q (see Figure 10.10). Operations a, b, c with these\nproperties can be constructed as follows.\nLet q1, q2, . . . be an enumeration of Q.\nInductively assume that we have already deﬁned a, b, c on {q1, . . . , qn} such that\nb(qi) < c(qi) < a(qi) < b(qj) whenever qi < qj, for i, j ∈[n].\nClearly, this is\npossible for n = 1. If qn+1 > qi for all i ∈[n], let qj be the maximum of {q1, . . . , qn},\nand deﬁne a(qj) < b(qn+1) < c(qn+1) < a(qn+1). In the case that qn+1 < qi for all\ni ∈[n] we proceed analogously. Otherwise, let i, j ∈[n] such that qi is the largest\npossible and qj is smallest possible such that qi < qn+1 < qj. In this case, deﬁne\na(qi) < b(qn+1) < c(qn+1) < a(qn+1) < b(qj). In this way we deﬁne unary operations\na, b, c on all of Q with the desired properties.\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n229\nFigure 10.10. Illustration of the operation mi.\nIn fact, the operation mi will be of special importance, because the following\nproposition shows that pp together with any operation providing min-intersection\nclosure generates the operation mi.\nProposition 10.5.13. A temporal relation R is preserved by pp and an operation\nf providing min-intersection closure if and only if R is preserved by mi.\nProof. It is clear that mi provides min-intersection closure, and Lemma 10.5.4\nshows that mi generates pp.\nFor the opposite direction, suppose R is k-ary and preserved by pp and an opera-\ntion f providing min-intersection closure. We show that for any two tuples t1, t2 ∈R\nthe tuple t3 = mi(t1, t2) is in R as well. Let a, b, c be the mappings from the deﬁnition\nof the operation mi. Let v1 < · · · < vl be the minimal-length sequence of rational\nnumbers such that for each i′ ∈[k] it holds that t3[i′] ∈S\nj∈[l]{a(vj), b(vj), c(vj)}.\nLet Mi be\n\b\ni′ ∈[k] | t3[i′] ∈{a(vi), b(vi), c(vi)}\n\t\n.\nObserve that for each i′ ∈Mi at least one of t1[i′] and t2[i′] is equal to vi and the\nother value is greater or equal to vi.\nLet M a\ni be the set of those i′ ∈Mi where\nvi = t1[i′] < t2[i′], M b\ni the set of those i′ ∈Mi where vi = t1[i′] = t2[i′], and M c\ni the\nset of those i′ ∈Mi where vi = t2[i′] < t1[i′].\nLet α1, . . . , αl ∈Aut((Q; <)) be such that αi maps vi to 0 and such that the\nentries of αit1 and αit2 are integers. Let β ∈Aut((Q; <)) be such that βf(0, 0) = 0.\nFor each i ∈[l] we deﬁne\nsi := pp(βf(αit1, αit2)), pp(αit2, t1) .\n(27)\nWe verify that for all i ∈[l] the tuple si is constant on each of the sets M a\ni , M b\ni , M c\ni ,\nthe value at M b\ni is lower than the value at M c\ni which is lower than the value at\nM a\ni . Furthermore, for each j ∈[l], j > i, and each i′ ∈Mi, j′ ∈Mj, it holds that\nsi[i′] < si[j′]. Having this, we can apply Lemma 10.5.3 and obtain a tuple from R\nwith the same ordering of entries as in t3, which proves the lemma.\nBecause αi maps vi to 0, the properties of pp imply that the tuple t′\ni = pp(αit2, t1)\nis constant at M b\ni ∪M c\ni and at M a\ni , and the value at the ﬁrst set is smaller than the\nvalue at the second set. Because the values of t2 at M a\ni ∪Sl\nj=i+1 Mj are greater than\nvi and the values of t1 at Sl\nj=i+1 Mj are also greater than vi (recall that for each\nj ∈[l], j′ ∈Mj it holds that min(t1[j′], t2[j′]) = vj) we conclude that the values of t′\ni\nat Sl\nj=i+1 Mj are greater than those at Mi.\nThe application of f in (27) yields a tuple which is constant on M b\ni and its\nvalue there (which is consequently mapped to 0 by β) is smaller than the values at\n\n230\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nM a\ni ∪M c\ni ∪Sl\nj=i+1 Mj. Thus it is easy to verify from the properties of pp that the\nouter application of pp in (27) yields a tuple with the desired properties.\n□\nExample 10.5.14. An interesting example of a relation that is preserved by mi\nbut not by min is the 4-ary relation I deﬁned as follows.\nI(a, b, c, d) ≡(a = b ∧b < c ∧c = d)\n∨(a = b ∧b > c ∧c = d)\n∨(a = b ∧b < c ∧c < d)\n∨(a > b ∧b > c ∧c = d)\nTo see that I is preserved by mi, let t1 and t2 be two tuples from I. We have to\nshow that t3 := mi(t1, t2) ∈I. First note that I(a, b, c, d) is equivalent to\n(a ≥b) ∧(b ̸= c) ∧(c ≤d) ∧(a = b ∨b > c) ∧(b < c ∨c = d) ,\nand that mi preserves ≤and ̸=.\nWe distinguish the following cases.\n(1) t1[2] < t1[3] and t2[2] < t2[3]. Then t1[1] = t1[2] and t2[1] = t2[2], and hence\nt3[1] = t3[2]. Since mi preserves <, we have t3[2] < t3[3]. Since mi preserves\n≤, we have that t3[3] ≤t3[4], and hence t3[1] = t3[2] < t3[3] < t3[4] or\nt3[1] = t3[2] < t3[3] = t3[4], which proves the claim.\n(2) t1[2] < t1[3] and t2[2] > t2[3]. Then t1[1] = t1[2] and t2[3] = t2[4]. We verify\nthat t3 satisﬁes the equivalent characterization of I given above; since mi\npreserves ≤and ̸=, this amounts to proving that t3 satisﬁes the two clauses\n(a = b ∨b > c) ∧(b < c ∧c = d).\nThe ﬁrst sub-case we consider is t3[2] < t3[3]. Then by the assumptions\non t1 and t2 and by deﬁnition of mi we have that t1[2] < t2[2]. Therefore,\nt1[1] = t1[2] < t2[2] ≤t2[1] and thus t3[1] = t3[2] again by the properties\nof mi; we see that both clauses are satisﬁed. The second sub-case is that\nt3[2] > t3[3]. Then by the assumptions on t1 and t2 and by deﬁnition of mi\nwe have that t1[4] ≥t1[3] > t2[3] = t2[4]. Thus t3[3] = t3[4] and again both\nclauses are satisﬁed.\n(3) t1[2] > t1[3] and t2[2] > t2[3]. This is analogous to the ﬁrst case.\n(4) t1[2] > t1[3] and t2[2] < t2[3]. This is analogous to the second case.\nThe relation I is not preserved by min since (0, 0, 1, 2) ∈I and (2, 1, 0, 0) ∈I but\nmin((0, 0, 1, 2), (2, 1, 0, 0)) = (0, 0, 0, 0) /∈I.\n□\nExample 10.5.15. The following ternary temporal relation U is preserved by min\n(we omit the easy proof), but not preserved by mi.\nU(x, y, z) ≡(x = y ∧y < z)\n∨(x = z ∧z < y)\n∨(x = y ∧y = z)\nTo see that U is not preserved by mi, note that the tuple mi((0, 0, 1), (0, 1, 0))\nhas three distinct values and hence is not in U, but (0, 0, 1), (0, 1, 0) ∈U. An al-\ngorithm that solves temporal constraint languages preserved by mi can be found in\nSection 10.5.7.\n□\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n231\n10.5.4. Weak near-unanimity modulo endomorphisms. For a uniform pre-\nsentation of the classiﬁcation result in Section 10.6, we need the following alternative\ndescription of the clone generated by mi. When A, B are two subsets of Q3, and\nf : Q3 →Q, we write A <f B if for all (x, y, z) ∈A and (x′, y′, z′) ∈B we have\nf(x, y, z) < f(x′, y′, z′).\nProposition 10.5.16. There exists a function f : Q3 →Q whose kernel has the\nfollowing classes: for each u ∈Q\n(1) x(u) := {(a, b, c) | u = b = c, a > c};\n(2) y(u) := {(a, b, c) | u = a = c, b > a};\n(3) z(u) := {(a, b, c) | u = a = b, c > a};\n(4) X(u) := {(a, b, c) | u = a, b > a, c > a};\n(5) Y (u) := {(a, b, c) | u = b, a > b, c > b};\n(6) Z(u) := {(a, b, c) | u = c, a > c, b > c};\n(7) D(u) := {(u, u, u)}.\nMoreover, for u < v, we have\nD(u) <f x(u) <f y(u) <f z(u) <f Z(u) <f Y (u) <f X(u) <f D(v) .\nProof. The speciﬁed countable family of subsets of Q3 indeed forms a partition\nof Q3. To see this, note that we distinguish which entries of the tuple are equal to\nthe minimum u of the entries of the tuple. This splits Q3 into seven diﬀerent classes\nfor a given u, all of them pairwise disjoint. See Figure 10.11. Note that <f deﬁnes\na linear order on this countable family, and since (Q; <) embeds all countable linear\norders, the existence of such a function f follows.\n□\nProposition 10.5.17. Let f : Q3 →Q be any function with the properties in\nProposition 10.5.16. Then there are a, b, c ∈End(Q; <) such that for all x, y ∈Q\na(f(y, x, x)) = b(f(x, y, x)) = c(f(x, x, y)) .\nThat is, f is a weak near unanimity modulo endomorphisms of (Q; <).\nProof. By Lemma 5.6.7, it suﬃces to show that for all ﬁnite S ⊂Q there are\nα, β ∈Aut((Q; <)) such that for all x, y ∈S\nf(y, x, x) = α(mi(y, x))\n(28)\nf(x, y, x) = β(mi(y, x))\n(29)\nf(x, x, y) = γ(mi(y, x))\n(30)\nObserve that for all u, v, u′, v′ ∈Q we have f(v, u, u) ≤f(v′, u′, u′) iﬀone of the\nfollowing cases applies:\n• (v, u, u) ∈D(u), (v′, u′, u′) ∈D(u′) ∪x(u′) ∪X(u′), and u ≤u′;\n• (v, u, u) ∈x(u), (v′, u′, u′) ∈x(u′) ∪X(u′), and u ≤u′;\n• (v, u, u) ∈x(u), (v′, u′, u′) ∈D(u′), and u < u′;\n• (v, u, u) ∈X(u), (v′, u′, u′) ∈X(u′), and u ≤u′;\n• (v, u, u) ∈X(u), (v′, u′, u′) ∈D(u′) ∪x(u′), and u < u′.\nNote that this is the case if and only if\n• u = v ≤u′ = v′;\n• u < v, u′ ̸= v′, u ≤u′,\n• u < v, u′ = v′, u < u′,\n• v < u, v′ < u′, u ≤u′,\n• v < u, u′ = v′, u < u′.\n\n232\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nThis in turn is the case if and only if mi(v, u) ≤mi(v′, u′). Then the statement\nfor (28) follows from homogeneity of (Q; <).\nThe proof for (29) and for (30) is\nanalogous.\n□\n1\n2\n3\n4\n5\n6\n7\nFigure 10.11. Illustration of the function f from Proposition 10.5.17.\nThe addition of the third item in the following proposition is a result of Micha l\nWrona [198].\nTheorem 10.5.18. Let R ⊆Qn be ﬁrst-order deﬁnable over (Q; <). Then the\nfollowing are equivalent.\n(1) R is preserved by the operation f as deﬁned in Proposition 10.5.16 (a weak\nnear unanimity modulo endomorphisms of (Q; <) by Proposition 10.5.17).\n(2) R is preserved by mi.\n(3) R can be deﬁned by a conjunction of formulas of the form\n(x1 ̸= z) ∨· · · ∨(xk ̸= z)\n∨(y1 < z) ∨· · · ∨(yl < z)\n(31)\n∨(y0 ≤z) .\nProof. The implication from (1) to (2) follows from the observation that (x, y) 7→\nf(x, x, y) induces the same weak linear order on Q2 as mi and hence generates mi.\nThe implication from (2) to (3) is an unpublished result from [198]. For the implica-\ntion from (3) to (1) we verify that f preserves formulas φ of the form as in (31). Let\nt1, t2, t3 be assignments that satisfy φ. Suppose for contradiction that t0 := f(t1, t2, t3)\ndoes not satisfy φ. In particular, t0(z) = t0(x1) = · · · = t0(xk). By the deﬁnition of\nf, there exists a u ∈Q such that\nD :=\n\b\n(t1(z), t2(z), t3(z)), (t1(x1), t2(x2), t3(x3)), . . . , (t1(xk), t2(xk), t3(xk))\n\t\nis contained in one of x(u), y(u), z(u), X(u), Y (u), Z(u), or D(u). It follows that there\nexists an i ∈{1, 2, 3} such that ti(z) = ti(x1) = · · · = ti(xk) = u. Suppose without\nloss of generality that i = 1. Since t1 satisﬁes φ, there must be a j ∈{0, 1, . . . , l} such\nthat t1(yj) < t1(z) = u or t1(y0) = t1(z) = u.\n• If t1(y0) = u and t2(y0) < t1(y0) = u or t3(y0) < t1(y0) = u then t0(y0) <\nt0(z).\n• If t2(y0) > t1(y0) = u and t3(y0) > t1(y0) = u then t0(y0) = t0(z).\n• If t1(yj) < t1(z) = u, then t0(yj) < t0(z).\nIn each of the three cases, we have reached a contradiction to the assumption that t0\ndoes not satisfy φ.\n□\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n233\nFigure 10.12. Illustration of the operation mx.\n10.5.5. Min-xor closure. We now introduce the last of the three mentioned\nclosure conditions.\nDefinition 10.5.19. A relation is called min-xor closed if for all tuples t1, t2 in\nR where the symmetric diﬀerence M(t1) △M(t2) is nonempty there exists a tuple t3\nin R such that M(t3) = M(t1) △M(t2).\nDefinition 10.5.20. Let f be a binary operation preserving <. We say that f\nprovides min-xor closure if f(0, 0) > f(0, x) = f(y, 0) for all integers x, y > 0.\nFor an example of a binary operation that provides min-xor closure, consider the\nfollowing binary operation, which we denote by mx.\nmx(x, y) :=\n\u001a a(min(x, y))\nif x ̸= y\nb(x)\nif x = y\nwhere a and b are unary operations that preserve < such that a(x) < b(x) < a(x + ε)\nfor all x ∈Q and all 0 < ε ∈Q (see Figure 10.12). Similarly as in the deﬁnition of\nmi, such operations a, b can be easily constructed. It is easy to see that the operation\nmx neither preserves the relation I nor the relation U introduced in Section 10.5.3.\nLemma 10.5.21. Let R be a temporal relation that is preserved by an operation f\nproviding min-xor closure. Then R is min-xor closed.\nProof. Let t1 and t2 be tuples in R, and suppose that the symmetric diﬀerence\nM(t1)△M(t2) of M(t1) and M(t2) is non-empty. Let v1 and v2 be the minimal values\nof the entries of t1 and of t2, respectively. Then there are α1, α2 ∈Aut((Q; <)) such\nthat α1v1 = 0 and α2v2 = 0 and such that α1 and α2 map all other entries of t1 and t2\nto integers. Consider the tuple t3 = f(α1t1, α2t2). Because α1t1 is 0 for all entries at\nM(t1), α2t2 is 0 for all entries at M(t2), and f(0, 0) > f(0, x) = f(y, 0) for all x, y > 0,\nit follows that in t3 all entries at M(t1) ∩M(t2) have a strictly larger value than all\nentries at M(t1) △M(t2), which all have the same value. Because f preserves <, all\nentries of t3 at M(t1)∩M(t2) have a smaller value than all entries not at M(t1)∪M(t2).\nWe conclude that the tuple t3 ∈R satisﬁes M(t3) = M(t1) △M(t2).\n□\nThe following lemma implies that {f, pp} generates mx for any operation f that\nprovides min-xor closure.\nProposition 10.5.22. A temporal relation R is preserved by pp and an operation\nf providing min-xor closure if and only if R is preserved by mx.\nProof. Clearly, mx provides min-xor closure.\nLemma 10.5.4 shows that mx\ngenerates pp.\n\n234\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nFor the opposite direction, suppose that R is k-ary and preserved by pp and an\noperation f providing min-xor closure. We show that for any two tuples t1, t2 ∈R\nthe tuple t3 = mx(t1, t2) is in R as well. Let a, b be the mappings as in the deﬁnition\nof the operation mx. Let v1 < · · · < vl be minimal set of rational numbers such\nthat t3[i] ∈S\nj∈[l]{a(vj), b(vj)} for all i ∈[k], and let Mi be the set of indices {i′ ∈\n[k]|t3[i′] ∈{a(vi), b(vi)}}. Observe that for each i′ ∈Mi at least one of t1[i′] and t2[i′]\nis equal to vi and the other value is greater or equal to vi. Let M a\ni be the set of those\ni′ ∈Mi where t1[i′] ̸= t2[i′] and M b\ni the set of those i′ ∈Mi where vi = t1[i′] = t2[i′].\nLet α1, . . . , αl ∈Aut((Q; <)) be such that αi maps vi to 0 and such that the\nentries of αit1 and αit2 are integers. For each i ∈[l] we deﬁne si := f(αit1, αit2).\nIt is easy to see from the choice of αi and properties of f that for each i ∈[l] the\ntuple si is constant at M a\ni , M b\ni , and that the value at M a\ni is lower than the value at\nM b\ni . Furthermore, because f preserves <, because the values of t1 at Sl\nj=i+1 Mj are\ngreater than vi, and because the values of t2 at Sl\nj=i+1 Mj are greater than vi, we\nsee that for each j ∈[l], j > i and each i′ ∈Mi, j′ ∈Mj, it holds that si[i′] < si[j′].\nHaving this, we can apply Lemma 10.5.3 and obtain a tuple from R with the same\nordering of entries as in t3, which proves the lemma.\n□\nExample 10.5.23. An interesting example of a temporal relation that is preserved\nby mx is the ternary relation X deﬁned as follows.\nX(x, y, z) ≡(x = y ∧y < z)\n∨(x = z ∧z < y)\n∨(y = z ∧y < x)\nThe relation is not preserved by min and by mi: the tuples t1 = (0, 0, 1), t2 =\n(0, 1, 0) are in X, but min(t1, t2) = (0, 0, 0) /∈R, and mi(t1, t2) has three distinct\nentries and hence is not in X as well.\n□\nAn algorithm that solves constraint languages preserved by mx can be found in\nSection 10.5.7.\n10.5.6. Operations generating min, mi, mx. As we have seen in Proposi-\ntion 10.2.6, if the relation T3 has a primitive positive deﬁnition in B, then CSP(B) is\nNP-hard. We show that if a temporal constraint language is shuﬄe-closed and does\nnot admit a primitive positive deﬁnition of T3, then it is preserved by min, mi, or mx.\nIf the relation T3 does not have a primitive positive deﬁnition in B, then Theo-\nrem 5.2.3 implies that B has a polymorphism that does not preserve T3. By Theo-\nrem 10.3.2, it suﬃces to consider operations that preserve <. We start with a sequence\nof auxiliary lemmas.\nLemma 10.5.24. Let f be a binary operation preserving <, and suppose that\nthere is an inﬁnite sequence x1 < x2 < . . . of elements of Q and y1 ∈Q such\nthat f(x1, y1) ≥f(x2, y1) < f(xi, y1) for all i > 2. Then f generates an operation\nproviding min-intersection closure.\nProof. Because f preserves <, we have that for any inﬁnite sequence y1 <\ny2 < . . . it holds that f(x2, yi) > f(x1, y1). Hence, the binary operation deﬁned by\nf(α(x), β(y)) provides min-intersection closure, where α ∈Aut((Q; <)) maps 0, 1, . . .\nto x2, x3, . . . and β ∈Aut((Q; <)) maps 0, 1, 2, . . . to y, y1, y2, . . .\n□\nLemma 10.5.25. Suppose f preserves < and generates a sequence of operations\nf1, f2, . . . such that for each fk it holds that fk(0, 0) < fk(x, 0) and fk(0, 0) < fk(0, x)\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n235\nfor all integers x ∈[k]. Then f generates an operation g providing min-intersection\nclosure.\nProof. A direct consequence of Lemma 8.3.13.\n□\nLemma 10.5.26. Let f be a binary operation preserving < such that there is an\ninﬁnite sequence x1 < x2 < . . . and y1 ∈Q satisfying f(xi, y1) > f(xj, y1) for all\n1 ≤i < j. Then {f, pp} generates an operation providing min-intersection closure.\nProof. By Lemma 10.5.25, it suﬃces to show that there is a sequence of op-\nerations f1, f2, . . . , generated by {f, pp} such that fk(0, 0) < fk(x, 0) and fk(0, 0) <\nfk(0, x) for all k ≥1 and all x ∈[k].\nSo let k ≥0 be a ﬁxed integer, and y1 < y2 < . . . be an arbitrary inﬁnite sequence.\nLet αk be from Aut((Q; <))such that\nα\n\b\nf(x1, yi)\n\f\f 1 ≤i ≤k} ∪{f(xi, y1) | 1 ≤i ≤k\n\t\n⊆{x2, . . . , x2k}\nand β1, β2 ∈Aut((Q; <)) such that β1 maps 0, 1, 2, . . . to x1, x2, x3, . . . and β2 maps\n0, 1, 2, . . . to y1, y2, y3, . . . We deﬁne\nfk(x, y) := f(αkf(β1x, β2y), β2y) ,\nand show that fk has the required properties. It follows from the assumptions on\nf that for all positive integers x we have f(β10, β20) = f(x1, y) > f(β1x, y1) =\nf(β1x, β20), and due to the properties of αk it holds that fk(0, 0) < fk(x, 0) for all\nintegers x ∈[k].\nWe also have for every x ∈[k] that β2x > y1 and αkf(β10, β2x) > x1. Because f\npreserves <, this shows that fk(0, x) = f(αkf(β10, β2x)), β2x) > f(x1, y1). Moreover,\nfk(0, 0) = f(αkf(x1, y1), y1) < f(x1, y1) by the assumptions on f. Hence, fk(0, x) >\nf(x1, y1) > fk(0, 0) for all x ∈[k].\n□\nThe following lemma applies (a special case of) Ramsey’s theorem; more substan-\ntial applications of Ramsey theory can be found in Section 10.6.\nLemma 10.5.27. Let f be a binary operation preserving < such that there is an\ninﬁnite sequence x1 < x2 < . . . and y1 ∈Q satisfying f(x1, y1) > f(xi, y1) = f(xj, y1)\nfor all 1 < i < j. Then {f, pp} generates an operation providing min-intersection or\nmin-xor closure.\nProof. By the inﬁnite pigeon-hole principle there must be an inﬁnite sequence\ny2 < y3 < . . . of elements of Q larger than y1 such that\n(1) f(x2, y1) = f(x1, yi) for all i ≥2, or\n(2) f(x2, y1) > f(x1, yi) for all i ≥2, or\n(3) f(x2, y1) < f(x1, yi) for all i ≥2.\nIn case 1, f generates an operation providing min-xor closure and we are done. In\ncase 2, we apply Ramseys theorem (Theorem 8.1.1) in the special case of m = 2,\nr = 3 as follows.\nLet D be {y1, y2, . . . }.\nFor i < j, deﬁne χ({yi, yj}) = 1 if\nf(x1, yi) = f(x1, yj), χ({yi, yj}) = 2 if f(x1, yi) > f(x1, yj), and χ({yi, yj}) = 3\nif f(x1, yi) < f(x1, yj). Then Theorem 8.1.1 applied to χ shows that there exists an\ninﬁnite subsequence z1 < z2 < . . . of y1 < y2 < . . . such that\n2a. f(x1, zi) = f(x1, zj) for all 1 ≤i < j, or\n2b. f(x1, zi) > f(x1, zj) for all 1 ≤i < j, or\n2c. f(x1, zi) < f(x1, zj) for all 1 ≤i < j.\nIn case 2a, we swap arguments of f and proceed as in case 3. In case 2b, we swap\narguments of f, apply Lemma 10.5.26, and conclude that f generates an operation\nproviding min-intersection closure.\nIn case 2c, note that f(x1, y1) > f(x2, y1) >\n\n236\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nx1\nx2\nx3\nx4\nx5\nx6\ny1\ny2\ny3\ny4\n. . .\n...\nFigure 10.13. Illustration for Case 3 of Lemma 10.5.27.\nf(x1, yi) for all i ≥2, and thus we can apply Lemma 10.5.24 to conclude that f\ngenerates an operation providing min-intersection closure.\nIn case 3, we show that similarly as in Lemma 10.5.26 there is a sequence of\noperations f1, f2, . . . generated by {f, pp} such that for each fk it holds that fk(0, 0) <\nfk(x, 0) and fk(0, 0) < fk(0, x) for all integers x ∈[k], and conclude by application of\nLemma 10.5.25. See Figure 10.13 for an illustration.\nLet αk be from Aut((Q; <))such that αkf(x2, y1) = x1 and α{f(x1, yi) | 1 ≤i ≤\nk} ⊆{x2, . . . , xk+1}. Furthermore let β1, β2 ∈Aut((Q; <)) be such that β1 maps\n0, 1, 2, . . . to x1, x2, x3, . . . and β2 maps 0, 1, 2, . . . to y1, y2, y3, . . . We deﬁne\nfk(x, y) := f(αkf(β1x, β2y), β2y) .\nThen for all integers x > 0\nfk(0, 0) = f(αkf(x1, y1), y1) = f(x2, y1) ,\nand\nfk(x, 0) = f(αkf(β1x, y1), y1) = f(x1, y1) .\nHence fk(0, 0) < fk(x, 0) for all integers x > 0.\nFinally, since β2x > y1 and\nαkf(x1, β2x) > x1 for all integers x > 0, we have that fk(0, x) > f(x1, y1) >\nf(x2, y1) = fk(0, 0).\n□\nThe previous two lemmas are combined in the following result.\nLemma 10.5.28. Let f be a binary operation that preserves < and violates the\nrelation ≤. Then {f, pp} generates an operation providing min-intersection or min-\nxor closure.\nProof. As f violates ≤, we can without loss of generality assume that there is\ny ∈Q and x1, x2 ∈Q, x1 < x2, such that f(x1, y) > f(x2, y).\nWe claim that there are only three possibilities:\na) There is an inﬁnite sequence x3 < x4 < . . . such that x2 < x3 and f(xi, y) >\nf(x2, y) for all i > 2.\nb) There is an inﬁnite sequence x3 < x4 < . . . such that x2 < x3 and f(xi, y) >\nf(xj, y) for all 2 ≤i < j.\nc) There is an inﬁnite sequence x3 < x4 < . . . such that x2 < x3 and f(xi, y) =\nf(x2, y) for all i > 2.\nTo show this claim, observe that by the inﬁnite pigeon-hole principle there is an\ninﬁnite sequence x3 < x4 < . . . with x2 < x3 such that f(xi, y) > f(x2, y) for all\ni > 2, f(x′\ni, y) = f(x2, y) for all i > 2, or f(xi, y) < f(x2, y) for all i > 2. In the ﬁrst\nand the second case the claim holds. In the third case, we repeat the argument with\nx2 < x3 instead of x1 < x2. Again, we distinguish three cases, and as before in two of\nthem we are immediately done. In the third case, we repeat again. If we repeat this\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n237\nfor inﬁnitely many times we obtain a sequence x3 = x′\n3 < x′\n4 < . . . such that x2 < x3\nand f(x′\ni, y) > f(x′\nj, y) for all 2 ≤i < j.\nIn a) the conditions of Lemma 10.5.24 are satisﬁed and we conclude that {f, pp}\ngenerates an operation providing min-intersection closure. In b) Lemma 10.5.26 shows\nthat {f, pp} generates an operation providing min-intersection closure. In c) we ap-\nply Lemma 10.5.27 and conclude that {f, pp} generates an operation providing min-\nintersection or min-xor closure.\n□\nThe following is the main result of this subsection. Recall that the relation T3\nwas deﬁned in Deﬁnition 10.2.5 to be\n{(x, y, z) ∈Q3 | (x = y < z) ∨(x = z < y) } .\nLemma 10.5.29. Let f be a binary operation that preserves < and violates the\nrelation T3. Then {f, pp} generates min, mi, or mx.\nProof. By Proposition 10.5.9, 10.5.13, and 10.5.22, it suﬃces to show that\n{f, pp} generates an operation providing min-intersection, min-union, or min-xor clo-\nsure. If f violates ≤, then we are immediately done by Lemma 10.5.28. So we further\nassume that f preserves ≤.\nBecause f preserves < and violates T3, we can assume without loss of generality\n(possibly after swapping arguments) that there are x1, x2, y1, y2 ∈Q such that x1 <\nx2, y1 < y2 and t := (f(x1, y1), f(x2, y1), f(x1, y2)) ̸∈T3. Because f preserves ≤we\nhave that f(x1, y1) ≤f(x2, y1) and f(x1, y1) ≤f(x1, y2). Since t ̸∈T3, there are only\ntwo possibilities:\n(1) t[1] < t[2] and t[1] < t[3]. In this case, choose inﬁnite sequences x3 < x4 <\n. . . and y3 < y4 < . . . such that x2 < x3, y2 < y3. Because f preserves ≤, we\nhave for all i > 1 that f(x2, y1) ≤f(xi, y1) and f(x1, y2) ≤f(x1, yi). Since\nt[1] = f(x1, y1) < t[2] = f(x2, y1) we have that f(x1, y1) < f(xi, y1) for all\ni > 1, and since t[1] = f(x1, y1) < t[3] = f(x1, y2) we have that f(x1, y1) <\nf(x1, yi) for all i > 1. Hence, f provides min-intersection closure.\n(2) t[1] = t[2] = t[3]. In this case we can choose inﬁnite sequences x′\n2 < x′\n3 < . . .\nand y′\n2 < y′\n3 < . . . such that x1 < x′\n2, y1 < y′\n2, and for all i > 1, x′\ni < x2 and\ny′\ni < y2. As f preserves ≤, we see that f(x′\ni, y1) = f(x1, y1) = f(x1, y′\ni) for\nall i > 1 and thus f provides min-union closure.\n□\n10.5.7. Algorithms for shuﬄe-closed languages. In this section we present\nthree algorithms, for the languages preserved by mi, by min, and by mx, respectively.\nAll three algorithms follow a common strategy. They are searching for a subset of\nthe variables that can have the minimal value in a solution. If they have found such\na a subset, S, the algorithms add equalities and inequalities that are implied by all\nconstraints under the assumption that the variables in S denote the minimal value\nin all solutions. Next, the algorithms recursively solve the instance consisting of the\nprojections of all constraints to the variables that do not denote the minimal value\nin all solutions. We later show that for languages preserved by pp it is true that\nif the instance has a solution, it also has a solution that satisﬁes all the additional\nconstraints.\nThroughout this section we assume that B is a structure with a ﬁrst-order deﬁni-\ntion in (Q; <) and a ﬁnite relational signature. For the formulation of the algorithms\nand their correctness proofs it will be convenient to work with an expanded con-\nstraint language, that contains the binary relation = for the equality relation. We\nalso add to the temporal constraint language B several other temporal relations that\nare primitive positive deﬁnable in B.\n\n238\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nDefinition 10.5.30. Let R be an n-ary temporal relation and L = {p1, . . . , pk} ⊆\n[n] where p1 < · · · < pk. Let {q1, . . . , ql} be [n] \\ L. Then the ordered projection of R\nto L is the k-ary relation R′ with the primitive positive deﬁnition\nR′(xp1, . . . , xpk) ≡∃xq1, . . . , xql.R(x1, . . . , xn) ∧\n^\ni∈[n]\\L, j∈L\nxi < xj .\nNote that if B is a ﬁnite temporal constraint language, then there are only ﬁnitely\nmany projections and ordered projections of relations in B. In case that there is a\nprimitive positive deﬁnition of < in B, ordered projections are primitive positive\ndeﬁnable. By Lemma 1.2.6, we can assume in this case that B contains all relations\nthat can be deﬁned by ordered projections from relations in B.\nTo formally introduce our algorithms, we also need the concept of an ordered\nprojection of instances of the CSP.\nDefinition 10.5.31. Let B be a temporal constraint language that contains all or-\ndered projections of relations from B. Let Φ be an instance of CSP(B) and X ⊆V (Φ).\nThen the ordered projection of Φ to X is the instance of CSP(B) that contains for\neach constraint R(x1, . . . , xn) in Φ, with not necessarily distinct variables x1, . . . , xn,\nthe constraint R′(xk1, . . . , xkl) where k1 < · · · < kl are such that {k1, ..., kl} = {k ∈\n[n] | xk ∈X}, and R′ is the ordered projection of R to {k1, . . . , kl}.\nLet Φ be an instance of a temporal CSP.\nDefinition 10.5.32. If ψ = R(x1, . . . , xk) is a constraint from Φ, then a subset\nX of the variables of ψ is called a min-set (of ψ) if there exists a k-tuple t satisfying\nψ such that x ∈X iﬀthe value for x in t is the minimum of all entries of t. A\nset of variables S ⊂V (Φ) is called free iﬀit is non-empty and for all constraints\nR(x1, . . . , xk) in Φ the set S ∩{x1, . . . , xk} is either empty or a min-set of R.\nWe will show how to use the concept of freeness to solve instances of CSP(B) for\nshuﬄe closed temporal constraint languages.\nLemma 10.5.33. Let Φ be an instance of CSP(B) for some shuﬄe closed B, and\nlet S be a free set of variables of Φ. Then Φ has a solution if and only if the ordered\nprojection Φ′ of Φ to V (Φ) \\ S has a solution.\nProof. First suppose Φ′ has a solution s′. Let ψ = R(x1, . . . , xm) be a constraint\nof Φ such that V (ψ) ∩S = {xp1, . . . , xpk} ̸= ∅. Let {xq1, . . . , xql} = V (ψ) \\ S for\nq1 < · · · < ql. By the deﬁnition of an ordered projection, there is a tuple t1 ∈R\nsuch that s′(xi) = t1[i] for all i ∈{q1, . . . , ql}. Since V (ψ) ∩S is a min-set of R,\nthere is a tuple t2 ∈R such that M(t2) = {p1, . . . , pk}. Let α ∈Aut((Q; <)) be such\nthat α maps the minimal value of t2 to 0. Because R is preserved by pp, the tuple\nt3 := pp(α(t2), t1) is in R. It is easy to verify that M(t3) = {p1, . . . , pk} and that\nthere is β ∈Aut((Q; <)) such that βt3[i] = s′(xi) for i ∈{q1, . . . , ql}. Because we can\nﬁnd such a tuple for all the constraints ψ in Φ where V (ψ) ∩S ̸= ∅, we conclude that\na solution s′ of Φ′ can be extended to a solution s of Φ by setting all the variables\nin S to some value that is smaller than the smallest value in {s′(x) | x ∈V (Φ′)}.\nClearly, all the constraints ψ in Φ with V (ψ) ∩S = ∅or V (ψ) ⊂S are satisﬁed by s\nas well.\nNow suppose that Φ has a solution s.\nLet x1, . . . , xn be the variables of Φ,\nand let {xr1, . . . , xr|S|} be S.\nLet s′ be a mapping from V (Φ) to Q such that\nM((s′(x1), . . . , s′(xn))) = {r1, . . . , r|S|}, and s′(x) = s(x) for x ∈V (Φ) \\ S.\nWe\nclaim that s′ is a solution for Φ′. Let ψ = R(y1, . . . , ym) be a constraint of Φ such\nthat V (ψ) ∩S ̸= ∅. Clearly, t1 := (s(y1), . . . , s(ym)) is in R since s is a solution\nof Φ. Let {yp1, . . . , ypl} be S ∩{y1, . . . , ym}. Since {yp1, . . . , ypl} is a min-set of R,\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n239\nSolve(Φ)\n// Input: An instance Φ of CSP(B)\n// for a shuﬄe closed temporal language B\n// Output: A solution s to Φ, or reject if there is no solution.\ni := 0\nwhile V (Φ) ̸= ∅do begin\nS := FindFreeSet(Φ)\nif S = false then reject\nfor each x ∈S do s(x) := i\ni := i + 1\nΦ := ordered projection of Φ to V (Φ) \\ S\nend\nreturn s\nFigure 10.14. An algorithm that eﬃciently solves instances of a\nshuﬄe closed constraint language if free sets can be computed eﬃ-\nciently.\nthere is a tuple t2 ∈R such that M(t2) = {p1, . . . , pl}. Let α ∈Aut((Q; <)) be such\nthat α maps the minimal value of t2 to 0. Because R is preserved by pp, the tuple\nt3 := pp(αt2, t1) is in R. It is easy to verify that M(t3) = {p1, . . . , pl}, and that there\nis an automorphism β such that βt3[i] = s(yi) for i ∈[m] \\ {p1, . . . , pl}. Clearly, the\nrestriction of s′ to V (Φ)\\S is a solution to the ordered projection Φ′ of Φ to V (Φ)\\S\nsince s′ also satisﬁes all the inequalities imposed by the ordered projection. Therefore\nΦ′ is satisﬁed by s′.\n□\nThe above lemma asserts that if we are able to identify a free set for instances\nof CSP(B) for a shuﬄe-closed temporal language B in polynomial time, then we\nalso have a polynomial time algorithm that solves CSP(B). The running time of the\nalgorithm is O(n · (m + t(n, m))), where n = |V |, m is the number of constraints in\nΦ, and t(n, m) is the running time of the procedure that computes the free set of an\ninstance with n variables and m constraints.\nAn algorithm for languages preserved by min. Now, we concentrate on the\nproblem to ﬁnd a free set of Φ if B is preserved by the operation min.\nLet ψ = R(x1, . . . , xk) be a constraint where R is from B and let L be a subset of\n{x1, . . . , xk}. Let A1, . . . , Al be all min-sets of ψ that are contained in L. When l ≥1,\ni.e., when such min-sets exist, there is a unique set Aj, j ∈[l], with the property that\nAi ⊆Aj for all i ∈[l], because R is preserved by min, and thus min-union closed by\nLemma 10.5.8. We call this min-set the maximal min-set of ψ contained in L. Note\nthat for some L it could be that l = 0, i.e., L does not contain min-sets of R.\nFigure 10.15 shows our procedure for ﬁnding a free set for a min-union closed\nconstraint language. It is straightforward to check that the procedure FindFreeSetUC\nhas a running time O(nm), where n is the number of variables and m is the number\nof constraints of Φ.\nLemma 10.5.34. The procedure FindFreeSetUC in Figure 10.15 returns a free set\nof Φ, or rejects. If it rejects, Φ is unsatisﬁable.\nProof. Suppose that the algorithm returns a (non-empty) set S. Then recheck\nmust be set to false. Therefore, for all constraints R(x1, ..., xk) of Φ such that S ∩\n{x1, . . . , xk} ̸= ∅the maximal min-set of ψ contained in S equals S ∩{x1, . . . , xk}.\nWe conclude that S is a free set of Φ.\n\n240\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nFindFreeSetUC(Φ)\n// Input: An instance Φ of CSP(B) with variables V\n// for a temporal constraint language B preserved by min.\n// Output: A free set S ⊆V of Φ, or reject.\n// If the algorithm rejects, Φ is unsatisﬁable\nS := V\nrecheck := true\nwhile recheck do begin\nrecheck := false\nfor all ψ ∈Φ do begin\nif S ∩V (ψ) ̸= ∅then begin\nS := (S \\ V (ψ)) ∪the maximal min-set of ψ contained in S ∩V (ψ)\nif S changed then recheck := true\nend\nend\nend\nif S ̸= ∅then return S\nelse reject\nend\nFigure 10.15. A polynomial time algorithm that computes free sets\nfor constraint languages preserved by min.\nWe now have to argue that in case that Φ is satisﬁable, the algorithm does not\nreject (i.e., it ﬁnds a free set). If Φ has a solution, there is some set S′ of variables that\nhave the minimal value in this solution. At the beginning of the procedure, S is set\nto V and therefore S′ ⊆S. We show that S′ ⊆S during the entire execution of the\nprocedure. Let ψ = R(x1, . . . , xk) be a constraint from Φ. Because S′ ∩{x1, . . . , xk}\nis a min-set of ψ that is contained in S, the maximal min-set of ψ added to S \\\n{x1, . . . , xk} certainly contains S′ ∩{x1, . . . , xk}. Therefore, after the modiﬁcation to\nS it still holds that S ⊇S′. When the procedure terminates, it returns the set S,\nbecause ∅̸= S′ ⊆S.\n□\nTheorem 10.5.35. If B is preserved by min there is an algorithm solving CSP(B)\nin time O(n2m).\nProof. We use the procedure FindFreeSetUC in Figure 10.15 for the subroutine\nFindFreeSet in Figure 10.14. Then Lemma 10.5.33 and Lemma 10.5.34 imply the\ncorrectness of the resulting algorithm.\n□\nAn algorithm for languages preserved by mi. In this section we describe\nhow to ﬁnd free sets in instances of CSP(B) for languages B that are preserved by\nmi. We deﬁne the notion of a minimal min-set: Let ψ = R(x1, . . . , xk) be a constraint\nfrom an instance Φ of CSP(B), and let L ⊆{x1, . . . , xk}. Let A1, . . . , Al be all min-\nsets of ψ that contain L. Because R is preserved by mi, and thus is min-intersection\nclosed by Lemma 10.5.12, there is a min-set Aj of ψ that is a subset of every min-set\ncontaining L. We call Aj the minimal min-set of R containing L.\nThe procedure for ﬁnding a free set for min-intersection closed constraint lan-\nguages is given in Figure 10.16. It is straightforward to verify that the above algo-\nrithm runs in time O(n2m) where n is the number of variables and m is the number\nof constraints in Φ.\nLemma 10.5.36. The procedure FindFreeSetIC in Figure 10.16 returns a free set\nS of Φ, or rejects. If it rejects, Φ is unsatisﬁable.\n\n10.5. SHUFFLE-CLOSED CONSTRAINTS\n241\nFindFreeSetIC(Φ)\n// Input: An instance Φ of CSP(B) where B is preserved by mi\n// Output: A free set S ⊆V (Φ) of Φ, or reject\n// If the algorithm rejects, Φ is unsatisﬁable\nfor all x ∈V (Φ) do begin\nS := {x}\nrecheck := true; correct := true\nwhile recheck ∧correct do begin\nrecheck := false\nfor all constraints ψ of Φ such that (V (ψ) ∩S) ̸= ∅do begin\nif there is no min-set of ψ containing S ∩V (ψ) then correct := false\nelse begin\nS := S ∪the minimal min-set of ψ containing S ∩V (ψ)\nif S changed then recheck := true\nend\nend\nend\nif correct then return S\nend\nreject\nFigure 10.16. A polynomial time algorithm that computes free sets\nfor min-intersection and shuﬄe closed constraint languages.\nProof. Suppose that the algorithm returns a set S. The variable correct must\nthen be equal to true. When the while loop terminates, recheck equals false, and so\nfor all constraints ψ ∈Φ such that V (ψ) ∩S ̸= ∅the set S did not change. This\nimplies that for all these constraints the minimal min-set of ψ containing S ∩V (ψ) is\nequal to S ∩V (ψ). We conclude that S is a free set of Φ.\nWe now have to argue that in case that Φ is satisﬁable, the algorithm does not\nreject. If Φ has a solution, then there is some set S′ of variables that have the minimal\nvalue in this solution. Consider a run of the while loop in the procedure FindFreeIC\nfor some variable x ∈S′. In the beginning, it holds that S = {x} ⊆S′. For each\nconstraint ψ from Φ we have that S′∩V (ψ) is a min-set of ψ if S′∩V (ψ) is non-empty.\nTherefore, the program variable correct cannot be set to false while S ⊆S′. Because\nwe always add only variables of the minimal min-set of ψ containing S ∩V (ψ) to S,\nall these variables are always in S′. Therefore, S remains a subset of S′ all the time,\nand the algorithm does not reject.\n□\nTheorem 10.5.37. If B is preserved by mi there is an algorithm solving CSP(B)\nin time O(n3m).\nProof. We use the procedure FindFreeSetIC in Figure 10.16 for the sub-routine\nFindFreeSet in Figure 10.14. Lemma 10.5.33 and Lemma 10.5.36 imply the correct-\nness of these algorithms.\n□\nAn algorithm for languages preserved by mx. Finally, we consider languages\nB preserved by mx. Let R be a relation from B. For a tuple t ∈R, we deﬁne χmin(t)\nto be a vector from {0, 1}k such that χmin(t)[i] = 1 if and only if t[i] is minimal in\nt. We deﬁne χmin(R) to be {χmin(t) | t ∈R}. Since R is preserved by mx and\nhence min-xor closed by Lemma 10.5.21, the set χmin(R) is closed under addition\nof distinct vectors over GF(2), and hence in particular closed under the Boolean\n\n242\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nminority operation minority(x, y, z) = x ⊕y ⊕z. By Theorem 5.4.3, χmin(R) ∪{0k}\nis exactly the set of solutions of a system of linear equations.\nTheorem 10.5.38. If B is preserved by mx there is an algorithm solving CSP(B)\nin time O(n4).\nProof. To ﬁnd a free set of variables of an instance Φ of CSP(B) (if it exists), we\nﬁrst construct a system S of linear equations over GF(2) with variable set {xv | v ∈V }\nand linear equations as described above for each constraint in Φ. It is well-known that\na solution of S that is distinct from 0n can be computed in cubic time (by Gaussian\nelimination). If there is such a solution, then the set of variables mapped to 1 is a\nfree set of Φ. If the system has no such solution, then there is no free set of variables,\nand there is no solution for Φ. Now the claim follows from Lemma 10.5.33 as in\nTheorem 10.5.35 and Theorem 10.5.37.\n□\n10.6. Classiﬁcation\nThis section combines the previous results to show that every temporal constraint\nlanguage has a polynomial-time constraint satisfaction problem, or is NP-complete.\n10.6.1. Classiﬁcation in the presence of <.\nLemma 10.6.1. Let f be a binary operation violating Betw and preserving <.\nThen there are t1, t2 ∈Betw such that f(t1, t2) has three distinct entries and f(t1, t2) ̸∈\nBetw.\nProof. Since f violates Betw, there are two triples t1, t2 ∈Betw such that\nt := f(t1, t2) ̸∈Betw. Because f preserves <, we can assume without loss of generality\nthat t1[1] < t1[2] < t1[3] and t2[1] > t2[2] > t2[3]. If t has three distinct entries (in\nthis case, we also say that t is injective), we are done. Otherwise we distinguish two\ncases:\n(1) t[1] = t[2] = t[3]: In that case, take a triple s1 such that s1[1] < t1[1],\ns1[2] = t1[2], and s1[3] = t1[3]. We also choose a triple s2 such that t2[2] <\ns2[1] < t2[1], s2[2] = t2[2], and s2[3] = t2[3]. It is straightforward to check\nthat s1[1] < s1[2] < s1[3] and s2[1] > s2[2] > s2[3] and thus both triples\nbelong to Betw. Now, consider s := f(s1, s2). We have that s[2] = t[2],\ns[3] = t[3], and s[1] < t[1] = s[2] = s[3] because f preserves <. Therefore\ns ̸∈Betw. Take s1 instead of t1, s2 instead of t2 and proceed with case 2.\n(2) If exactly two entries in t have the same value, let i, j be their indices and let\nk be the index of the entry with the unique value. We assume that t[k] > t[i]\n(the other case is symmetric). It is straightforward to verify that there is\nan entry in t such that making the value of this entry smaller would make t\ninjective and it would still not be in Betw. We can assume without loss of\ngenerality that i is an index of such an entry. We choose s1 so that s1[i] <\nt1[i], s1[j] = t1[j], s1[k] = t1[k], and s1[1] < s1[2] < s1[3]. We choose s2 such\nthat s2[i] < t2[i], s2[j] = t2[j], s2[k] = t2[k], and s2[1] > s2[2] > s2[3]. Note\nthat s1, s2 ∈Betw. The tuple s := f(s1, s2) satisﬁes s[i] < t[i], s[j] = t[j],\nand s[k] = t[k]. By the choice of i we conclude that s is injective, s ̸∈Betw\nand we are done.\n□\nWe use Ramsey theory via Theorem 8.3.17 to prove the following.\nLemma 10.6.2. Let f be a binary operation that preserves < and violates Betw.\nThen f generates ll, dual-ll, pp, or dual-pp.\n\n10.6. CLASSIFICATION\n243\nG1\nG2\nG3\nS1\nS2\nT1\nT2\nt2[1]\nt2[2]\nt2[3]\nt1[1]\nt1[2]\nt1[3]\nG1\nG2\nG3\nS1\nS2\nT1\nT2\nt2[1]\nt2[2]\nt2[3]\nt1[1]\nt1[2]\nt1[3]\nFigure 10.17. Grids chosen for the application of the product Ram-\nsey theorem. The depicted ordering on the values of f follows from\nthe choice of t1, t2 and because f preserves <.\nProof. If f violates Betw and preserves <, then Lemma 10.6.1 asserts that\nthere are t1, t2 ∈Betw such that t := f(t1, t2) ̸∈Betw and t is injective.\nAs f\npreserves <, we can assume without loss of generality that t1[1] < t1[2] < t1[3] and\nt2[1] > t2[2] > t2[3] (otherwise, we apply the argument to f(y, x)).\nEither the triple t satisﬁes t[1] > t[2] < t[3] or t[1] < t[2] > t[3]. In the ﬁrst case,\nlet S1 := {x ∈Q | t1[1] < x < t1[2]}, S2 := {x ∈Q | t1[3] < x}, T1 := {y ∈Q | t2[3] <\ny < t2[2]}, and T2 := {y ∈Q | t2[1] < y}.\nIn the second case, let S1 := {x ∈\nQ | t1[2] < x < t1[3]}, S2 := {x ∈Q | x < t1[1]}, T1 := {y ∈Q | t2[2] < y < t2[1]},\nand T2 := {y ∈Q | y < t2[3]}. See Figure 10.17 for an illustration of these sets.\nFor each k ∈N, we deﬁne sets S(k)\n1 , T (k)\n1\n, S(k)\n2 , T (k)\n2\nas follows. Apply Lemma 8.2.9\nto the grid S1×T1 (both S1 and T1 are inﬁnite and in particular larger than R(R(k))),\nand obtain subsets U (k) ⊆S1 and V (k) ⊆T1 such that |U (k)| ≥R(k), |V (k)| ≥R(k),\nand f is canonical on U (k) × V (k). Similarly, we apply Theorem 8.2.9 to the grid\nU (k) × T2 and obtain subsets S(k)\n1\n⊆U (k) and T (k)\n2\n⊆T2 of cardinality at least k\nsuch that f is homogenous on S(k)\n1\n× T (k)\n2\n. We ﬁnally apply Theorem 8.2.9 to the\ngrid S2 × V (k) and obtain subsets S(k)\n2\n⊆S2 and T (k)\n1\n⊆V (k) of cardinality at least\nk such that f is canonical on S(k)\n2\n× T (k)\n1\n. Note that f is in particular canonical on\nS(k)\n1\n× T (k)\n1\n.\nThere are just 63 possibilities for how f behaves on those grids for given k. Hence,\nthere is an inﬁnite set K ⊆N such that f behaves in the same way on S(k)\n1\n× T (k)\n1\nfor all k ∈K, in the same way on S(k)\n1\n× T (k)\n2\nfor all k ∈K, and in the same way on\nS(k)\n2\n× T (k)\n1\nfor all k ∈K.\nThe following observations will be obvious by inspection of Figure 10.17, left\nside. In case that S(k)\n1\nis before S(k)\n2\n(that is, all elements in S(k)\n1\nare smaller than all\nelements in S(k)\n2 ) and T (k)\n1\nis before T (k)\n2\n, then by the choice of S(k)\n1 , S(k)\n2 , T (k)\n1\n, and\nT (k)\n2\n, and because f preserves <, we have\nf(x, y) < f(t1[2], t2[2]) < f(t1[1], t2[1]) < f(x′, y′)\nfor all (x, y) ∈S(k)\n1\n× T (k)\n1\nand (x′, y′) ∈(S(k)\n1\n× T (k)\n2\n). Similarly,\nf(x, y) < f(t1[2], t2[2]) < f(t1[3], t2[3]) < f(x′′, y′′)\nfor all (x, y) ∈S(k)\n1\n× T (k)\n1\nand (x′′, y′′) ∈(S(k)\n2\n× T (k)\n1\n).\nThe other case is that\nS(k)\n2\nis before S(k)\n1\nand T (k)\n2\nis before T (k)\n1\n(see the right side of Figure 10.17 for an\n\n244\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\nillustration). In this case f(x, y) > f(t1[2], t2[2]) > f(x′, y′) for all (x, y) ∈S(k)\n1\n×T (k)\n1\nand (x′, y′) ∈(S(k)\n1\n× T (k)\n2\n) ∪(S(k)\n2\n× T (k)\n1\n).\nFirst suppose that f is dominated by the same argument on all the grids S(k)\n1\n×\nT (k)\n1\n, S(k)\n1\n× T (k)\n2\n, and S(k)\n2\n× T (k)\n1\nfor all k ∈K. We can assume that f is dominated\non these grids by the second argument; otherwise we swap the arguments of f. Let\ng, h ∈{lexy,x, lexy,−x, py} be such that f behaves like g on S(k)\n1\n× T (k)\n1\nand like h on\nS(k)\n2\n× T (k)\n1\n. Then by the above observations and local interpolation f generates [g|h]\nif S1 is before S2, and [h|g] if S2 is before S1. Moreover, we show that f also generates\nlex.\n• If g or h is lexx,y or lexy,x, then f clearly generates lex.\n• If g or h is lexx,−y or lexy,−x, then f generates lex as well, as lex(x, −lex(x, −y))\nbehaves like lex(x, y).\n• If g is py and h is py, then f generates lex by Lemma 10.4.5.\nNote that the operation [g|h] satisﬁes the conditions in Lemma 10.4.4, and hence\n{lex, [g|h]} generates [lexy,x|lexy,x]. By Lemma 10.4.5, f generates ll.\nNow we consider the case that f is dominated by diﬀerent arguments on the grids\nS(k)\n1\n×T (k)\n1\nand S(k)\n1\n×T (k)\n2\n, or by diﬀerent arguments on the grids S(k)\n1\n×T (k)\n1\nand S(k)\n2\n×\nT (k)\n1\n, for all k ∈K. We only consider the ﬁrst case; the second case is symmetric under\nswapping the arguments of f. Let g, h be from {lexx,y, lexx,−y, lexy,x, lexy,−x, px, py}\nsuch that f behaves like h on the grids S(k)\n1\n×T (k)\n1\nand like g on the grids S(k)\n2\n×T (k)\n1\n.\nAgain, by local interpolation f generates [h|g] if S1 is before S2, and [g|h] if S2 is\nbefore S1. We assume without loss of generality that f generates [h|g] (in the other\ncase we can exchange the names of h and g and proceed in the same way).\nIf h is py and g is px, then [h|g] behaves like pp; hence f generates pp and we are\ndone. Dually, if h is px and g is py, then f generates dual-pp. In all other cases, either\nh or g is from lexx,y, lexy,x, lexx,−y, or lexy,−x, and thus f generates lex as we have\nalready seen before. But then Lemma 10.4.4 shows that f generates ll or dual-ll.\n□\n10.6.2. Summary. We summarize our ﬁndings in the following classiﬁcation\nstatement; also see Figure 10.18.\nTheorem 10.6.3. Let B be a temporal constraint language.\nThen one of the\nfollowing applies.\n• B is preserved by at least one of the following nine operations: ll, min, mi, mx,\ntheir duals, or a constant operation.\n• Betw, Cycl, Sep, T3, −T3, or I6 is primitive positive deﬁnable in B.\nProof. Theorem 10.3.2 asserts that one of the following cases is true:\n(1) There is a primitive positive deﬁnition of Cycl, Betw, or Sep in B.\n(2) Pol(B) contains a constant operation.\n(3) Pol(B) contains all permutations of Q. In this case, Theorem 6.4.2 shows\nthat B either has a binary injective polymorphism g, or the relation I6 has\na primitive positive deﬁnition in B. In the ﬁrst case, by composing g with\na permutation, we see that all binary injective operations preserve B, and\nhence in particular the operation ll is a polymorphism of B.\n(4) all f ∈Pol(B) preserve <.\nWe are done in all cases except the fourth.\nAlso, we can assume that B has a\npolymorphism f that violates Betw.\nBy Lemma 5.3.10, we can assume that f is\nbinary. Then Lemma 10.6.2 implies that the operation f generates pp, dual-pp, ll, or\ndual-ll. If f generates ll or dual-ll there is nothing to show. If f generates pp then\n\n10.6. CLASSIFICATION\n245\n-\nconstant\nNP-complete\nin P\ncycl\nlex\npp\nmin\nll\nmx\nmi\nPol(Betw)\nPol(Cycl)\nPol(E6)\nPol(Sep)\nPol(T3)\nFigure 10.18. An illustration of the classiﬁcation result for tempo-\nral constraint languages. Double-circles mean that the corresponding\noperation has a dual generating a distinct clone which is not drawn\nin the ﬁgure.\nLemma 10.5.29 shows that either T3 has a primitive positive deﬁnition in B, or B is\npreserved by min, mi, or mx. Dually, if f generates dual-pp then either −T3 has a\nprimitive positive deﬁnition in B, or B is preserved by one of the duals of min, mi,\nor mx, which completes the proof.\n□\nWith the previous theorem it is easy to obtain the full complexity classiﬁcation\nfor temporal constraint satisfcation problems, and ﬁnally show Theorem 10.1.1.\nProof of Theorem 10.1.1. When B is preserved by ll, min, mi, mx, one of\ntheir duals, or the constant operation, then B has an at most ternary weak near una-\nnimity polymorphism modulo endomorphisms; this is immediate for the commutative\nbinary functions mx, min, their duals, and for the constant function. For ll, this has\nbeen shown in Theorem 10.4.11, and for mi in Theorem 10.5.18. For dual mi and\ndual ll the dual argument works.\nNow let B′ be a ﬁnite signature reduct of B. If B′ is preserved by a constant\noperation, then tractability of CSP(B′) follows from Proposition 1.1.11. For the case\nthat B′ is preserved by ll or dual-ll we have presented a polynomial-time algorithm\nfor CSP(B′) in Theorem 10.4.19. If B′ is preserved by min, mi, mx, or one of their\nduals, tractability of CSP(B′) is shown in Section 10.5.7.\nNow suppose that B is not preserved by one of the listed operations. Then by\nTheorem 10.6.3 we know that one of the relations Betw, Cycl, Sep, T3, −T3, or I6\nhas a primitive positive deﬁnition in B. Each of those relations together with ﬁnitely\nmany constants primitively positively interprets ({0, 1}; 1IN3):\n• For (Q; Betw, 0) a primitive positive interpretation of ({0, 1}; NAE) has been\nshown in Proposition 5.5.13,which also gives a primitive positive interpreta-\ntion of ({0, 1}; 1IN3) in (Q; Betw, 0) via Theorem 5.5.17.\n\n246\n10. TEMPORAL CONSTRAINT SATISFACTION PROBLEMS\n• a primitive positive interpretation of ({0, 1}; 1IN3) in (Q; Cycl) with param-\neters has been given in Theorem 10.2.7.\n• The structure (Q; Sep, 0, 1) primitively positively interprets ({0, 1}; 1IN3) by\nProposition 10.2.8.\n• The structure (Q; T3, 0) primitively positively interprets ({0, 1}; 1IN3) by\nProposition 10.2.6; the proof for −T is dual.\n• I6 primitively positively interprets ({0, 1}; 1IN3) by Proposition 5.5.9.\nFinally, recall from Theorem 10.3.1 that if B does not have a constant endomorphism,\nthen it is a model-complete core, and hence Corollary 5.6.11 shows that the two cases\nin the statement of Theorem 10.1.1 are distinct.\n□\nSee Figure 10.19 for an overview over the nine largest tractable temporal con-\nstraint languages; the entries also mention typical relations for the respective lan-\nguage, i.e., a set of relations that is contained in the language, but not contained in\nany other of the nine languages – hence, these relations show that all the languages\nare distinct.\nPolymorphism\nTypical Relations\nComplexity\nReference\nmin\n{U, <}\nO(n2m)\nTheorem 10.5.35\nmi\n{I}\nO(n3m)\nTheorem 10.5.37\nmx\n{X}\nO(n4)\nTheorem 10.5.38\nmax = dual min\n{−U, <}\nO(n2m)\ndual mi\n{−I}\nO(n3m)\ndual mx\n{−X}\nO(n4)\nll\n{(u ̸= v) ∨(x > y) ∨(x > z)}\nO(nm)\nTheorem 10.4.19\ndual ll\n{(u ̸= v) ∨(x < y) ∨(x < z)}\nO(nm)\nconstant\n{(x ≤y ≤z) ∨(z ≤y ≤x)}\nO(m)\nFigure 10.19. Summary of the various tractable languages.\nFor\nthe last three operations, the typical relations are given by their\nﬁrst-order deﬁnition; in all other cases, see Section 10.5.\n10.6.3. Decidability of Tractability. We want to remark that the so-called\nmeta-problem for tractability is decidable; this is formally stated in the following\ncorollary.\nCorollary 10.6.4. There is an algorithm that, given quantiﬁer-free ﬁrst-order\nformulas φ1, . . . , φn that deﬁne over (Q; <) the relations R1, . . . , Rn, decides whether\nCSP(Q; R1, . . . , Rn) is tractable or NP-complete.\nProof. Follows from Theorem 8.4.4 in combination with Theorem 10.6.3.\n□\n\nCHAPTER 11\nNon-Dichotomies\nThere are basically two methods for proving that a subclass of NP does not have\na complexity dichotomy. The ﬁrst is to show that for every problem in NP there is a\npolynomial-time equivalent problem in the subclass. By polynomial-time equivalent\nwe mean that there are polynomial-time Turing reductions between the two problems.\nThe non-dichotomy result then follows from Ladner’s theorem [143], which asserts\nthat there are problems in NP that are neither in P nor NP-complete, unless P=NP.\nThis method has been applied to show that, for example, the class of monotone\nSNP does not exhibit a complexity dichotomy [95]. We will apply this technique in\nSection 11.1 and Section 11.2 to give two diﬀerent proofs of the fact that the class of\n247\n\n248\n11. NON-DICHOTOMIES\nall constraint satisfaction problems with inﬁnite domains does not have a complexity\ndichotomy.\nThe second technique to show a non-dichotomy is to directly use Ladner’s proof\ntechnique, which is sometimes called delayed diagonalization. We will use this method\nin Section 11.3 to show that there are ω-categorical structures B such that CSP(B)\nis in coNP, but neither in P nor coNP-complete (unless P=coNP). The question\nwhether there are ω-categorical structures B such that CSP(B) is in NP \\ P but not\nNP-complete is still open.\nThis chapter contains results from [33] (in Section 11.3) as well as previously\nunpublished results.\n11.1. Arithmetical Templates\nIn this section we show that for every computational decision problem there exists\na polynomial-time equivalent constraint satisfaction problem with an inﬁnite template\nB.\nThis result was ﬁrst shown in [33].\nHere we present a new proof that uses\nMatiyasevich’s theorem. In fact, we prove a stronger result, namely the existence of\na single structure C such that for every recursively enumerable problem P there is a\nstructure B with a ﬁrst-order deﬁnition in C such that CSP(B) is polynomial-time\nequivalent to P. A second proof, based on the results in Section 1.4.2 of Chapter 1,\ncan be found in the next section.\nPreviously, Bauslaugh [16] showed that for every recursive function f there exists\nan inﬁnite structure B such that CSP(B) is decidable, but has time complexity at\nleast f. More recently, Schwandtner gave upper and lower bounds in the exponen-\ntial time hierarchy for some inﬁnite domain CSPs [186]; but these bounds leave an\nexponential gap.\nIn this section we make essential use of the following theorem, which is due to\nDavis, Matiyasevich, Putnam, and Robinson.\nTheorem 11.1.1 (See e.g. [162]). A subset of Z is recursively enumerable if and\nonly if it has a primitive positive deﬁnition in (Z; ∗, +, 1), the integers with addition\nand multiplication.\nTheorem 11.1.2. For every recursively enumerable problem P there exists a re-\nlational structure B with a ﬁrst-order (in fact, a primitive positive) deﬁnition in\n(Z; ∗, +, 1) such that CSP(B) is polynomial-time Turing equivalent to P.\nProof. Code P as a set L of natural numbers, viewing the binary encodings\nof natural numbers as bit strings. More precisely, s ∈P if and only if the number\nrepresented in binary by the string 1s is in L. That is, we append the symbol 1 at\nthe front so that for instance 00 ∈P and 01 ∈P correspond to diﬀerent numbers in\nL. Now consider the structure B := (Z; S, D, L′, N) where\n• S is the binary relation deﬁned by\nS(x, y) ⇔\n\u0000(y = x + 1 ∧x ≥0) ∨(x = y = −1)\n\u0001\n• D is the binary relation deﬁned by\nD(x, y) ⇔\n\u0000(y = 2x ∧x ≥0) ∨(x = y = −1)\n\u0001\n• L′ := L ∪{−1}\n• N := {0}\nClearly, if P is recursively enumerable, then L and L′ are recursively enumerable, too.\nWe have to verify that CSP(B) is polynomial time equivalent to P. We ﬁrst show\nthat there is a polynomial-time reduction from P to CSP(B). View an instance of\nP as a number n ≥0 as above, and let η(x) be a primitive positive deﬁnition for\n\n11.2. CSPS IN SNP\n249\nx = n in B. It is possible to ﬁnd such a deﬁnition in polynomial time by repeatedly\ndoubling (y = x + x) and incrementing (y = x + 1) the value 0 (this also follows from\nthe more general Lemma 1.5.1). It is clear that n codes a yes-instance of P if and\nonly if ∃x(η(x) ∧L′(x)) is true in B.\nTo reduce CSP(B) to P, we present a polynomial-time algorithm for CSP(B) that\nuses an oracle for P (so our reduction will be a polynomial-time Turing reduction).\nLet φ be an instance of CSP(B), and let H be the undirected graph whose vertices\nare the variables W of φ, and which has an edge between x and y if φ contains the\nconstraint S(x, y) or the constraint D(x, y). Compute the connected components of\nH. If a connected component does not contain x with a constraint N(x) in φ, then\nwe can set all variables of that component to −1 and satisfy all constraints involving\nthose variables.\nOtherwise, suppose that we have a component C that does contain x0 with a\nconstraint N(x0). Observe that by connectivity, if there exists a solution, then all\nvariables in C must take non-negative value. Consider the following linear system:\nfor each constraint of the form S(x, y) for x, y ∈C we add y = x + 1 and x ≥0 to the\nsystem, and for each constraint of the form D(x, y) for x, y ∈D we add z = 2x and\nx ≥0. Subject to x0 = 0 this system has either one or no solution. We can check\nin polynomial time whether a linear system with 2 variables per constraint has no\ninteger solution [48], and if there is no solution, the algorithm rejects. Otherwise, the\nalgorithm assigns to each variable x ∈C its unique integer value, and if φ contains a\nconstraint L′(x), we call the oracle for P with the binary encoding of this value. If\nany of those oracle calls has a negative result, reject. Otherwise, we have found an\nassignment that satisﬁes all constraints, and accept.\n□\nThe universal-algebraic approach fails badly when it comes to analysing the com-\nputational complexity of CSP(B): the semi-lattice operation (x, y) 7→max(x, y) pre-\nserves B for all structures B considered in the previous proof, and from that we\ncannot draw any consequences for the computational complexity of CSP(B).\n11.2. CSPs in SNP\nAnother proof that shows that every problem in NP is polynomial-time Turing\nequivalent to an inﬁnite domain CSP is based on a result by Feder and Vardi, and\nthe results from Section 1.4.3.\nTheorem 11.2.1 (Theorem 3 in [95]). Every problem in NP is equivalent to a\nproblem in monotone SNP under polynomial-time reductions.\nWe show the following.\nProposition 11.2.2. Every problem in monotone SNP is equivalent to a problem\nin monotone connected SNP under polynomial-time Turing reductions.\nProof. Let Φ be a monotone SNP sentence of the form ∃R1, . . . , Rk ∀x1, . . . , xl. φ\nfor φ quantiﬁer-free and in conjunctive normal form. The sentence Ψ that we are go-\ning to construct from Φ has an additional free relation symbol E, and an existentially\nquantiﬁed relation symbol T, and is deﬁned by\n∃R1, . . . , Rk, T ∀x1, . . . , xl. ψ\nwhere ψ is the quantiﬁer-free ﬁrst-order formula with the following clauses.\n(1) ¬E(x1, x2) ∨T(x1, x2);\n(2) ¬T(x1, x2) ∨¬T(x2, x3) ∨T(x1, x3);\n(3) ¬T(x1, x2) ∨T(x2, x1);\n\n250\n11. NON-DICHOTOMIES\n(4) for each clause φ′ of φ with variables x1, . . . , xq, the clause\nφ′ ∨\n_\ni<j<q\n¬T(xi, xj) .\nThe sentence Ψ is clearly connected and monotone. We are therefore left with the\ntask to verify that Φ and Ψ are equivalent under polynomial-time Turing reductions.\nWe start with the reduction from Φ to Ψ. When A is a ﬁnite τ-structure, we\nexpand A to a (τ ∪{E})-structure A′ by choosing for E the full binary relation. Then\nalso T must denote the full binary relation (so that the clauses from item (1), (2),\nand (3) above are satisﬁed), and the clauses introduced in (4) are equivalent to φ′.\nHence, Φ holds on A if and only if Ψ holds on A′.\nFor the reduction from Ψ to Φ, let A be an instance of Ψ. We can compute the\nconnected components C1, . . . , Ck of the {E}-reduct of A in polynomial time in the\nsize A. For each of those connected components C, we evaluate Φ on the τ-reduct AC\nof A[C]. If for one component this evaluation is negative, then A[C] and consequently\nA do not satisfy Ψ. Otherwise, for each C there exists an τ ∪{R1, . . . , Rk}-expansion\nof AC that satisﬁes φ. Let A′ be the expansion of the disjoint union of all those\n(τ ∪{R1, . . . , Rk})-structures by the relation T denotes the equivalence relation with\nequivalence classes C1, . . . , Ck. Clearly, all clauses from items (1), (2), and (3) in the\ndeﬁnition of Ψ are satisﬁed by A′. Each q-tuple (a1, . . . , aq) from elements of A′ either\ncontains entries from diﬀerent components, and hence satisﬁes the disjunctions from\nitem (4), or contains only entries from the same component C, but in this case the\ntuple also satisﬁes the disjunctions from item (4) since AC satisﬁes Φ.\n□\nCorollary 11.2.3. For every problem in NP there is a structure B such that\nthe problem is polynomial-time Turing equivalent to CSP(B).\nProof. By Theorem 11.2.1, every problem in NP is equivalent to a monotone\nSNP sentence Φ under polynomial-time reductions.\nWe have shown in Proposi-\ntion 11.2.2 that Φ is equivalent to a monotone connected SNP sentence Ψ, and by\nTheorem 1.4.11 there exists an inﬁnite structure B such that Ψ describes CSP(B).\n□\nIn Figure 11.1 the diagram about the fragments of SNP from Section 1.4 has been\ndecorated with information about the complexity classiﬁcation status.\n11.3. coNP-intermediate ω-categorical Templates\nIn this section we show that there exists an ω-categorical directed graph B such\nthat CSP(B) is in coNP, but neither coNP-complete nor in P (unless coNP=P). All\nstructures in this section will be Fra¨ıss´e limits of classes of directed graphs.\nLet N be a class of ﬁnite tournaments, and recall that Forb(N), the class of\nall ﬁnite digraphs that does not embed a tournament from N, is an amalgamation\nclass (Example 3.2.7). We write BN for the Fra¨ıss´e-limit of Forb(N). Observe that\nfor ﬁnite N the problem CSP(BN ) can be solved in deterministic polynomial time,\nbecause for a given instance A of this problem an algorithm simply has to check\nwhether there is a homomorphism from one of the structures in N to A, which is the\ncase if and only if there is a homomorphism from A to BN .\nWhen proving that there are uncountably many homogeneous digraphs, Henson\nspeciﬁed an inﬁnite set T of tournaments T3, T4, . . . with the property that Ti does\nnot embed into Tj if i ̸= j. The tournament Tn, for n ≥3, in Henson’s set T has\nvertices 0, . . . , n + 1, and the following edges:\n• (i, j) for j = i + 1 and 0 ≤i ≤n;\n• (0, n + 1);\n• (j, i) for j > i + 1 and (i, j) ̸= (0, n + 1).\n\n11.3. CONP-INTERMEDIATE ω-CATEGORICAL TEMPLATES\n251\nSNP\nmonotone \nSNP\nconnected \nSNP\nSNP ∩ \nCSP(inf)\nconnected \nmonotone \nmonadic SNP\nSNP ∩ \nCSP(ω-cat)\nCSP(ﬁn)\nmonotone \nmonadic SNP\nFeder-Vardi Conjecture:\nDichotomy\nNo Dichotomy\nDichotomy\nUnknown\nNP\nFigure 11.1. Dichotomies and non-dichotomies for fragments of\nSNP. CSP(inf) (CSP(ω-cat), CSP(ﬁn)) refers to the class of all prob-\nlems CSP(B) where B is an inﬁnite (ω-categorical, ﬁnite, respec-\ntively) structure with ﬁnite relational signature.\nProposition 11.3.1. The problem CSP(BT ) is coNP-complete.\nProof. The problem is contained in coNP, because we can eﬃciently test whether\na sequence v1, . . . , vk of distinct vertices of a given directed graph A induces Tk in\nA, i.e., whether (vi, vj) is an arc in A if and only if (i, j) is an arc in Tk, for all\ni, j ∈{1, . . . , k}. If for all such sequences of vertices this test is negative, we can be\nsure that A is from Forb(T ), and hence homomorphically maps to BT . Otherwise, A\nembeds a structure from T , and hence does not homomorphically map to BT .\nThe proof of coNP-hardness goes by reduction from the complement of the NP-\ncomplete 3SAT problem (see Example 1.2.2), and is inspired by a classical reduction\nfrom 3-SAT to Clique.\nFor a given 3-SAT instance, we create an instance A of\nCSP(BT ) as follows: If\n{x1\n0, x2\n0, x3\n0}, . . . , {x1\nk+1, x2\nk+1, x3\nk+1}\nare the clauses of the 3-SAT formula (we assume without loss of generality that the\n3-SAT instance has at least three clauses), then the vertex set of A is\n{(0, 1), (0, 2), (0, 3), . . . , (k + 1, 1), (k + 1, 2), (k + 1, 3)} ,\nand the arc set of A consists of all pairs ((i, j), (p, q)) of vertices such that xj\ni ̸= ¬xq\np\nand such that (i, p) is an arc in Tk.\nWe claim that a 3-SAT instance is unsatisﬁable if and only if the created in-\nstance A homomorphically maps to BT . The 3-SAT instance is satisﬁable iﬀthere\nis a mapping from the variables to true and false such that in each clause at least\none literal, say xj0\n0 , . . . , xjk+1\nk+1 , is true.\nThis is the case if and only if the vertices\n(0, j1), . . . , (k + 1, jk+1) induce Tk in A, i.e., ((i, ji), (p, jp)) is an edge if and only if\n\n252\n11. NON-DICHOTOMIES\n(i, p) is an edge in Tk. This is the case if and only if Tk embeds into A. To conclude,\nit suﬃces to prove that Tk embeds into A if and only if A does not homomorphically\nmap to BT . It is clear that if Tk embeds into A, then A does not homomorphically\nmap to BT . Conversely, if A does not homomorphically embed to BT , then there\nexists a j such that there is an embedding e of Tj into A. Then for any (i, j), (p, q)\nin the image of e we have that (i, p) is an edge of Tk. Therefore, the mapping that\nsends an element u of Tj to the ﬁrst component of e(u) is an embedding of Tj into Tk.\nSince Tj and Tk are homomorphically inequivalent for all distinct j, k ≥3 we obtain\nthat j = k and that Tk embeds into A, which ﬁnishes the proof.\n□\nWe now modify the proof of Ladner’s Theorem given in [171] (which is basically\nLadner’s original proof) to create a subset T0 of T such that CSP(BT0) is in coNP,\nbut neither in P nor coNP-complete (unless coNP=P). One of the ideas in Ladner’s\nproof is to ‘blow holes into SAT’, such that the resulting problem is too sparse to be\nNP-complete and to dense to be in P. Our modiﬁcation is that we do not blow holes\ninto a computational problem itself, but that we ‘blow holes into the obstruction set\nT of CSP(BT )’.\nIn the following, we ﬁx one of the standard encodings of graphs as strings over the\nalphabet {0, 1}. Let M1, M2, . . . be an enumeration of all polynomial-time bounded\nTuring machines, and let R1, R2, . . . be an enumeration of all polynomial time bounded\nreductions. We assume that these enumerations are eﬀective; it is well-known that\nsuch enumerations exist.\nThe deﬁnition of T0 uses a Turing machine F that computes a function f : N →N,\nwhich is deﬁned below. The set T0 is then deﬁned as follows.\nT0 = {Tn | f(n) is even }\nThe input number n is given to the machine F in unary representation. The compu-\ntation of F proceeds in two phases. In the ﬁrst phase, F simulates itself1 on input\n1, then on input 2, 3, and so on, until the number of computation steps of F in this\nphase exceeds n (we can always maintain a counter during the simulation to recognize\nwhen to stop). Let k be the value f(i) for the last input i for which the simulation\nwas completely performed by F.\nIn the second phase, the machine stops if phase two takes more than n compu-\ntation steps, and F returns k. We distinguish whether k is even or odd. If k is even,\nall directed graphs A on s = 1, 2, 3, . . . vertices are enumerated. For each directed\ngraph A in the enumeration the machine F simulates Mk/2 on the encoding of A.\nMoreover, F computes whether A homomorphically maps to BT0. This is the case\nif for all structures Tl ∈T that embed into A the value of f(l) is even. So F tests\nfor l = 1, 2, . . . , s whether Tl embeds to A (F uses any straightforward exponential\ntime algorithm for this purpose), and if it does, simulates itself on input l to ﬁnd out\nwhether f(l) is even. If\n(1) Mk/2 rejects and A homomorphically maps to BT0, or\n(2) Mk/2 accepts and A does not homomorphically map to BT0,\nthen F returns k + 1 (and f(n) = k + 1).\nThe other case of the second phase is that k is odd. Again F enumerates all\ndirected graphs A on s = 1, 2, 3, . . . vertices, and simulates the computation of R⌊k/2⌋\non the encoding of A. Then F computes whether the output of R⌊k/2⌋encodes a\ndirected graph A′ that homomorphically maps to BT0. The graph A′ homomorphi-\ncally maps to BT0 iﬀfor all tournaments Tl that embed into A′ the value f(l) is\n1Note that by the ﬁxpoint theorem of recursion theory we can assume that F has access to its\nown description.\n\n11.3. CONP-INTERMEDIATE ω-CATEGORICAL TEMPLATES\n253\neven. Whether Tl embeds into A′ is tested with a straightforward exponential-time\nalgorithm. To test whether f(l) is even, F simulates itself on input l. Finally, F tests\nwith a straightforward exponential-time algorithm whether A homomorphically maps\nto BT . If\n(3) A homomorphically maps to BT and A′ does not homomorphically map to\nBT0, or\n(4) A does not homomorphically map to BT and A′ homomorphically maps to\nBT0,\nthen F returns k + 1.\nLemma 11.3.2. The function f is a non-decreasing function, that is, for all n we\nhave f(n) ≤f(n + 1).\nProof. We inductively assume that f(s −1) ≤f(s) for all s ≤n, and have to\nshow that f(n) ≤f(n + 1). Since F has more time to simulate itself when we run it\non n + 1 instead of n, the value i computed in the ﬁrst phase of F cannot become\nsmaller. By inductive assumption, k = f(i) cannot become smaller as well. In the\nsecond phase, we either return k or k + 1. Hence, if k becomes larger in the ﬁrst\nphase, the output of F cannot become smaller. If k does not become larger, then the\nonly diﬀerence between the second phase of F for input n + 1 compared to input n\nis that there is more time for the computations. Hence, if the machine F on input n\nveriﬁes condition (1),(2),(3),(4) for some graph A (and hence returns k + 1), then F\nalso veriﬁes this condition for A on input n + 1, and returns k + 1 as well. Otherwise,\nf(n) = k, and also here f(n + 1) ≥f(n) holds.\n□\nLemma 11.3.3. For all n0 there exists an n > n0 such that f(n) > f(n0) (unless\ncoNP ̸= P).\nProof. Assume for contradiction that there exists an n0 such that f(n) equals\na constant k0 for all n ≥n0. Then there also exists an n1 such that for all n ≥n1\nthe value of k computed by the ﬁrst phase of F on input n is k0.\nIf k0 is even, then on all inputs n ≥n1 the second phase of F simulates Mk0/2\non encodings of an enumeration of graphs. Since the output of F must be k0, for all\ngraphs neither (1) nor (2) can apply. Since this holds for all n ≥n1, the polynomial-\ntime bounded machine Mk0/2 correctly decides CSP(BT0), and hence CSP(BT0) is in\nP. But then there is the following polynomial-time algorithm that solves CSP(BT ),\na contradiction to coNP-completeness of CSP(BT ) (Proposition 11.3.1) and our as-\nsumption that coNP ̸= P.\nInput: A directed graph A.\nIf A homomorphically maps to BT0 then accept.\nTest whether one of the ﬁnitely many graphs in T \\ T0 embeds into A.\nAccept if none of them embeds into A.\nReject otherwise.\nIf k0 is odd, then on all inputs n ≥n1 the second phase of F does not ﬁnd a graph\nA for which (3) or (4) applies, because the output of F must be k0. Hence, R⌊k0/2⌋is\na polynomial-time reduction from CSP(BT ) to CSP(BT0), and by Proposition 11.3.1\nthe problem CSP(BT0) is coNP-hard. But note that because f(n) equals the odd\nnumber k0 for all but ﬁnitely many n, the set T0 is ﬁnite. Therefore, CSP(BT0) can\nbe solved in polynomial time, contradicting our assumption that coNP ̸= P.\n□\n\n254\n11. NON-DICHOTOMIES\nTheorem 11.3.4. CSP(BT0) is in coNP, but neither in P nor coNP-complete\n(unless coNP=P).\nProof. It is easy to see that CSP(BT0) is in coNP. On input A the algorithm\nnon-deterministically chooses a sequence of l vertices, and checks in polynomial time\nwhether this sequence induces a copy of Tl. If yes, the algorithm computes f(l), which\ncan be done in linear time by executing F on the unary representation of l. If f(l)\nis even, the algorithm accepts. Recall that A does not homomorphically map to BT0\niﬀa tournament Tl ∈T0 embeds into A, which is the case iﬀthere is an accepting\ncomputation path for the above non-deterministic algorithm.\nSuppose that CSP(BT0) is in P.\nThen for some i the machine Mi decides\nCSP(BT0). By Lemma 11.3.2 and Lemma 11.3.3 there exists an n0 such that f(n0) =\n2i. Then there must also be an n1 > n2 such that the value k computed during the\nﬁrst phase of F on input n1 equals 2i. Since Mi correctly decides CSP(BT0), the\nmachine F returns 2i on input n1. By Lemma 11.3.2, the machine F also returns 2i\nfor all inputs from n1 to n2, and by induction it follows that it F returns 2i for all\ninputs larger than n ≥n0, in contradiction to Lemma 11.3.3.\nFinally, suppose that CSP(BT0) is coNP-complete. Then for some i the machine\nRi is a valid reduction from CSP(BT ) to CSP(BT0). Again, by Lemma 11.3.2 and\nLemma 11.3.3 there exists an n1 such that the value k computed during the ﬁrst phase\nof F on input n1 equals 2i. Since the reduction Ri is correct, the machine F returns\n2i on input n1, and in fact returns 2i on all inputs greater than n1. This contradicts\nLemma 11.3.3.\n□\n\nCHAPTER 12\nFuture Work\nWe conclude the thesis by mentioning four promising directions of future work.\n12.1. Phylogeny Constraints\nWe have presented a classiﬁcation of the complexity of CSP(B) for all structures\nB with a ﬁrst-order deﬁnition over (Q; <), or over the random graph (V; E). One\nmight ask which other structures, besides (Q; <) and the random graph (V; E), are\ninteresting and promising candidates for such a classiﬁcation.\nA very interesting\ncandidate is the structure (L; |) (or equivalently, over a relatively 3-transitive C-set),\nintroduced in Section 4.1. The class of CSPs that can be formulated with templates\nthat can be deﬁned over this structure is very large and contains many problems that\nhave been independently studied in the literature, capturing for instance the rooted\ntriple satisfaction problem and the quartet satisﬁability problem from phylogenetic\nanalysis. All the tools we needed for complexity classiﬁcation are available: (L; |) is\nhomogeneous, and an appropriate order expansion of it is Ramsey (see Example 8.1.8).\n12.2. Datalog\nFeder and Vardi [95] observed that all the known algorithms for solving CSP(B),\nfor a ﬁnite structure B, are either based on algebraic algorithms that can be seen as\ngeneralizations of Gaussian elimination, or based on simple ‘constraint propagation’,\nor combinations of these two paradigms. This is still the case today. An elegant way\nto formalize algorithms that perform constraint propagation is Datalog. Datalog can\nbe seen as conjunctive queries that have been extended by a recursion mechanisms;\nalternatively, one can view Datalog as Prolog (see e.g. [183]) without function sym-\nbols. In the context of constraint satisfaction Datalog has been introduced in [95]\nand further studied in [136]. Some of the early contributions were equivalent char-\nacterizations of the expressive power of Datalog in terms of bounded treewidth duality\nand existential pebble games.\nRecently, Barto and Kozik [12] presented an exact characterization of those CSPs\nwhere CSP(B) can be solved by a Datalog program. The characterization is universal-\nalgebraic (see Chapter 5), and conﬁrming a conjecture of Larose and Zadori [147]. It\nwas later shown to be equivalent to a conjecture made already by Feder and Vardi\nin [95], see [146].\nDatalog programs are very useful to solve inﬁnite-domain constraint satisfaction\nproblems as well. It has been shown in [31] that when B is an ω-categorical structure,\nthen the characterizations of the expressive power of Datalog in terms of bounded\ntreewidth duality and existential pebble games remain valid. This has been applied to\nshow that several fundamental inﬁnite-domain CSPs in the literature cannot be solved\nby Datalog [42,45]. It would be very interesting to have an algebraic characterization\nof the expressive power of Datalog for CSPs with ω-categorical templates.\n255\n\n256\n12. FUTURE WORK\n12.3. Topological Clones\nWe have seen in Section 7.4 that the topological automorphism group of an ω-\ncategorical structure Γ describes Γ up to bi-interpretability; that is, two ω-categorical\nstructures Γ and ∆whose automorphism groups are isomorphic as topological groups\nare ﬁrst-order bi-interpretable.\nWe have also seen that the right tool for the complexity study of CSPs is primitive\npositive interpretability, and not ﬁrst-order interpretability; see Section 5.5. So it\nis natural to ask in this context whether primitive positive interpretability can be\ncharacterized in terms of the polymorphism clone viewed as a topological clone, that\nis, viewed as an abstract clone equipped with the topology of point-wise convergence.\nWe did not deﬁne abstract clones; but in this context it suﬃces to know that they\nrelate to clones in the same way as permutation groups relate to abstract groups.\nA partial result in this direction has been obtained in joint work with Junker [39];\none of the results proven there is that two ω-categorical structures without constant\nendomorphism are existential positive bi-interpretable1 if and only if their transfor-\nmation monoids, viewed as topological monoids, are isomorphic.\nThe goal to lift this further to primitive positive interpretability amounts to show-\ning that the topological clone of B characterizes the pseudo-variety generated by the\npolymorphism algebra of B, via Theorem 5.5.14.\n12.4. A Logic for P?\nIn Section 1.4 we have seen a logical characterization of the complexity class NP:\nby Fagin’s theorem, a problem is in NP if and only if it can be described in existential\nsecond-order logic. A similar logic for the complexity class P is not known. The\nquestion whether there exists a logic for P has been formalized by Gurevich [108] and\nbecame one of the most inﬂuential questions in ﬁnite model theory [107].\nOne approach to shed some light on this question is to identify large fragments\nof existential second-order logic such that the set of sentences in this fragment that\ndescribe problems in P has an eﬀective enumeration. For example, consider the logic\nof connected monotone SNP. Theorem 11.2.1 and Proposition 11.2.2 show that every\nproblem in NP is polynomial-time equivalent to a problem in connected monotone\nSNP. The proof of Theorem 11.2.1 and Proposition 11.2.2 is constructive in the sense\nthat from a non-deterministic Turing machine we can eﬀectively construct the cor-\nresponding connected monotone SNP sentence. So if there were an algorithm that\nenumerates those connected monotone SNP sentences that describe a problem in P,\nthen the question to Gurevich’s question is positive (Gurevich conjectured that the\nanswer is negative). Such an algorithm probably does not exist. But it might exist\nfor fragments of connected monotone SNP. Recall that every sentence in connected\nmonotone SNP describes a CSP. Hence, complexity classiﬁcation for inﬁnite domain\nconstraint satisfaction can also be motivated by the quest for a logic for P.\n1A ﬁrst-order interpretation is called existential positive if all the involved formulas of the\ninterpretation are existential positive; existential positive bi-interpretations are deﬁned by a similar\nmodiﬁcation of ﬁrst-order bi-interpretations.\n\nBibliography\n[1] F. G. Abramson and L. Harrington. Models without indiscernibles. Journal of Symbolic Logic,\n43(3):572–600, 1978.\n[2] S. A. Adeleke and P. M. Neumann. Relations related to betweenness: their structure and\nautomorphisms, volume 623 of Memoirs of the AMS. American Mathematical Society, 1998.\n[3] G. Ahlbrandt and M. Ziegler. Quasi-ﬁnitely axiomatizable totally categorical theories. Annals\nof Pure and Applied Logic, 30(1):63–82, 1986.\n[4] A. Aho, Y. Sagiv, T. Szymanski, and J. Ullman. Inferring a tree from lowest common ancestors\nwith an application to the optimization of relational expressions. SIAM Journal on Computing,\n10(3):405–421, 1981.\n[5] J. F. Allen. Maintaining knowledge about temporal intervals. Communications of the ACM,\n26(11):832–843, 1983.\n[6] E. Allender, M. Bauland, N. Immerman, H. Schnoor, and H. Vollmer. The complexity of sat-\nisﬁability problems: Reﬁning Schaefer’s theorem. Journal of Computer and System Sciences,\n75(4):245–254, 2009.\n[7] B. Aspvall, M. F. Plass, and R. E. Tarjan. A linear-time algorithm for testing the truth of\ncertain quantiﬁed boolean formulas. Information Processing Letters, 8(3):121–123, 1979.\n[8] A. Atserias. On digraph coloring problems and treewidth duality. In Proceedings of LICS, pages\n106–115, 2005.\n[9] A. Atserias, A. A. Bulatov, and A. Dawar. Aﬃne systems of equations and counting inﬁnitary\nlogic. Theoretical Computer Science, 410(18):1666–1683, 2009.\n[10] F. Baader and T. Nipkow. Term rewriting and all that. Cambridge University Press, 1999.\n[11] L. Barto. The dichotomy for conservative constraint satisfaction problems revisited. In Pro-\nceedings of the Symposium on Logic in Computer Science (LICS), Toronto, Canada, 2011.\n[12] L. Barto and M. Kozik. Constraint satisfaction problems of bounded width. In Proceedings of\nthe Annual Symposium on Foundations of Computer Science (FOCS), pages 595–603, 2009.\n[13] L. Barto and M. Kozik. New conditions for Taylor varieties and CSP. In Proceedings of LICS,\npages 100–109, 2010.\n[14] L. Barto and M. Kozik. Absorbing subalgebras, cyclic terms and the constraint satisfaction\nproblem. Logical Methods in Computer Science, 8/1(07):1–26, 2012.\n[15] L. Barto, M. Kozik, and T. Niven. The CSP dichotomy holds for digraphs with no sources\nand no sinks (a positive answer to a conjecture of Bang-Jensen and Hell). SIAM Journal on\nComputing, 38(5), 2009.\n[16] B. L. Bauslaugh. The complexity of inﬁnite H-coloring. Journal of Combinatorial Theory,\nSeries B, 61(2):141–154, 1994.\n[17] B. L. Bauslaugh. Core-like properties of inﬁnite graphs and structures. Discrete Mathematics,\n138(1):101–111, 1995.\n[18] B. L. Bauslaugh. Cores and compactness of inﬁnite directed graphs. Journal of Combinatorial\nTheory, Series B, 68(2):255–276, 1996.\n[19] H. Becker and A. Kechris. The Descriptive Set Theory of Polish Group Actions. Number 232\nin LMS Lecture Note Series. Cambridge University Press, 1996.\n[20] I. Ben Yaacov. Positive model theory and compact abstract theories. Journal of Mathematical\nLogic, 3(1):85–118, 2003.\n[21] B. Bennett. Spatial reasoning with propositional logics. In Proceedings of the International\nConference on Knowledge Representation and Reasoning, pages 51–62. Morgan Kaufmann,\n1994.\n[22] J. Berman, P. Idziak, P. Markovic, R. McKenzie, M. Valeriote, and R. Willard. Varieties with\nfew subalgebras of powers. Transactions of the American Mathematical Society, 362(3):1445–\n1473, 2010.\n257\n\n258\nBIBLIOGRAPHY\n[23] M. Bezem, R. Nieuwenhuis, and E. Rodr´ıguez-Carbonell. The max-atom problem and its rel-\nevance. In Proceedings of the International Conference on Logic for Programming, Artiﬁcial\nIntelligence, and Reasoning (LPAR), pages 47–61, 2008.\n[24] M. Bodirsky. Constraint satisfaction with inﬁnite domains. Dissertation, Humboldt-Universit¨at\nzu Berlin, 2004.\n[25] M. Bodirsky. Cores of countably categorical structures. Logical Methods in Computer Science,\n3(1):1–16, 2007.\n[26] M. Bodirsky. Constraint satisfaction problems with inﬁnite templates. In H. Vollmer, editor,\nComplexity of Constraints (a collection of survey articles), volume 5250 of Lecture Notes in\nComputer Science, pages 196–228. Springer, 2008.\n[27] M. Bodirsky and H. Chen. Oligomorphic clones. Algebra Universalis, 57(1):109–125, 2007.\n[28] M. Bodirsky and H. Chen. Quantiﬁed equality constraints. SIAM Journal on Computing,\n39(8):3682–3699, 2010. A preliminary version of the paper appeared in the proceedings of\nLICS’07.\n[29] M. Bodirsky, H. Chen, J. K´ara, and T. von Oertzen. Maximal inﬁnite-valued constraint lan-\nguages. Theoretical Computer Science (TCS), 410:1684–1693, 2009. A preliminary version\nappeared at ICALP’07.\n[30] M. Bodirsky, H. Chen, and M. Pinsker. The reducts of equality up to primitive positive inter-\ndeﬁnability. Journal of Symbolic Logic, 75(4):1249–1292, 2010.\n[31] M. Bodirsky and V. Dalmau. Datalog and constraint satisfaction with inﬁnite templates. Jour-\nnal on Computer and System Sciences, 79:79–100, 2013. A preliminary version appeared in\nthe proceedings of the Symposium on Theoretical Aspects of Computer Science (STACS’05).\n[32] M. Bodirsky, V. Dalmau, B. Martin, and M. Pinsker. Distance constraint satisfaction problems.\nIn P. Hlinen´y and A. Kucera, editors, Proceedings of Mathematical Foundations of Computer\nScience, Lecture Notes in Computer Science, pages 162–173. Springer Verlag, August 2010.\n[33] M. Bodirsky and M. Grohe. Non-dichotomies in constraint satisfaction complexity. In L. Aceto,\nI. Damgard, L. A. Goldberg, M. M. Halld´orsson, A. Ing´olfsd´ottir, and I. Walukiewicz, edi-\ntors, Proceedings of the International Colloquium on Automata, Languages and Programming\n(ICALP), Lecture Notes in Computer Science, pages 184 –196. Springer Verlag, July 2008.\n[34] M. Bodirsky, M. Hils, and A. Krimkevitch. Tractable set constraints. In T. Walsh, editor,\nProceedings of International Joint Conferences on Artiﬁcial Intelligence (IJCAI), pages 510–\n515. AAAI, July 2011.\n[35] M. Bodirsky, M. Hils, and B. Martin. On the scope of the universal-algebraic approach to\nconstraint satisfaction. Logical Methods in Computer Science (LMCS), 8(3:13), 2012. An ex-\ntended abstract that announced some of the results appeared in the proceedings of Logic in\nComputer Science (LICS’10).\n[36] M. Bodirsky, P. Jonsson, and T. V. Pham. The complexity of phylogeny constraint satisfaction.\nIn Proceedings of the Symposium on Theoretical Aspects of Computer Science (STACS), 2016.\nPreprint arXiv:1503.07310.\n[37] M. Bodirsky, P. Jonsson, and T. von Oertzen. Horn versus full ﬁrst-order: complexity di-\nchotomies for algebraic constraint satisfaction. Journal of Logic and Computation, 22(3):643–\n660, 2011.\n[38] M. Bodirsky, P. Jonsson, and T. von Oertzen. Essential convexity and complexity of semi-\nalgebraic constraints. Logical Methods in Computer Science, 8(4), 2012. An extended abstract\nabout a subset of the results has been published under the title Semilinear Program Feasibility\nat ICALP’10.\n[39] M. Bodirsky and M. Junker. ℵ0-categorical structures: interpretations and endomorphisms.\nAlgebra Universalis, 64(3-4):403–417, 2011.\n[40] M. Bodirsky and J. K´ara. The complexity of equality constraint languages. Theory of Comput-\ning Systems, 3(2):136–158, 2008. A conference version appeared in the proceedings of Computer\nScience Russia (CSR’06).\n[41] M. Bodirsky and J. K´ara. The complexity of temporal constraint satisfaction problems. Jour-\nnal of the ACM, 57(2):1–41, 2009. An extended abstract appeared in the Proceedings of the\nSymposium on Theory of Computing (STOC).\n[42] M. Bodirsky and J. K´ara. A fast algorithm and Datalog inexpressibility for temporal reasoning.\nACM Transactions on Computational Logic, 11(3), 2010.\n[43] M. Bodirsky and M. Kutz. Pure dominance constraints. In Proceedings of the Symposium on\nTheoretical Aspects of Computer Science (STACS), pages 287–298, 2002.\n[44] M. Bodirsky and M. Kutz. Determining the consistency of partial tree descriptions. Artiﬁcial\nIntelligence, 171:185–196, 2007.\n\nBIBLIOGRAPHY\n259\n[45] M. Bodirsky and J. K. Mueller. Rooted phylogeny problems. Logical Methods in Computer\nScience, 7(4), 2011. An extended abstract appeared in the proceedings of ICDT’10.\n[46] M. Bodirsky and J. Neˇsetˇril. Constraint satisfaction with countable homogeneous templates.\nIn Proceedings of CSL, pages 44–57, Vienna, 2003.\n[47] M. Bodirsky and J. Neˇsetˇril. Constraint satisfaction with countable homogeneous templates.\nJournal of Logic and Computation, 16(3):359–373, 2006.\n[48] M. Bodirsky, G. Nordh, and T. von Oertzen. Integer programming with 2-variable equations\nand 1-variable inequalities. Information Processing Letters, 109(11):572–575, 2009.\n[49] M. Bodirsky and D. Piguet. Finite trees are Ramsey with respect to topological embeddings.\nTechnical report, arXiv:1002.1557, 2010.\n[50] M. Bodirsky and M. Pinsker. Reducts of Ramsey structures. AMS Contemporary Mathematics,\nvol. 558 (Model Theoretic Methods in Finite Combinatorics), pages 489–519, 2011.\n[51] M. Bodirsky and M. Pinsker. Minimal functions on the random graph. Israel Journal of Math-\nematics, 200(1):251–296, 2014.\n[52] M. Bodirsky and M. Pinsker. Schaefer’s theorem for graphs. Journal of the ACM, 62(3):52\npages (article number 19), 2015. A conference version appeared in the Proceedings of STOC\n2011, pages 655–664.\n[53] M. Bodirsky, M. Pinsker, and A. Pongr´acz. Projective clone homomorphisms. Preprint\narXiv:1409.4601, 2014.\n[54] M. Bodirsky, M. Pinsker, and T. Tsankov. Decidability of deﬁnability. Journal of Symbolic\nLogic, 78(4):1036–1054, 2013. A conference version appeared in the Proceedings of LICS 2011.\n[55] M. Bodirsky and S. Woelﬂ. RCC8 is tractable on instances of bounded treewidth. In T. Walsh,\neditor, Proceedings of International Joint Conferences on Artiﬁcial Intelligence (IJCAI), pages\n756–761. AAAI, July 2011.\n[56] V. G. Bodnarˇcuk, L. A. Kaluˇznin, V. N. Kotov, and B. A. Romov. Galois theory for Post\nalgebras, part I and II. Cybernetics, 5:243–539, 1969.\n[57] F. B¨orner, A. A. Bulatov, H. Chen, P. Jeavons, and A. A. Krokhin. The complexity of constraint\nsatisfaction games and QCSP. Information and Computation, 207(9):923–944, 2009.\n[58] N. Bourbaki. General Topology, Volume 1. Springer, 1998.\n[59] M. Broxvall and P. Jonsson. Point algebras for temporal reasoning: Algorithms and complexity.\nArtiﬁcial Intelligence, 149(2):179–220, 2003.\n[60] M. Broxvall, P. Jonsson, and J. Renz. Disjunctions, independence, reﬁnements. Artiﬁcial In-\ntelligence, 140(1/2):153–173, 2002.\n[61] A. A. Bulatov. Tractable conservative constraint satisfaction problems. In Proceedings of the\nSymposium on Logic in Computer Science (LICS), pages 321–330, Ottawa, Canada, 2003.\n[62] A. A. Bulatov. H-coloring dichotomy revisited. Theoretical Computer Science, 349(1):31–39,\n2005.\n[63] A. A. Bulatov. A dichotomy theorem for constraint satisfaction problems on a 3-element set.\nJournal of the ACM, 53(1):66–120, 2006.\n[64] A. A. Bulatov and V. Dalmau. A simple algorithm for Mal’tsev constraints. SIAM Journal on\nComputing, 36(1):16–27, 2006.\n[65] A. A. Bulatov and P. Jeavons. Algebraic structures in combinatorial problems. Technical report\nMATH-AL-4-2001, Technische Universit¨at Dresden, 2001.\n[66] A. A. Bulatov, A. A. Krokhin, and P. G. Jeavons. Classifying the complexity of constraints\nusing ﬁnite algebras. SIAM Journal on Computing, 34:720–742, 2005.\n[67] H. K. B¨uning and T. Lettmann. Propositional Logic: Deduction and Algorithms. Cambridge\nUniversity Press, 1999.\n[68] S. N. Burris and H. P. Sankappanavar. A Course in Universal Algebra. Springer Verlag, Berlin,\n1981.\n[69] P. J. Cameron. Transitivity of permutation groups on unordered sets. Mathematische\nZeitschrift, 148:127–139, 1976.\n[70] P. J. Cameron. Oligomorphic permutation groups. Cambridge University Press, Cambridge,\n1990.\n[71] G. Cantor.\n¨Uber unendliche,\nlineare Punktmannigfaltigkeiten. Mathematische Annalen,\n23:453–488, 1884.\n[72] H. Chen. A rendezvous of logic, complexity, and algebra. ACM Computing Surveys, 42(1),\n2009.\n[73] H. Chen and V. Dalmau. (Smart) look-ahead arc consistency and the pursuit of CSP tractabil-\nity. In Proceedings of CP, pages 182–196, 2004.\n[74] H. Chen and M. Grohe. Constraint satisfaction with succinctly speciﬁed relations. Journal of\nComputer and System Sciences, 76(8):847–860, 2010.\n\n260\nBIBLIOGRAPHY\n[75] G. Cherlin, S. Shelah, and N. Shi. Universal graphs with forbidden subgraphs and algebraic\nclosure. Advances in Applied Mathematics, 22:454–491, 1999.\n[76] D. Cohen, P. Jeavons, P. Jonsson, and M. Koubarakis. Building tractable disjunctive con-\nstraints. Journal of the ACM, 47(5):826–853, 2000.\n[77] D. A. Cohen, P. Jeavons, P. Jonsson, and M. Koubarakis. Building tractable disjunctive con-\nstraints. Journal of the ACM, 47(5):826–853, 2000.\n[78] T. Cornell. On determining the consistency of partial descriptions of trees. In Proceedings of\nthe ACL, pages 163–170, 1994.\n[79] J. Covington. Homogenizable relational structures. Illinois Journal of Mathematics, 34(4):731–\n743, 1990.\n[80] N. Creignou, P. G. Kolaitis, and H. Vollmer, editors. Complexity of Constraints - An Overview\nof Current Research Themes [Result of a Dagstuhl Seminar], volume 5250 of Lecture Notes in\nComputer Science. Springer, 2008.\n[81] B. Cz´ak´any. Minimal clones. Algebra Universalis, 54(1):73–89, 2005.\n[82] V. Dalmau. Linear datalog and bounded path duality of relational structures. Logical Methods\nin Computer Science, 1(1), 2005.\n[83] W. Deuber. A generalization of Ramsey’s theorem for regular trees. Journal of Combinatorial\nTheory, Series B, 18:18–23, 1975.\n[84] W. F. Dowling and J. H. Gallier. Linear-time algorithms for testing the satisﬁability of propo-\nsitional Horn formulae. The Journal of Logic Programming, 1(3):267–284, 1984.\n[85] T. Drakengren and P. Jonsson. Reasoning about set constraints applied to tractable inference\nin intuitionistic logic. Journal of Logic and Computation, 8(6):855–875, 1998.\n[86] T. Drakengren and P. Jonsson. Computational complexity of temporal constraint problems. In\nHandbook of Temporal Reasoning in Artiﬁcial Intelligence, pages 197–218. Elsevier, 2005.\n[87] M. Droste. Structure of partially ordered sets with transitive automorphism groups. AMS\nMemoir, 57(334), 1985.\n[88] I. D. Duentsch. Relation algebras and their application in temporal and spatial reasoning.\nArtiﬁcial Intelligence Review, 23:315–357, 2005.\n[89] I. D¨untsch, H. Wang, and S. McCloskey. A relation algebraic approach to the region connection\ncalculus. Theoretical Computer Science, 255:63–83, 2001.\n[90] H.-D. Ebbinghaus and J. Flum. Finite Model Theory. Springer, Berlin, Heidelberg, New York,\n1999. 2nd edition.\n[91] H.-D. Ebbinghaus, J. Flum, and W. Thomas. Mathematical Logic. Springer, Berlin, Heidelberg,\nNew York, 1984.\n[92] L. Egri, B. Larose, and P. Tesson. Symmetric datalog and constraint satisfaction problems in\nlogspace. In Proceedings of LICS, pages 193–202, 2007.\n[93] D. M. Evans. A closed oligomorphic permutation group without oligomorphic extremely\namenable subgroups. Announced at the workshop “Homogeneous structures” in Banﬀ, 2015.\n[94] G. Exoo. A lower bound for R(5, 5). Journal of Graph Theory, 13:97–98, 1989.\n[95] T. Feder and M. Y. Vardi. The computational structure of monotone monadic SNP and con-\nstraint satisfaction: a study through Datalog and group theory. SIAM Journal on Computing,\n28:57–104, 1999.\n[96] T. Feder and M. Y. Vardi. Homomorphism closed vs. existential positive. In Proceedings of\nLICS, pages 311–320, 2003.\n[97] R. Fra¨ıss´e. Sur l’extension aux relations de quelques propri´et´es des ordres. Annales Scientiﬁques\nde l’ ´Ecole Normale Sup´erieure, 71:363–388, 1954.\n[98] R. Fra¨ıss´e. Theory of Relations. Elsevier Science Ltd, North-Holland, 1986.\n[99] Z. Galil and N. Megiddo. Cyclic ordering is NP-complete. Theoretical Computer Science,\n5(2):179–182, 1977.\n[100] S. Gao. Invariant Descriptive Set Theory. Pure and applied mathematics. Taylor and Francis,\n2008.\n[101] M. Garey and D. Johnson. A guide to NP-completeness. CSLI Press, Stanford, 1978.\n[102] D. Geiger. Closed systems of functions and predicates. Paciﬁc Journal of Mathematics, 27:95–\n100, 1968.\n[103] A. Goerdt. On random ordering constraints. In Computer Science Russia (CSR), pages 105–\n116, 2009.\n[104] R. L. Graham and B. L. Rothschild. Ramsey’s theorem for n-parameter sets. Transactions of\nthe AMS, 159:257–292, 1971.\n[105] R. L. Graham, B. L. Rothschild, and J. H. Spencer. Ramsey theory. Wiley-Interscience Series\nin Discrete Mathematics and Optimization. John Wiley & Sons, Inc., New York, 1990. Second\nedition.\n\nBIBLIOGRAPHY\n261\n[106] E. E. Granirer. Extremely amenable semigroups 2. Mathematica Scandinavica, 20:93–113, 1967.\n[107] M. Grohe. The quest for a logic capturing PTIME. In Proceedings of LICS, pages 267–271,\n2008.\n[108] Y. Gurevich. Toward logic tailored for computational complexity. Computation and Proof The-\nory, pages 175–216, 1984.\n[109] W. Guttmann and M. Maucher. Variations on an ordering theme with constraints. In Proceed-\nings of TCS, pages 77–90, 2006.\n[110] L. Haddad and I. G. Rosenberg. Finite clones containing all permutations. Canadian Journal\nof Mathematics, 46(5):951–970, 1994.\n[111] D. Haskell and D. Macpherson. Cell decompositions of C-minimal structures. Annals of Pure\nand Applied Logic, 66:113–162, 1994.\n[112] L. Heindorf. The maximal clones on countable sets that include all permutations. Algebra\nUniversalis, 48:209–222, 2002.\n[113] P. Hell and J. Neˇsetˇril. On the complexity of H-coloring. Journal of Combinatorial Theory,\nSeries B, 48:92–110, 1990.\n[114] P. Hell and J. Neˇsetˇril. The core of a graph. Discrete Mathematics, 109:117–126, 1992.\n[115] J. W. Helton and J. Nie. Suﬃcient and necessary conditions for semideﬁnite representability\nof convex hulls and sets. SIAM Journal on Optimization, 20(2):759–791, 2009.\n[116] C. W. Henson. Countable homogeneous relational systems and categorical theories. Journal of\nSymbolic Logic, 37:494–500, 1972.\n[117] R. Hirsch. Expressive power and complexity in algebraic logic. Journal of Logic and Compu-\ntation, 7(3):309 – 351, 1997.\n[118] D. Hobby and R. McKenzie. The structure of ﬁnite algebras, volume 76 of Contemporary\nMathematics. American Mathematical Society, 1988.\n[119] W. Hodges. Model theory. Cambridge University Press, 1993.\n[120] W. Hodges. A shorter model theory. Cambridge University Press, Cambridge, 1997.\n[121] J. H˚astad, R. Manokaran, P. Raghavendra, and M. Charikar. Beating the random ordering is\nhard: Every ordering CSP is approximation resistant. SIAM Journal on Computing, 2011. To\nappear.\n[122] J. Hubiˇcka and J. Neˇsetˇril. Homomorphism and embedding universal structures for restricted\nclasses. ArXiv:0909.4939, 2009.\n[123] P. M. Idziak, P. Markovic, R. McKenzie, M. Valeriote, and R. Willard. Tractability and learn-\nability arising from algebras with few subpowers. SIAM Journal on Computing, 39(7):3023–\n3037, 2010.\n[124] K. J¨anich. Topologie. Springer, 2000. In German; seventh edition.\n[125] P. G. Jeavons and M. C. Cooper. Tractable constraints on ordered domains. Artiﬁcial Intelli-\ngence, 79(2):327–339, 1995.\n[126] P. Jonsson and C. B¨ackstr¨om. A unifying approach to temporal constraint reasoning. Artiﬁcial\nIntelligence, 102(1):143–155, 1998.\n[127] P. Jonsson and T. Drakengren. A complete classiﬁcation of tractability in RCC-5. Journal of\nArtiﬁcial Intelligence Research, 6:211–221, 1997.\n[128] M. Junker and M. Ziegler. The 116 reducts of (Q, <, a). Journal of Symbolic Logic, 74(3):861–\n884, 2008.\n[129] P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz. Constraint query languages. In Proceedings\nof Symposium on Principles of Database Systems (PODS), pages 299–313, 1990.\n[130] M. Karpinski, H. Kleine B¨uning, and P. H. Schmitt. On the computational complexity of quan-\ntiﬁed Horn clauses. In E. B¨orger, H. Kleine B¨uning, and M. M. Richter, editors, Proceedings\nof CSL, Lecture Notes in Computer Science, pages 129–137, 1987. 1st Workshop on Computer\nScience Logic, Karlsruhe, Germany.\n[131] R. Kaye and D. Macpherson, editors. Automorphisms of ﬁrst-order structures. Oxford Univer-\nsity Press, 1994.\n[132] A. Kechris, V. Pestov, and S. Todorcevic. Fraiss´e limits, Ramsey theory, and topological dy-\nnamics of automorphism groups. Geometric and Functional Analysis, 15(1):106–189, 2005.\n[133] J. Keisler. Reduced products and Horn classes. Transactions of the AMS, 117:307–328, 1965.\n[134] L. Khachiyan. A polynomial algorithm in linear programming. Doklady Akademii Nauk SSSR,\n244:1093–1097, 1979.\n[135] P. G. Kolaitis and M. Y. Vardi. The decision problem for the probabilities of higher-order\nproperties. In Proceedings of the Symposium on Theory of Computing (STOC), pages 425–\n435, 1987.\n[136] P. G. Kolaitis and M. Y. Vardi. Conjunctive-query containment and constraint satisfaction. In\nProceedings of Symposium on Principles of Database Systems (PODS), pages 205–213, 1998.\n\n262\nBIBLIOGRAPHY\n[137] S. Koppelberg. Projective boolean algebras. In Handbook of Boolean Algebras, volume 3, pages\n741–773. North Holland, Amsterdam-New York-Oxford- Tokyo, 1989.\n[138] M. Koubarakis. Tractable disjunctions of linear constraints: Basic results and applications to\ntemporal reasoning. Theoretical Computer Science, 266:311–339, 2001.\n[139] M. Krasner. G´en´eralisations et analogues de la th´eorie de Galois. In Congr`es de la Victoire,\nAssociation Fran¸caise pour l’Avancement des Sciences, pages 54–58, 1945.\n[140] A. A. Krokhin, P. Jeavons, and P. Jonsson. Reasoning about temporal relations: The tractable\nsubalgebras of Allen’s interval algebra. Journal of the ACM, 50(5):591–640, 2003.\n[141] G. Kun. Constraints, MMSNP, and expander relational structures. Combinatorica, 33(3):335–\n347, 2013.\n[142] P. B. Ladkin and R. D. Maddux. On binary constraint problems. Journal of the Association\nfor Computing Machinery, 41(3):435–469, 1994.\n[143] R. E. Ladner. On the structure of polynomial time reducibility. Journal of the ACM, 22(1):155–\n171, 1975.\n[144] B. Larose, C. Loten, and C. Tardif. A characterisation of ﬁrst-order constraint satisfaction\nproblems. Logical Methods in Computer Science, 3(4:6), 2007.\n[145] B. Larose and P. Tesson. Universal algebra and hardness results for constraint satisfaction\nproblems. Theoretical Computer Science, 410(18):1629–1647, 2009.\n[146] B. Larose, M. Valeriote, and L. Z´adori. Omitting types, bounded width and the ability to\ncount. International Journal of Algebra and Computation, 19(5), 2009.\n[147] B. Larose and L. Z´adori. Bounded width problems and algebras. Algebra Universalis, 56(3-\n4):439–466, 2007.\n[148] J.-L. Lassez and K. McAloon. Independence of negative constraints. In International Joint\nConference on Theory and Practice of Software Development (TAPSOFT), Volume 1, pages\n19–27, 1989.\n[149] J.-L. Lassez and K. McAloon. A constraint sequent calculus. In Proceedings of LICS, pages\n52–61, 1990.\n[150] G. Ligozat and J. Renz. What is a qualitative calculus? A general framework. In Proceedings\nof Paciﬁc Rim International Conferences on Artiﬁcial Intelligence (PRICAI), pages 53–64,\n2004.\n[151] R. Lyndon. The representation of relational algebras. Annals of Mathematics, 51(3):707–729,\n1950.\n[152] H. Machida and M. Pinsker. The minimal clones above the permutations. Semigroup Forum,\n75:181–211, 2007.\n[153] D. Macpherson. A survey of homogeneous structures. Discrete Mathematics, 311(15):1599–\n1634, 2011.\n[154] F. Madelaine. Constraint satisfaction problems and related logic. PhD-thesis, University of\nLeicester, 2003.\n[155] F. Madelaine and I. A. Stewart. Constraint satisfaction, logic and forbidden patterns. SIAM\nJournal on Computing, 37(1):132–163, 2007.\n[156] F. R. Madelaine. On the containment of forbidden patterns problems. In Proceedings of CP,\npages 345–359, 2010.\n[157] F. R. Madelaine and I. A. Stewart. Some problems not deﬁnable using structure homomor-\nphisms. Ars Combinatorica, 67:153–159, 2003.\n[158] D. Marker. Model Theory: An Introduction. Springer, New York, 2002.\n[159] M. Mar´oti and R. McKenzie. Existence theorems for weakly symmetric operations. Algebra\nUniversalis, 59(3), 2008.\n[160] K. Marriott and M. Odersky. Negative Boolean constraints. Theoretical Computer Science,\n160(1&2):365–380, 1996.\n[161] D. Marx. Tractable structures for constraint satisfaction with truth tables. Theory of Comput-\ning Systems, 48(3):444–464, 2011.\n[162] Y. V. Matiyasevich. Hilbert’s Tenth Problem. MIT Press, Cambridge, Massachusetts, 1993.\n[163] K. R. Milliken. A Ramsey theorem for trees. Journal of Combinatorial Theory, Series A,\n26(3):215 – 237, 1979.\n[164] R. H. M¨ohring, M. Skutella, and F. Stork. Scheduling with and/or precedence constraints.\nSIAM Journal on Computing, 33(2):393–415, 2004.\n[165] B. Nebel and H.-J. B¨urckert. Reasoning about temporal relations: A maximal tractable sub-\nclass of Allen’s interval algebra. Journal of the ACM, 42(1):43–66, 1995.\n[166] J. Neˇsetˇril. Ramsey theory. Handbook of Combinatorics, pages 1331–1403, 1995.\n[167] J. Neˇsetˇril. Ramsey classes and homogeneous structures. Combinatorics, Probability & Com-\nputing, 14(1-2):171–189, 2005.\n\nBIBLIOGRAPHY\n263\n[168] J. Neˇsetˇril and V. R¨odl. Ramsey classes of set systems. Journal of Combinatorial Theory,\nSeries A, 34(2):183–201, 1983.\n[169] J. Neˇsetˇril and V. R¨odl. The partite construction and Ramsey set systems. Discrete Mathe-\nmatics, 75(1-3):327–334, 1989.\n[170] J. Opatrny. Total ordering problem. SIAM Journal on Computing, 8(1):111–114, 1979.\n[171] C. H. Papadimitriou. Computational Complexity. Addison-Wesley, 1994.\n[172] C. H. Papadimitriou and M. Yannakakis. Optimization, approximation, and complexity classes.\nJournal of Computer and System Sciences, 43:425–440, 1991.\n[173] M. Pinsker. Maximal clones on uncountable sets that include all permutations. Algebra Uni-\nversalis, 54(2):129–148, 2005.\n[174] M. Pinsker. The number of unary clones containing the permutations on an inﬁnite set. Acta\nScientiarum Mathematicarum (Szeged), 71:461–467, 2005.\n[175] B. Poizat. A Course in Model Theory: An Introduction to Contemporary Mathematical Logic.\nSpringer, 2000.\n[176] E. L. Post. The two-valued iterative systems of mathematical logic. Annals of Mathematics\nStudies, 5, 1941.\n[177] M. V. Ramana. An exact duality theory for semideﬁnite programming and its complexity\nimplications. Mathematical Programming, 77:129–162, 1997.\n[178] O. Reingold. Undirected connectivity in log-space. Journal of the ACM, 55(4), 2008.\n[179] J. Renz and B. Nebel. On the complexity of qualitative spatial reasoning: A maximal tractable\nfragment of the region connection calculus. Artiﬁcial Intelligence, 108(1-2):69–123, 1999.\n[180] B. Rossman. Homomorphism preservation theorems. Journal of the ACM, 55(3), 2008.\n[181] D. Saracino. Model companions for ℵ0-categorical theories. Proceedings of the AMS, 39:591–\n598, 1973.\n[182] T. J. Schaefer. The complexity of satisﬁability problems. In Proceedings of the Symposium on\nTheory of Computing (STOC), pages 216–226, 1978.\n[183] U. Sch¨oning. Logic for Computer Scientists. Springer, 1989.\n[184] J. Schreier and Stanis law Marcin Ulam. ¨Uber die Permutationsgruppe der nat¨urlichen Zahlen-\nfolge. Studia Mathematica, 4:134–141, 1933.\n[185] A. Schrijver. Theory of Linear and Integer Programming. Wiley - Interscience Series in Discrete\nMathematics and Optimization, 1998.\n[186] G. Schwandtner. Datalog on inﬁnite structures. Dissertation, Humboldt-Universit¨at zu Berlin,\n2008.\n[187] M. H. Siggers. A strong Mal’cev condition for varieties omitting the unary type. Algebra Uni-\nversalis, 64(1):15–20, 2010.\n[188] H. Simmons. Large and small existentially closed structures. Journal of Symbolic Logic,\n41(2):379–390, 1976.\n[189] M. Steel. The complexity of reconstructing trees from qualitative characters and subtrees.\nJournal of Classiﬁcation, 9:91–116, 1992.\n[190] A. Szendrei. Clones in universal algebra. S´eminaire de Math´ematiques Sup´erieures. Les Presses\nde l’Universit´e de Montr´eal, 1986.\n[191] R. Tarjan. Depth-ﬁrst search and linear graph algorithms. SIAM Journal on Computing,\n1(2):146–160, 1972.\n[192] W. Taylor. Varieties obeying homotopy laws. Canadian Journal of Mathematics, 29:498–527,\n1977.\n[193] S. Thomas. Reducts of the random graph. Journal of Symbolic Logic, 56(1):176–181, 1991.\n[194] S. Thomas. Reducts of random hypergraphs. Annals of Pure and Applied Logic, 80(2):165–193,\n1996.\n[195] T. Tsankov. Unitary representations of oligomorphic groups. Geometric and Functional Anal-\nysis, 22(2):528–555, 2012.\n[196] R. Willard. Testing expressibility is hard. In Proceedings of CP, pages 9–23, 2010.\n[197] H. Wolkowicz, R. Saigal, and L. Vandenberghe, editors. Handbook of semideﬁnite programming:\ntheory, algorithms, and applications. Springer, 2000.\n[198] M. Wrona. Clausal descriptions of temporal relations. Personal Communication, 2008.",
    "pdf_filename": "Complexity Classification in Infinite-Domain Constraint Satisfaction.pdf"
}